diff -x .git -x inputs -Naur stamp-0.9.10/.patched stamp-g/.patched
--- stamp-0.9.10/.patched	2017-03-21 21:04:54.000000000 +0000
+++ stamp-g/.patched	2017-03-21 20:58:05.000000000 +0000
@@ -1 +0,0 @@
-patched
diff -x .git -x inputs -Naur stamp-0.9.10/.patched2 stamp-g/.patched2
--- stamp-0.9.10/.patched2	1970-01-01 01:00:00.000000000 +0100
+++ stamp-g/.patched2	2017-03-21 21:05:22.000000000 +0000
@@ -0,0 +1 @@
+patched
diff -x .git -x inputs -Naur stamp-0.9.10/CMakeLists.txt stamp-g/CMakeLists.txt
--- stamp-0.9.10/CMakeLists.txt	2017-03-21 15:28:47.000000000 +0000
+++ stamp-g/CMakeLists.txt	2017-03-21 11:12:45.000000000 +0000
@@ -1,81 +1,22 @@
 get_filename_component(LIB_DIR lib REALPATH)
 
-if(CMAKE_CXX_COMPILER_ID MATCHES "XL")
-  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -qalias=noansi")
-  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -qalias=noansi")
-elseif(CMAKE_CXX_COMPILER_ID MATCHES "GNU")
-  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=gnu99")
-endif()
-
 include_directories(lib)
+include_directories(${Galois_INCLUDE_DIRS})
 
-if(EXISTS /usr/global/tools/papi/bgqos_0/papi-5.0.1-V1R1M2/include)
-  set(PAPI_INCLUDE_DIRS /usr/global/tools/papi/bgqos_0/papi-5.0.1-V1R1M2/include)
-  set(PAPI_LIBRARIES /usr/global/tools/papi/bgqos_0/papi-5.0.1-V1R1M2/lib/libpapi.a rt)
-else()
-  set(PAPI_INCLUDE_DIRS /usr/lib64/papi-5.1.1/usr/include)
-  set(PAPI_LIBRARIES /usr/lib64/papi-5.1.1/usr/lib/libpapi.so rt)
-endif()
-
-if(USE_PAPI)
-  include_directories(${PAPI_INCLUDE_DIRS})
-  add_definitions(-DUSE_PAPI)
+if(CMAKE_CXX_COMPILER_ID MATCHES "GNU")
+  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=c99")
 endif()
 
-set(extra_sources)
-if(USE_STAMP_PALLOC)
-  add_definitions(-DSTAMP_PALLOC)
-  add_definitions(-DSIMULATOR)
-  set(extra_sources ${extra_sources} ${LIB_DIR}/memory.c)
-endif()
-if(USE_PAPI OR USE_SALLOC)
-  set(extra_sources ${extra_sources} ${LIB_DIR}/force_cxx_linker.cpp)
-endif()
-
-if(USE_SALLOC)
-  if(EXISTS /g/g14/nguyen91/local-bgq/lib/libtcmalloc_minimal.a)
-    set(SALLOC_LIB /g/g14/nguyen91/local-bgq/lib/libtcmalloc_minimal.a)
-  else()
-    set(SALLOC_LIB /h1/ddn/local/lib/libtcmalloc_minimal.a)
-  endif()
-endif()
-
-set(libraries ${CMAKE_THREAD_LIBS_INIT} m)
-
-if(USE_SALLOC)
-  set(libraries ${libraryes} ${SALLOC_LIB})
-endif()
-
-if(USE_PAPI)
-  set(libraries ${libraries} ${PAPI_LIBRARIES})
-endif()
-
-if(USE_STM)
-  add_definitions(-DSTM)
-  include_directories(${tinystm_INCLUDE_DIRS})
-  set(libraries ${libraries} ${tinystm_LIBRARIES})
-elseif(USE_XTM)
-  add_definitions(-DSTM)
-  add_definitions(-DXTM)
-  add_definitions(-DSIMULATOR)
-  if(USE_XTM_INLINE)
-    add_definitions(-DXTM_USE_INLINE_LOCKABLE)
-  endif()
-  include_directories(${XTM_INCLUDE_DIRS})
-  set(libraries ${libraries} ${XTM_LIBRARIES})
-elseif(USE_HTM)
+if(USE_HTM)
   add_definitions(-DHTM)
-  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -qtm")
-  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -qtm")
 endif()
 
 function(app name)
-  add_executable(${name} ${ARGN} ${extra_sources})
-  target_link_libraries(${name} ${libraries})
-  install(TARGETS ${name} RUNTIME DESTINATION bin)
+  add_executable(${name}g ${ARGN})
+  target_link_libraries(${name}g ${Galois_LIBRARIES})
+  install(TARGETS ${name}g RUNTIME DESTINATION bin)
 endfunction(app)
 
-
 add_subdirectory(bayes)
 add_subdirectory(genome)
 add_subdirectory(intruder)
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/CMakeLists.txt stamp-g/bayes/CMakeLists.txt
--- stamp-0.9.10/bayes/CMakeLists.txt	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/bayes/CMakeLists.txt	2017-03-21 18:20:54.000000000 +0000
@@ -4,22 +4,25 @@
 #
 # ==============================================================================
 
-add_definitions(-DLIST_NO_DUPLICATES -DLEARNER_TRY_REMOVE -DLEARNER_TRY_REVERSE)
+#add_definitions(-DLIST_NO_DUPLICATES -DLEARNER_TRY_REMOVE -DLEARNER_TRY_REVERSE)
+add_definitions(-DLEARNER_TRY_REMOVE -DLEARNER_TRY_REVERSE)
 
 set(sources
-        adtree.c
+        adtree.cpp
         bayes.c
 	data.c
-	learner.c
-	net.c
+	learner.cpp
+	net.cpp
 	sort.c
 	${LIB_DIR}/bitmap.c
-	${LIB_DIR}/list.c
+	${LIB_DIR}/deque.cpp
+        #${LIB_DIR}/list.c
 	${LIB_DIR}/mt19937ar.c
-	${LIB_DIR}/queue.c
+        #${LIB_DIR}/queue.c
 	${LIB_DIR}/random.c
-	${LIB_DIR}/thread.c
-	${LIB_DIR}/vector.c)
+        ${LIB_DIR}/thread.cpp
+        #${LIB_DIR}/vector.c
+)
 
 app(bayes ${sources})
 
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/adtree.c stamp-g/bayes/adtree.c
--- stamp-0.9.10/bayes/adtree.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/bayes/adtree.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,715 +0,0 @@
-/* =============================================================================
- *
- * adtree.c
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * Reference:
- *
- * A. Moore and M.-S. Lee. Cached sufficient statistics for efficient machine
- * learning with large datasets. Journal of Artificial Intelligence Research 8
- * (1998), pp 67-91.
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <stdlib.h>
-#include "adtree.h"
-#include "data.h"
-#include "query.h"
-#include "utility.h"
-#include "vector.h"
-
-
-/* =============================================================================
- * allocNode
- * =============================================================================
- */
-adtree_node_t*
-allocNode (long index)
-{
-    adtree_node_t* nodePtr;
-
-    nodePtr = (adtree_node_t*)malloc(sizeof(adtree_node_t));
-    if (nodePtr) {
-        nodePtr->varyVectorPtr = vector_alloc(1);
-        if (nodePtr->varyVectorPtr == NULL) {
-            free(nodePtr);
-            return NULL;
-        }
-        nodePtr->index = index;
-        nodePtr->value = -1;
-        nodePtr->count = -1;
-    }
-
-    return nodePtr;
-}
-
-
-/* =============================================================================
- * freeNode
- * =============================================================================
- */
-void
-freeNode (adtree_node_t* nodePtr)
-{
-    vector_free(nodePtr->varyVectorPtr);
-    free(nodePtr);
-}
-
-
-/* =============================================================================
- * allocVary
- * =============================================================================
- */
-adtree_vary_t*
-allocVary (long index)
-{
-    adtree_vary_t* varyPtr;
-
-    varyPtr = (adtree_vary_t*)malloc(sizeof(adtree_vary_t));
-    if (varyPtr) {
-        varyPtr->index = index;
-        varyPtr->mostCommonValue = -1;
-        varyPtr->zeroNodePtr = NULL;
-        varyPtr->oneNodePtr = NULL;
-    }
-
-    return varyPtr;
-}
-
-
-/* =============================================================================
- * freeVary
- * =============================================================================
- */
-void
-freeVary (adtree_vary_t* varyPtr)
-{
-    free(varyPtr);
-}
-
-
-/* =============================================================================
- * adtree_alloc
- * =============================================================================
- */
-adtree_t*
-adtree_alloc ()
-{
-    adtree_t* adtreePtr;
-
-    adtreePtr = (adtree_t*)malloc(sizeof(adtree_t));
-    if (adtreePtr) {
-        adtreePtr->numVar = -1L;
-        adtreePtr->numRecord = -1L;
-        adtreePtr->rootNodePtr = NULL;
-    }
-
-    return adtreePtr;
-}
-
-
-/* =============================================================================
- * freeNodes
- * =============================================================================
- */
-static void
-freeNodes (adtree_node_t* nodePtr)
-{
-    if (nodePtr) {
-        vector_t* varyVectorPtr = nodePtr->varyVectorPtr;
-        long v;
-        long numVary = vector_getSize(varyVectorPtr);
-        for (v = 0; v < numVary; v++) {
-            adtree_vary_t* varyPtr = (adtree_vary_t*)vector_at(varyVectorPtr, v);
-            freeNodes(varyPtr->zeroNodePtr);
-            freeNodes(varyPtr->oneNodePtr);
-            freeVary(varyPtr);
-        }
-        freeNode(nodePtr);
-    }
-}
-
-
-/* =============================================================================
- * adtree_free
- * =============================================================================
- */
-void
-adtree_free (adtree_t* adtreePtr)
-{
-    freeNodes(adtreePtr->rootNodePtr);
-    free(adtreePtr);
-}
-
-
-static adtree_vary_t*
-makeVary (long parentIndex,
-          long index,
-          long start,
-          long numRecord,
-          data_t* dataPtr);
-
-static adtree_node_t*
-makeNode (long parentIndex,
-          long index,
-          long start,
-          long numRecord,
-          data_t* dataPtr);
-
-
-/* =============================================================================
- * makeVary
- * =============================================================================
- */
-static adtree_vary_t*
-makeVary (long parentIndex,
-          long index,
-          long start,
-          long numRecord,
-          data_t* dataPtr)
-{
-    adtree_vary_t* varyPtr = allocVary(index);
-    assert(varyPtr);
-
-    if ((parentIndex + 1 != index) && (numRecord > 1)) {
-        data_sort(dataPtr, start, numRecord, index);
-    }
-
-    long num0 = data_findSplit(dataPtr, start, numRecord, index);
-    long num1 = numRecord - num0;
-
-    long mostCommonValue = ((num0 >= num1) ? 0 : 1);
-    varyPtr->mostCommonValue = mostCommonValue;
-
-    if (num0 == 0 || mostCommonValue == 0) {
-        varyPtr->zeroNodePtr = NULL;
-    } else {
-        varyPtr->zeroNodePtr =
-            makeNode(index, index, start, num0, dataPtr);
-        varyPtr->zeroNodePtr->value = 0;
-    }
-
-    if (num1 == 0 || mostCommonValue == 1) {
-        varyPtr->oneNodePtr = NULL;
-    } else {
-        varyPtr->oneNodePtr =
-            makeNode(index, index, (start + num0), num1, dataPtr);
-        varyPtr->oneNodePtr->value = 1;
-    }
-
-    return varyPtr;
-}
-
-
-/* =============================================================================
- * makeNode
- * =============================================================================
- */
-static adtree_node_t*
-makeNode (long parentIndex,
-          long index,
-          long start,
-          long numRecord,
-          data_t* dataPtr)
-{
-    adtree_node_t* nodePtr = allocNode(index);
-    assert(nodePtr);
-
-    nodePtr->count = numRecord;
-
-    vector_t* varyVectorPtr = nodePtr->varyVectorPtr;
-
-    long v;
-    long numVar = dataPtr->numVar;
-    for (v = (index + 1); v < numVar; v++) {
-        adtree_vary_t* varyPtr =
-            makeVary(parentIndex, v, start, numRecord, dataPtr);
-        assert(varyPtr);
-        bool_t status = vector_pushBack(varyVectorPtr, (void*)varyPtr);
-        assert(status);
-    }
-
-    return nodePtr;
-}
-
-
-/* =============================================================================
- * adtree_make
- * -- Records in dataPtr will get rearranged
- * =============================================================================
- */
-void
-adtree_make (adtree_t* adtreePtr, data_t* dataPtr)
-{
-    long numRecord = dataPtr->numRecord;
-    adtreePtr->numVar = dataPtr->numVar;
-    adtreePtr->numRecord = dataPtr->numRecord;
-    data_sort(dataPtr, 0, numRecord, 0);
-    adtreePtr->rootNodePtr = makeNode(-1, -1, 0, numRecord, dataPtr);
-}
-
-
-/* =============================================================================
- * getCount
- * =============================================================================
- */
-static long
-getCount (adtree_node_t* nodePtr,
-          long i,
-          long q,
-          vector_t* queryVectorPtr,
-          long lastQueryIndex,
-          adtree_t* adtreePtr)
-{
-    if (nodePtr == NULL) {
-        return 0;
-    }
-
-    long nodeIndex = nodePtr->index;
-    if (nodeIndex >= lastQueryIndex) {
-        return nodePtr->count;
-    }
-
-    long count = 0L;
-
-    query_t* queryPtr = (query_t*)vector_at(queryVectorPtr, q);
-    if (!queryPtr) {
-        return nodePtr->count;
-    }
-    long queryIndex = queryPtr->index;
-    assert(queryIndex <= lastQueryIndex);
-    vector_t* varyVectorPtr = nodePtr->varyVectorPtr;
-    adtree_vary_t* varyPtr =
-        (adtree_vary_t*)vector_at(varyVectorPtr,
-                                  (queryIndex - nodeIndex - 1));
-    assert(varyPtr);
-
-    long queryValue = queryPtr->value;
-
-    if (queryValue == varyPtr->mostCommonValue) {
-
-        /*
-         * We do not explicitly store the counts for the most common value.
-         * We can calculate it by finding the count of the query without
-         * the current (superCount) and subtracting the count for the
-         * query with the current toggled (invertCount).
-         */
-        long numQuery = vector_getSize(queryVectorPtr);
-        vector_t* superQueryVectorPtr = PVECTOR_ALLOC(numQuery - 1);
-        assert(superQueryVectorPtr);
-
-        long qq;
-        for (qq = 0; qq < numQuery; qq++) {
-            if (qq != q) {
-                bool_t status = vector_pushBack(superQueryVectorPtr,
-                                                vector_at(queryVectorPtr, qq));
-                assert(status);
-            }
-        }
-        long superCount = adtree_getCount(adtreePtr, superQueryVectorPtr);
-
-        PVECTOR_FREE(superQueryVectorPtr);
-
-        long invertCount;
-        if (queryValue == 0) {
-            queryPtr->value = 1;
-            invertCount = getCount(nodePtr,
-                                   i,
-                                   q,
-                                   queryVectorPtr,
-                                   lastQueryIndex,
-                                   adtreePtr);
-            queryPtr->value = 0;
-        } else {
-            queryPtr->value = 0;
-            invertCount = getCount(nodePtr,
-                                   i,
-                                   q,
-                                   queryVectorPtr,
-                                   lastQueryIndex,
-                                   adtreePtr);
-            queryPtr->value = 1;
-        }
-        count += superCount - invertCount;
-
-    } else {
-
-        if (queryValue == 0) {
-            count += getCount(varyPtr->zeroNodePtr,
-                              (i + 1),
-                              (q + 1),
-                              queryVectorPtr,
-                              lastQueryIndex,
-                              adtreePtr);
-        } else if (queryValue == 1) {
-            count += getCount(varyPtr->oneNodePtr,
-                              (i + 1),
-                              (q + 1),
-                              queryVectorPtr,
-                              lastQueryIndex,
-                              adtreePtr);
-        } else { /* QUERY_VALUE_WILDCARD */
-#if 0
-            count += getCount(varyPtr->zeroNodePtr,
-                              (i + 1),
-                              (q + 1),
-                              queryVectorPtr,
-                              lastQueryIndex,
-                              adtreePtr);
-            count += getCount(varyPtr->oneNodePtr,
-                              (i + 1),
-                              (q + 1),
-                              queryVectorPtr,
-                              lastQueryIndex,
-                              adtreePtr);
-#else
-            assert(0); /* catch bugs in learner */
-#endif
-        }
-
-    }
-
-    return count;
-}
-
-
-/* =============================================================================
- * adtree_getCount
- * -- queryVector must consist of queries sorted by id
- * =============================================================================
- */
-long
-adtree_getCount (adtree_t* adtreePtr, vector_t* queryVectorPtr)
-{
-    adtree_node_t* rootNodePtr = adtreePtr->rootNodePtr;
-    if (rootNodePtr == NULL) {
-        return 0;
-    }
-
-    long lastQueryIndex = -1L;
-    long numQuery = vector_getSize(queryVectorPtr);
-    if (numQuery > 0) {
-        query_t* lastQueryPtr = (query_t*)vector_at(queryVectorPtr, (numQuery - 1));
-        lastQueryIndex = lastQueryPtr->index;
-    }
-
-    return getCount(rootNodePtr,
-                    -1,
-                    0,
-                    queryVectorPtr,
-                    lastQueryIndex,
-                    adtreePtr);
-}
-
-
-/* #############################################################################
- * TEST_ADTREE
- * #############################################################################
- */
-#ifdef TEST_ADTREE
-
-#include <stdio.h>
-#include "timer.h"
-
-static void printNode (adtree_node_t* nodePtr);
-static void printVary (adtree_vary_t* varyPtr);
-
-bool_t global_doPrint = FALSE;
-
-
-static void
-printData (data_t* dataPtr)
-{
-    long numVar = dataPtr->numVar;
-    long numRecord = dataPtr->numRecord;
-
-    long r;
-    for (r = 0; r < numRecord; r++) {
-        printf("%4li: ", r);
-        char* record = data_getRecord(dataPtr, r);
-        assert(record);
-        long v;
-        for (v = 0; v < numVar; v++) {
-            printf("%li", (long)record[v]);
-        }
-        puts("");
-    }
-}
-
-
-static void
-printNode (adtree_node_t* nodePtr)
-{
-    if (nodePtr) {
-        printf("[node] index=%li value=%li count=%li\n",
-               nodePtr->index, nodePtr->value, nodePtr->count);
-        vector_t* varyVectorPtr = nodePtr->varyVectorPtr;
-        long v;
-        long numVary = vector_getSize(varyVectorPtr);
-        for (v = 0; v < numVary; v++) {
-            adtree_vary_t* varyPtr = (adtree_vary_t*)vector_at(varyVectorPtr, v);
-            printVary(varyPtr);
-        }
-    }
-    puts("[up]");
-}
-
-
-static void
-printVary (adtree_vary_t* varyPtr)
-{
-    if (varyPtr) {
-        printf("[vary] index=%li\n", varyPtr->index);
-        printNode(varyPtr->zeroNodePtr);
-        printNode(varyPtr->oneNodePtr);
-    }
-    puts("[up]");
-}
-
-
-static void
-printAdtree (adtree_t* adtreePtr)
-{
-    printNode(adtreePtr->rootNodePtr);
-}
-
-
-static void
-printQuery (vector_t* queryVectorPtr)
-{
-    printf("[");
-    long q;
-    long numQuery = vector_getSize(queryVectorPtr);
-    for (q = 0; q < numQuery; q++) {
-        query_t* queryPtr = (query_t*)vector_at(queryVectorPtr, q);
-        printf("%li:%li ", queryPtr->index, queryPtr->value);
-    }
-    printf("]");
-}
-
-
-static long
-countData (data_t* dataPtr, vector_t* queryVectorPtr)
-{
-    long count = 0;
-    long numQuery = vector_getSize(queryVectorPtr);
-
-    long r;
-    long numRecord = dataPtr->numRecord;
-    for (r = 0; r < numRecord; r++) {
-        char* record = data_getRecord(dataPtr, r);
-        bool_t isMatch = TRUE;
-        long q;
-        for (q = 0; q < numQuery; q++) {
-            query_t* queryPtr = (query_t*)vector_at(queryVectorPtr, q);
-            long queryValue = queryPtr->value;
-            if ((queryValue != QUERY_VALUE_WILDCARD) &&
-                ((char)queryValue) != record[queryPtr->index])
-            {
-                isMatch = FALSE;
-                break;
-            }
-        }
-        if (isMatch) {
-            count++;
-        }
-    }
-
-    return count;
-}
-
-
-static void
-testCount (adtree_t* adtreePtr,
-           data_t* dataPtr,
-           vector_t* queryVectorPtr,
-           long index,
-           long numVar)
-{
-    if (index >= numVar) {
-        return;
-    }
-
-    long count1 = adtree_getCount(adtreePtr, queryVectorPtr);
-    long count2 = countData(dataPtr, queryVectorPtr);
-    if (global_doPrint) {
-        printQuery(queryVectorPtr);
-        printf(" count1=%li count2=%li\n", count1, count2);
-        fflush(stdout);
-    }
-    assert(count1 == count2);
-
-    query_t query;
-
-    long i;
-    for (i = 1; i < numVar; i++) {
-        query.index = index + i;
-        bool_t status = vector_pushBack(queryVectorPtr, (void*)&query);
-        assert(status);
-
-        query.value = 0;
-        testCount(adtreePtr, dataPtr, queryVectorPtr, query.index, numVar);
-
-        query.value = 1;
-        testCount(adtreePtr, dataPtr, queryVectorPtr, query.index, numVar);
-
-        vector_popBack(queryVectorPtr);
-    }
-}
-
-
-static void
-testCounts (adtree_t* adtreePtr, data_t* dataPtr)
-{
-    long numVar = dataPtr->numVar;
-    vector_t* queryVectorPtr = vector_alloc(numVar);
-    long v;
-    for (v = -1; v < numVar; v++) {
-        testCount(adtreePtr, dataPtr, queryVectorPtr, v, dataPtr->numVar);
-    }
-    vector_free(queryVectorPtr);
-}
-
-
-static void
-test (long numVar, long numRecord)
-{
-    random_t* randomPtr = random_alloc();
-    data_t* dataPtr = data_alloc(numVar, numRecord, randomPtr);
-    assert(dataPtr);
-    data_generate(dataPtr, 0, 10, 10);
-    if (global_doPrint) {
-        printData(dataPtr);
-    }
-
-    data_t* copyDataPtr = data_alloc(numVar, numRecord, randomPtr);
-    assert(copyDataPtr);
-    data_copy(copyDataPtr, dataPtr);
-
-    adtree_t* adtreePtr = adtree_alloc();
-    assert(adtreePtr);
-
-    TIMER_T start;
-    TIMER_READ(start);
-
-    adtree_make(adtreePtr, copyDataPtr);
-
-    TIMER_T stop;
-    TIMER_READ(stop);
-
-    printf("%lf\n", TIMER_DIFF_SECONDS(start, stop));
-
-    if (global_doPrint) {
-        printAdtree(adtreePtr);
-    }
-
-    testCounts(adtreePtr, dataPtr);
-
-    adtree_free(adtreePtr);
-    random_free(randomPtr);
-    data_free(dataPtr);
-}
-
-
-int
-main ()
-{
-    puts("Starting...");
-
-    puts("Test 1:");
-    test(3, 8);
-
-    puts("Test 2:");
-    test(4, 64);
-
-    puts("Test 3:");
-    test(8, 256);
-
-    puts("Test 4:");
-    test(12, 256);
-
-    puts("Test 5:");
-    test(48, 1024);
-
-    puts("All tests passed.");
-
-    return 0;
-}
-
-
-#endif /* TEST_ADTREE */
-
-
-/* =============================================================================
- *
- * End of adtree.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/adtree.cpp stamp-g/bayes/adtree.cpp
--- stamp-0.9.10/bayes/adtree.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-g/bayes/adtree.cpp	2017-03-21 18:18:20.000000000 +0000
@@ -0,0 +1,748 @@
+/* =============================================================================
+ *
+ * adtree.c
+ *
+ * =============================================================================
+ *
+ * Copyright (C) Stanford University, 2006.  All Rights Reserved.
+ * Author: Chi Cao Minh
+ *
+ * =============================================================================
+ *
+ * Reference:
+ *
+ * A. Moore and M.-S. Lee. Cached sufficient statistics for efficient machine
+ * learning with large datasets. Journal of Artificial Intelligence Research 8
+ * (1998), pp 67-91.
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+
+
+#include <assert.h>
+#include <stdlib.h>
+#include "adtree.h"
+#include "data.h"
+#include "query.h"
+#include "utility.h"
+#include "vector.h"
+
+#include <iostream>
+
+/* =============================================================================
+ * allocNode
+ * =============================================================================
+ */
+adtree_node_t*
+allocNode (long index)
+{
+    adtree_node_t* nodePtr;
+
+    nodePtr = (adtree_node_t*)malloc(sizeof(adtree_node_t));
+    if (nodePtr) {
+        nodePtr->varyVectorPtr = vector_alloc(1);
+        if (nodePtr->varyVectorPtr == NULL) {
+            free(nodePtr);
+            return NULL;
+        }
+        nodePtr->index = index;
+        nodePtr->value = -1;
+        nodePtr->count = -1;
+    }
+
+    return nodePtr;
+}
+
+
+/* =============================================================================
+ * freeNode
+ * =============================================================================
+ */
+void
+freeNode (adtree_node_t* nodePtr)
+{
+    vector_free(nodePtr->varyVectorPtr);
+    free(nodePtr);
+}
+
+
+/* =============================================================================
+ * allocVary
+ * =============================================================================
+ */
+adtree_vary_t*
+allocVary (long index)
+{
+    adtree_vary_t* varyPtr;
+
+    varyPtr = (adtree_vary_t*)malloc(sizeof(adtree_vary_t));
+    if (varyPtr) {
+        varyPtr->index = index;
+        varyPtr->mostCommonValue = -1;
+        varyPtr->zeroNodePtr = NULL;
+        varyPtr->oneNodePtr = NULL;
+    }
+
+    return varyPtr;
+}
+
+
+/* =============================================================================
+ * freeVary
+ * =============================================================================
+ */
+void
+freeVary (adtree_vary_t* varyPtr)
+{
+    free(varyPtr);
+}
+
+
+/* =============================================================================
+ * adtree_alloc
+ * =============================================================================
+ */
+adtree_t*
+adtree_alloc ()
+{
+    adtree_t* adtreePtr;
+
+    adtreePtr = (adtree_t*)malloc(sizeof(adtree_t));
+    if (adtreePtr) {
+        adtreePtr->numVar = -1L;
+        adtreePtr->numRecord = -1L;
+        adtreePtr->rootNodePtr = NULL;
+    }
+
+    return adtreePtr;
+}
+
+
+/* =============================================================================
+ * freeNodes
+ * =============================================================================
+ */
+static void
+freeNodes (adtree_node_t* nodePtr)
+{
+    if (nodePtr) {
+        vector_t* varyVectorPtr = nodePtr->varyVectorPtr;
+        long v;
+        //long numVary = vector_getSize(varyVectorPtr);
+        list_iter_t it;
+        list_iter_reset(&it, varyVectorPtr);
+        for (v = 0; list_iter_hasNext(&it, varyVectorPtr)/*v < numVary*/; v++) {
+            adtree_vary_t* varyPtr = (adtree_vary_t*)list_iter_next(&it, varyVectorPtr);//vector_at(varyVectorPtr, v);
+            freeNodes(varyPtr->zeroNodePtr);
+            freeNodes(varyPtr->oneNodePtr);
+            freeVary(varyPtr);
+        }
+        freeNode(nodePtr);
+    }
+}
+
+
+/* =============================================================================
+ * adtree_free
+ * =============================================================================
+ */
+void
+adtree_free (adtree_t* adtreePtr)
+{
+    freeNodes(adtreePtr->rootNodePtr);
+    free(adtreePtr);
+}
+
+
+static adtree_vary_t*
+makeVary (long parentIndex,
+          long index,
+          long start,
+          long numRecord,
+          data_t* dataPtr);
+
+static adtree_node_t*
+makeNode (long parentIndex,
+          long index,
+          long start,
+          long numRecord,
+          data_t* dataPtr);
+
+
+/* =============================================================================
+ * makeVary
+ * =============================================================================
+ */
+static adtree_vary_t*
+makeVary (long parentIndex,
+          long index,
+          long start,
+          long numRecord,
+          data_t* dataPtr)
+{
+    adtree_vary_t* varyPtr = allocVary(index);
+    assert(varyPtr);
+
+    if ((parentIndex + 1 != index) && (numRecord > 1)) {
+        data_sort(dataPtr, start, numRecord, index);
+    }
+
+    long num0 = data_findSplit(dataPtr, start, numRecord, index);
+    long num1 = numRecord - num0;
+
+    long mostCommonValue = ((num0 >= num1) ? 0 : 1);
+    varyPtr->mostCommonValue = mostCommonValue;
+
+    if (num0 == 0 || mostCommonValue == 0) {
+        varyPtr->zeroNodePtr = NULL;
+    } else {
+        varyPtr->zeroNodePtr =
+            makeNode(index, index, start, num0, dataPtr);
+        varyPtr->zeroNodePtr->value = 0;
+    }
+
+    if (num1 == 0 || mostCommonValue == 1) {
+        varyPtr->oneNodePtr = NULL;
+    } else {
+        varyPtr->oneNodePtr =
+            makeNode(index, index, (start + num0), num1, dataPtr);
+        varyPtr->oneNodePtr->value = 1;
+    }
+
+    return varyPtr;
+}
+
+
+/* =============================================================================
+ * makeNode
+ * =============================================================================
+ */
+static adtree_node_t*
+makeNode (long parentIndex,
+          long index,
+          long start,
+          long numRecord,
+          data_t* dataPtr)
+{
+    adtree_node_t* nodePtr = allocNode(index);
+    assert(nodePtr);
+
+    nodePtr->count = numRecord;
+
+    vector_t* varyVectorPtr = nodePtr->varyVectorPtr;
+
+    long v;
+    long numVar = dataPtr->numVar;
+    for (v = (index + 1); v < numVar; v++) {
+        adtree_vary_t* varyPtr =
+            makeVary(parentIndex, v, start, numRecord, dataPtr);
+        assert(varyPtr);
+        bool_t status = vector_pushBack(varyVectorPtr, (void*)varyPtr);
+        assert(status);
+    }
+
+    return nodePtr;
+}
+
+
+/* =============================================================================
+ * adtree_make
+ * -- Records in dataPtr will get rearranged
+ * =============================================================================
+ */
+void
+adtree_make (adtree_t* adtreePtr, data_t* dataPtr)
+{
+    long numRecord = dataPtr->numRecord;
+    adtreePtr->numVar = dataPtr->numVar;
+    adtreePtr->numRecord = dataPtr->numRecord;
+    data_sort(dataPtr, 0, numRecord, 0);
+    adtreePtr->rootNodePtr = makeNode(-1, -1, 0, numRecord, dataPtr);
+}
+
+
+/* =============================================================================
+ * getCount
+ * =============================================================================
+ */
+static long
+getCount (adtree_node_t* nodePtr,
+          long i,
+          long q,
+          vector_t* queryVectorPtr,
+          long lastQueryIndex,
+          adtree_t* adtreePtr)
+{
+    if (nodePtr == NULL) {
+        return 0;
+    }
+
+    long nodeIndex = nodePtr->index;
+    if (nodeIndex >= lastQueryIndex) {
+        return nodePtr->count;
+    }
+
+    long count = 0L;
+
+    // TODO check that linear scan isn't too expansive
+    query_t* queryPtr = NULL;//(query_t*)vector_at(queryVectorPtr, q);
+    if (q >= 0 && (unsigned)q < queryVectorPtr->size()) {
+        auto Qit = queryVectorPtr->begin();
+        std::advance(Qit, q);
+        queryPtr = (query_t*) *Qit;
+#if 0
+        list_iter_t Qit;
+        list_iter_reset(&Qit, queryVectorPtr);
+        for (long Q = 0; Q < q + 1; ++Q)
+            queryPtr = (query_t*) list_iter_next(&Qit, queryVectorPtr);
+#endif
+    }
+    if (!queryPtr) {
+        return nodePtr->count;
+    }
+    long queryIndex = queryPtr->index;
+    assert(queryIndex <= lastQueryIndex);
+    vector_t* varyVectorPtr = nodePtr->varyVectorPtr;
+    adtree_vary_t* varyPtr = NULL;
+    //    (adtree_vary_t*)vector_at(varyVectorPtr,
+    //                              (queryIndex - nodeIndex - 1));
+#if 0
+    list_iter_t Vit;
+    list_iter_reset(&Vit, varyVectorPtr);
+    for (long V = 0; V <= (queryIndex - nodeIndex - 1); ++V)
+        varyPtr = (adtree_vary_t*) list_iter_next(&Vit, varyVectorPtr);
+#endif
+    auto Vit = varyVectorPtr->begin();
+    std::advance(Vit, (queryIndex - nodeIndex - 1));
+    varyPtr = (adtree_vary_t*) *Vit;
+    assert(varyPtr);
+
+    long queryValue = queryPtr->value;
+
+    if (queryValue == varyPtr->mostCommonValue) {
+
+        /*
+         * We do not explicitly store the counts for the most common value.
+         * We can calculate it by finding the count of the query without
+         * the current (superCount) and subtracting the count for the
+         * query with the current toggled (invertCount).
+         */
+        //long numQuery = vector_getSize(queryVectorPtr);
+        //vector_t* superQueryVectorPtr = PVECTOR_ALLOC(numQuery - 1);
+        vector_t superQueryVector;
+        //assert(superQueryVectorPtr);
+
+        auto ii = queryVectorPtr->begin();
+        auto ei = queryVectorPtr->end();
+
+        long qq;
+        for (qq = 0; ii != ei; qq++, ++ii) {
+            if (qq != q) {
+                superQueryVector.push_back(*ii);
+                //assert(status);
+            }
+        }
+        long superCount = adtree_getCount(adtreePtr, &superQueryVector);
+
+        //PVECTOR_FREE(superQueryVectorPtr);
+
+        long invertCount;
+        if (queryValue == 0) {
+            queryPtr->value = 1;
+            invertCount = getCount(nodePtr,
+                                   i,
+                                   q,
+                                   queryVectorPtr,
+                                   lastQueryIndex,
+                                   adtreePtr);
+            queryPtr->value = 0;
+        } else {
+            queryPtr->value = 0;
+            invertCount = getCount(nodePtr,
+                                   i,
+                                   q,
+                                   queryVectorPtr,
+                                   lastQueryIndex,
+                                   adtreePtr);
+            queryPtr->value = 1;
+        }
+        count += superCount - invertCount;
+
+    } else {
+
+        if (queryValue == 0) {
+            count += getCount(varyPtr->zeroNodePtr,
+                              (i + 1),
+                              (q + 1),
+                              queryVectorPtr,
+                              lastQueryIndex,
+                              adtreePtr);
+        } else if (queryValue == 1) {
+            count += getCount(varyPtr->oneNodePtr,
+                              (i + 1),
+                              (q + 1),
+                              queryVectorPtr,
+                              lastQueryIndex,
+                              adtreePtr);
+        } else { /* QUERY_VALUE_WILDCARD */
+#if 0
+            count += getCount(varyPtr->zeroNodePtr,
+                              (i + 1),
+                              (q + 1),
+                              queryVectorPtr,
+                              lastQueryIndex,
+                              adtreePtr);
+            count += getCount(varyPtr->oneNodePtr,
+                              (i + 1),
+                              (q + 1),
+                              queryVectorPtr,
+                              lastQueryIndex,
+                              adtreePtr);
+#else
+            assert(0); /* catch bugs in learner */
+#endif
+        }
+
+    }
+
+    return count;
+}
+
+
+/* =============================================================================
+ * adtree_getCount
+ * -- queryVector must consist of queries sorted by id
+ * =============================================================================
+ */
+long
+adtree_getCount (adtree_t* adtreePtr, vector_t* queryVectorPtr)
+{
+    adtree_node_t* rootNodePtr = adtreePtr->rootNodePtr;
+    if (rootNodePtr == NULL) {
+        return 0;
+    }
+
+    long lastQueryIndex = -1L;
+    long numQuery = vector_getSize(queryVectorPtr);
+    if (numQuery > 0) {
+        query_t* lastQueryPtr = (query_t*)vector_back(queryVectorPtr); //vector_at(queryVectorPtr, (numQuery - 1));
+        lastQueryIndex = lastQueryPtr->index;
+    }
+
+    return getCount(rootNodePtr,
+                    -1,
+                    0,
+                    queryVectorPtr,
+                    lastQueryIndex,
+                    adtreePtr);
+}
+
+
+/* #############################################################################
+ * TEST_ADTREE
+ * #############################################################################
+ */
+#ifdef TEST_ADTREE
+
+#include <stdio.h>
+#include "timer.h"
+
+static void printNode (adtree_node_t* nodePtr);
+static void printVary (adtree_vary_t* varyPtr);
+
+bool_t global_doPrint = FALSE;
+
+
+static void
+printData (data_t* dataPtr)
+{
+    long numVar = dataPtr->numVar;
+    long numRecord = dataPtr->numRecord;
+
+    long r;
+    for (r = 0; r < numRecord; r++) {
+        printf("%4li: ", r);
+        char* record = data_getRecord(dataPtr, r);
+        assert(record);
+        long v;
+        for (v = 0; v < numVar; v++) {
+            printf("%li", (long)record[v]);
+        }
+        puts("");
+    }
+}
+
+
+static void
+printNode (adtree_node_t* nodePtr)
+{
+    if (nodePtr) {
+        printf("[node] index=%li value=%li count=%li\n",
+               nodePtr->index, nodePtr->value, nodePtr->count);
+        vector_t* varyVectorPtr = nodePtr->varyVectorPtr;
+        long v;
+        //long numVary = vector_getSize(varyVectorPtr);
+        list_iter_t it;
+        list_iter_reset(&it, varyVectorPtr);
+        for (v = 0; list_iter_hasNext(&it, varyVectorPtr)/*v < numVary*/; v++) {
+            adtree_vary_t* varyPtr = (adtree_vary_t*)list_iter_next(&it, varyVectorPtr);//vector_at(varyVectorPtr, v);
+            printVary(varyPtr);
+        }
+    }
+    puts("[up]");
+}
+
+
+static void
+printVary (adtree_vary_t* varyPtr)
+{
+    if (varyPtr) {
+        printf("[vary] index=%li\n", varyPtr->index);
+        printNode(varyPtr->zeroNodePtr);
+        printNode(varyPtr->oneNodePtr);
+    }
+    puts("[up]");
+}
+
+
+static void
+printAdtree (adtree_t* adtreePtr)
+{
+    printNode(adtreePtr->rootNodePtr);
+}
+
+
+static void
+printQuery (vector_t* queryVectorPtr)
+{
+    printf("[");
+    long q;
+    //long numQuery = vector_getSize(queryVectorPtr);
+    list_iter_t it;
+    list_iter_reset(&it, queryVectorPtr);
+    for (q = 0; list_iter_hasNext(&it, queryVectorPtr)/*q < numQuery*/; q++) {
+        query_t* queryPtr = (query_t*)list_iter_next(&it, queryVectorPtr);//vector_at(queryVectorPtr, q);
+        printf("%li:%li ", queryPtr->index, queryPtr->value);
+    }
+    printf("]");
+}
+
+
+static long
+countData (data_t* dataPtr, vector_t* queryVectorPtr)
+{
+    long count = 0;
+    long numQuery = vector_getSize(queryVectorPtr);
+
+    long r;
+    long numRecord = dataPtr->numRecord;
+    for (r = 0; r < numRecord; r++) {
+        char* record = data_getRecord(dataPtr, r);
+        bool_t isMatch = TRUE;
+        long q;
+        list_iter_t it;
+        list_iter_reset(&it, queryVectorPtr);
+        for (q = 0; list_iter_hasNext(&it, queryVectorPtr)/*q < numQuery*/; q++) {
+            query_t* queryPtr = (query_t*)list_iter_next(&it, queryVectorPtr);//vector_at(queryVectorPtr, q);
+            long queryValue = queryPtr->value;
+            if ((queryValue != QUERY_VALUE_WILDCARD) &&
+                ((char)queryValue) != record[queryPtr->index])
+            {
+                isMatch = FALSE;
+                break;
+            }
+        }
+        if (isMatch) {
+            count++;
+        }
+    }
+
+    return count;
+}
+
+
+static void
+testCount (adtree_t* adtreePtr,
+           data_t* dataPtr,
+           vector_t* queryVectorPtr,
+           long index,
+           long numVar)
+{
+    if (index >= numVar) {
+        return;
+    }
+
+    long count1 = adtree_getCount(adtreePtr, queryVectorPtr);
+    long count2 = countData(dataPtr, queryVectorPtr);
+    if (global_doPrint) {
+        printQuery(queryVectorPtr);
+        printf(" count1=%li count2=%li\n", count1, count2);
+        fflush(stdout);
+    }
+    assert(count1 == count2);
+
+    query_t query;
+
+    long i;
+    for (i = 1; i < numVar; i++) {
+        query.index = index + i;
+        bool_t status = vector_pushBack(queryVectorPtr, (void*)&query);
+        assert(status);
+
+        query.value = 0;
+        testCount(adtreePtr, dataPtr, queryVectorPtr, query.index, numVar);
+
+        query.value = 1;
+        testCount(adtreePtr, dataPtr, queryVectorPtr, query.index, numVar);
+
+        vector_popBack(queryVectorPtr);
+    }
+}
+
+
+static void
+testCounts (adtree_t* adtreePtr, data_t* dataPtr)
+{
+    long numVar = dataPtr->numVar;
+    vector_t* queryVectorPtr = vector_alloc(numVar);
+    long v;
+    for (v = -1; v < numVar; v++) {
+        testCount(adtreePtr, dataPtr, queryVectorPtr, v, dataPtr->numVar);
+    }
+    vector_free(queryVectorPtr);
+}
+
+
+static void
+test (long numVar, long numRecord)
+{
+    random_t* randomPtr = random_alloc();
+    data_t* dataPtr = data_alloc(numVar, numRecord, randomPtr);
+    assert(dataPtr);
+    data_generate(dataPtr, 0, 10, 10);
+    if (global_doPrint) {
+        printData(dataPtr);
+    }
+
+    data_t* copyDataPtr = data_alloc(numVar, numRecord, randomPtr);
+    assert(copyDataPtr);
+    data_copy(copyDataPtr, dataPtr);
+
+    adtree_t* adtreePtr = adtree_alloc();
+    assert(adtreePtr);
+
+    TIMER_T start;
+    TIMER_READ(start);
+
+    adtree_make(adtreePtr, copyDataPtr);
+
+    TIMER_T stop;
+    TIMER_READ(stop);
+
+    printf("%lf\n", TIMER_DIFF_SECONDS(start, stop));
+
+    if (global_doPrint) {
+        printAdtree(adtreePtr);
+    }
+
+    testCounts(adtreePtr, dataPtr);
+
+    adtree_free(adtreePtr);
+    random_free(randomPtr);
+    data_free(dataPtr);
+}
+
+
+int
+main ()
+{
+    puts("Starting...");
+
+    puts("Test 1:");
+    test(3, 8);
+
+    puts("Test 2:");
+    test(4, 64);
+
+    puts("Test 3:");
+    test(8, 256);
+
+    puts("Test 4:");
+    test(12, 256);
+
+    puts("Test 5:");
+    test(48, 1024);
+
+    puts("All tests passed.");
+
+    return 0;
+}
+
+
+#endif /* TEST_ADTREE */
+
+
+/* =============================================================================
+ *
+ * End of adtree.c
+ *
+ * =============================================================================
+ */
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/adtree.h stamp-g/bayes/adtree.h
--- stamp-0.9.10/bayes/adtree.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/bayes/adtree.h	2017-03-20 15:19:41.000000000 +0000
@@ -86,6 +86,10 @@
 #include "query.h"
 #include "vector.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct adtree_node {
     long index;
     long value;
@@ -140,6 +144,9 @@
 long
 adtree_getCount (adtree_t* adtreePtr, vector_t* queryVectorPtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* ADTREE_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/data.h stamp-g/bayes/data.h
--- stamp-0.9.10/bayes/data.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/bayes/data.h	2017-03-20 15:19:41.000000000 +0000
@@ -77,6 +77,10 @@
 #include "net.h"
 #include "random.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct data {
     long numVar;
     long numRecord;
@@ -151,6 +155,9 @@
 long
 data_findSplit (data_t* dataPtr, long start, long num, long offset);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* DATA_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/learner.c stamp-g/bayes/learner.c
--- stamp-0.9.10/bayes/learner.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/bayes/learner.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1644 +0,0 @@
-/* =============================================================================
- *
- * learn.c
- * -- Learns structure of Bayesian net from data
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * The penalized log-likelihood score (Friedman & Yahkani, 1996) is used to
- * evaluated the "goodness" of a Bayesian net:
- *
- *                             M      n_j
- *                            --- --- ---
- *  -N_params * ln(R) / 2 + R >   >   >   P((a_j = v), X_j) ln P(a_j = v | X_j)
- *                            --- --- ---
- *                            j=1 X_j v=1
- *
- * Where:
- *
- *     N_params     total number of parents across all variables
- *     R            number of records
- *     M            number of variables
- *     X_j          parents of the jth variable
- *     n_j          number of attributes of the jth variable
- *     a_j          attribute
- *
- * The second summation of X_j varies across all possible assignments to the
- * values of the parents X_j.
- *
- * In the code:
- *
- *    "local log likelihood" is  P((a_j = v), X_j) ln P(a_j = v | X_j)
- *    "log likelihood" is everything to the right of the '+', i.e., "R ... X_j)"
- *    "base penalty" is -ln(R) / 2
- *    "penalty" is N_params * -ln(R) / 2
- *    "score" is the entire expression
- *
- * For more notes, refer to:
- *
- * A. Moore and M.-S. Lee. Cached sufficient statistics for efficient machine
- * learning with large datasets. Journal of Artificial Intelligence Research 8
- * (1998), pp 67-91.
- *
- * =============================================================================
- *
- * The search strategy uses a combination of local and global structure search.
- * Similar to the technique described in:
- *
- * D. M. Chickering, D. Heckerman, and C. Meek.  A Bayesian approach to learning
- * Bayesian networks with local structure. In Proceedings of Thirteenth
- * Conference on Uncertainty in Artificial Intelligence (1997), pp. 80-89.
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <math.h>
-#include <stdlib.h>
-#include "adtree.h"
-#include "data.h"
-#include "learner.h"
-#include "list.h"
-#include "net.h"
-#include "operation.h"
-#include "query.h"
-#include "random.h"
-#include "thread.h"
-#include "timer.h"
-#include "utility.h"
-#include "vector.h"
-
-struct learner_task {
-    operation_t op;
-    long fromId;
-    long toId;
-    float score;
-};
-
-typedef struct findBestTaskArg {
-    long toId;
-    learner_t* learnerPtr;
-    query_t* queries;
-    vector_t* queryVectorPtr;
-    vector_t* parentQueryVectorPtr;
-    long numTotalParent;
-    float basePenalty;
-    float baseLogLikelihood;
-    bitmap_t* bitmapPtr;
-    queue_t* workQueuePtr;
-    vector_t* aQueryVectorPtr;
-    vector_t* bQueryVectorPtr;
-} findBestTaskArg_t;
-
-#ifdef TEST_LEARNER
-long global_maxNumEdgeLearned = -1L;
-long global_insertPenalty = 1;
-float global_operationQualityFactor = 1.0F;
-#else
-extern long global_insertPenalty;
-extern long global_maxNumEdgeLearned;
-extern float global_operationQualityFactor;
-#endif
-
-/* =============================================================================
- * DECLARATION OF TM_CALLABLE FUNCTIONS
- * =============================================================================
- */
-
-TM_CALLABLE
-static learner_task_t
-TMfindBestReverseTask (TM_ARGDECL  findBestTaskArg_t* argPtr);
-
-TM_CALLABLE
-static learner_task_t
-TMfindBestInsertTask (TM_ARGDECL  findBestTaskArg_t* argPtr);
-
-TM_CALLABLE
-static learner_task_t
-TMfindBestRemoveTask (TM_ARGDECL  findBestTaskArg_t* argPtr);
-
-/* =============================================================================
- * compareTask
- * -- Want greatest score first
- * -- For list
- * =============================================================================
- */
-static long
-compareTask (const void* aPtr, const void* bPtr)
-{
-    learner_task_t* aTaskPtr = (learner_task_t*)aPtr;
-    learner_task_t* bTaskPtr = (learner_task_t*)bPtr;
-    float aScore = aTaskPtr->score;
-    float bScore = bTaskPtr->score;
-
-    if (aScore < bScore) {
-        return 1;
-    } else if (aScore > bScore) {
-        return -1;
-    } else {
-        return (aTaskPtr->toId - bTaskPtr->toId);
-    }
-}
-
-
-/* =============================================================================
- * compareQuery
- * -- Want smallest ID first
- * -- For vector_sort
- * =============================================================================
- */
-static int
-compareQuery (const void* aPtr, const void* bPtr)
-{
-    query_t* aQueryPtr = (query_t*)(*(void**)aPtr);
-    query_t* bQueryPtr = (query_t*)(*(void**)bPtr);
-
-    return (aQueryPtr->index - bQueryPtr->index);
-}
-
-
-/* =============================================================================
- * learner_alloc
- * =============================================================================
- */
-learner_t*
-learner_alloc (data_t* dataPtr, adtree_t* adtreePtr, long numThread)
-{
-    learner_t* learnerPtr;
-
-    learnerPtr = (learner_t*)malloc(sizeof(learner_t));
-    if (learnerPtr) {
-        learnerPtr->adtreePtr = adtreePtr;
-        learnerPtr->netPtr = net_alloc(dataPtr->numVar);
-        assert(learnerPtr->netPtr);
-        learnerPtr->localBaseLogLikelihoods =
-            (LocalBaseLogLikelihood*)malloc(dataPtr->numVar * sizeof(*learnerPtr->localBaseLogLikelihoods));
-        assert(learnerPtr->localBaseLogLikelihoods);
-        XTM_LOCKABLE_VALUE(learnerPtr->baseLogLikelihood) = 0.0F;
-        XTM_LOCKABLE_INIT(learnerPtr->baseLogLikelihood);
-        learnerPtr->tasks =
-            (learner_task_t*)malloc(dataPtr->numVar * sizeof(learner_task_t));
-        assert(learnerPtr->tasks);
-        learnerPtr->taskListPtr = list_alloc(&compareTask);
-        assert(learnerPtr->taskListPtr);
-        XTM_LOCKABLE_VALUE(learnerPtr->numTotalParent) = 0;
-        XTM_LOCKABLE_INIT(learnerPtr->numTotalParent);
-    }
-
-    return learnerPtr;
-}
-
-
-/* =============================================================================
- * learner_free
- * =============================================================================
- */
-void
-learner_free (learner_t* learnerPtr)
-{
-    list_free(learnerPtr->taskListPtr);
-    free(learnerPtr->tasks);
-    free(learnerPtr->localBaseLogLikelihoods);
-    net_free(learnerPtr->netPtr);
-    free(learnerPtr);
-}
-
-
-/* =============================================================================
- * computeSpecificLocalLogLikelihood
- * -- Query vectors should not contain wildcards
- * =============================================================================
- */
-static float
-computeSpecificLocalLogLikelihood (adtree_t* adtreePtr,
-                                   vector_t* queryVectorPtr,
-                                   vector_t* parentQueryVectorPtr)
-{
-    long count = adtree_getCount(adtreePtr, queryVectorPtr);
-    if (count == 0) {
-        return 0.0;
-    }
-
-    double probability = (double)count / (double)adtreePtr->numRecord;
-    long parentCount = adtree_getCount(adtreePtr, parentQueryVectorPtr);
-
-    assert(parentCount >= count);
-    assert(parentCount > 0);
-
-    return (float)(probability * (double)log((double)count/ (double)parentCount));
-}
-
-
-/* =============================================================================
- * createPartition
- * =============================================================================
- */
-static void
-createPartition (long min, long max, long id, long n,
-                 long* startPtr, long* stopPtr)
-{
-    long range = max - min;
-    long chunk = MAX(1, ((range + n/2) / n)); /* rounded */
-    long start = min + chunk * id;
-    long stop;
-    if (id == (n-1)) {
-        stop = max;
-    } else {
-        stop = MIN(max, (start + chunk));
-    }
-
-    *startPtr = start;
-    *stopPtr = stop;
-}
-
-
-/* =============================================================================
- * createTaskList
- * -- baseLogLikelihoods and taskListPtr are updated
- * =============================================================================
- */
-static void
-createTaskList (void* argPtr)
-{
-    TM_THREAD_ENTER();
-
-    long myId = thread_getId();
-    long numThread = thread_getNumThread();
-
-    learner_t* learnerPtr = (learner_t*)argPtr;
-    list_t* taskListPtr = learnerPtr->taskListPtr;
-
-    bool_t status;
-
-    adtree_t* adtreePtr = learnerPtr->adtreePtr;
-    LocalBaseLogLikelihood* localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
-    learner_task_t* tasks = learnerPtr->tasks;
-
-    query_t queries[2];
-    vector_t* queryVectorPtr = PVECTOR_ALLOC(2);
-    assert(queryVectorPtr);
-    status = vector_pushBack(queryVectorPtr, (void*)&queries[0]);
-    assert(status);
-
-    query_t parentQuery;
-    vector_t* parentQueryVectorPtr = PVECTOR_ALLOC(1);
-    assert(parentQueryVectorPtr);
-
-    long numVar = adtreePtr->numVar;
-    long numRecord = adtreePtr->numRecord;
-    float baseLogLikelihood = 0.0;
-    float penalty = (float)(-0.5 * log((double)numRecord)); /* only add 1 edge */
-
-    long v;
-
-    long v_start;
-    long v_stop;
-    createPartition(0, numVar, myId, numThread, &v_start, &v_stop);
-
-    /*
-     * Compute base log likelihood for each variable and total base loglikelihood
-     */
-
-    for (v = v_start; v < v_stop; v++) {
-
-        float localBaseLogLikelihood = 0.0;
-        queries[0].index = v;
-
-        queries[0].value = 0;
-        localBaseLogLikelihood +=
-            computeSpecificLocalLogLikelihood(adtreePtr,
-                                              queryVectorPtr,
-                                              parentQueryVectorPtr);
-
-        queries[0].value = 1;
-        localBaseLogLikelihood +=
-            computeSpecificLocalLogLikelihood(adtreePtr,
-                                              queryVectorPtr,
-                                              parentQueryVectorPtr);
-
-        XTM_LOCKABLE_VALUE(localBaseLogLikelihoods[v].value) = localBaseLogLikelihood;
-        XTM_LOCKABLE_INIT(localBaseLogLikelihoods[v].value);
-        baseLogLikelihood += localBaseLogLikelihood;
-
-    } /* foreach variable */
-
-    TM_BEGIN();
-    float globalBaseLogLikelihood =
-        TM_SHARED_READ_F(learnerPtr->baseLogLikelihood);
-    TM_SHARED_WRITE_F(learnerPtr->baseLogLikelihood,
-                      (baseLogLikelihood + globalBaseLogLikelihood));
-    TM_END();
-
-    /*
-     * For each variable, find if the addition of any edge _to_ it is better
-     */
-
-    status = PVECTOR_PUSHBACK(parentQueryVectorPtr, (void*)&parentQuery);
-    assert(status);
-
-    for (v = v_start; v < v_stop; v++) {
-
-        /*
-         * Compute base log likelihood for this variable
-         */
-
-        queries[0].index = v;
-        long bestLocalIndex = v;
-        float bestLocalLogLikelihood = XTM_LOCKABLE_VALUE(localBaseLogLikelihoods[v].value);
-
-        status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[1]);
-        assert(status);
-
-        long vv;
-        for (vv = 0; vv < numVar; vv++) {
-
-            if (vv == v) {
-                continue;
-            }
-            parentQuery.index = vv;
-            if (v < vv) {
-                queries[0].index = v;
-                queries[1].index = vv;
-            } else {
-                queries[0].index = vv;
-                queries[1].index = v;
-            }
-
-            float newLocalLogLikelihood = 0.0;
-
-            queries[0].value = 0;
-            queries[1].value = 0;
-            parentQuery.value = 0;
-            newLocalLogLikelihood +=
-                computeSpecificLocalLogLikelihood(adtreePtr,
-                                                  queryVectorPtr,
-                                                  parentQueryVectorPtr);
-
-            queries[0].value = 0;
-            queries[1].value = 1;
-            parentQuery.value = ((vv < v) ? 0 : 1);
-            newLocalLogLikelihood +=
-                computeSpecificLocalLogLikelihood(adtreePtr,
-                                                  queryVectorPtr,
-                                                  parentQueryVectorPtr);
-
-            queries[0].value = 1;
-            queries[1].value = 0;
-            parentQuery.value = ((vv < v) ? 1 : 0);
-            newLocalLogLikelihood +=
-                computeSpecificLocalLogLikelihood(adtreePtr,
-                                                  queryVectorPtr,
-                                                  parentQueryVectorPtr);
-
-            queries[0].value = 1;
-            queries[1].value = 1;
-            parentQuery.value = 1;
-            newLocalLogLikelihood +=
-                computeSpecificLocalLogLikelihood(adtreePtr,
-                                                  queryVectorPtr,
-                                                  parentQueryVectorPtr);
-
-            if (newLocalLogLikelihood > bestLocalLogLikelihood) {
-                bestLocalIndex = vv;
-                bestLocalLogLikelihood = newLocalLogLikelihood;
-            }
-
-        } /* foreach other variable */
-
-        PVECTOR_POPBACK(queryVectorPtr);
-
-        if (bestLocalIndex != v) {
-            float logLikelihood = numRecord * (baseLogLikelihood +
-                                                + bestLocalLogLikelihood
-                                                - XTM_LOCKABLE_VALUE(localBaseLogLikelihoods[v].value));
-            float score = penalty + logLikelihood;
-            learner_task_t* taskPtr = &tasks[v];
-            taskPtr->op = OPERATION_INSERT;
-            taskPtr->fromId = bestLocalIndex;
-            taskPtr->toId = v;
-            taskPtr->score = score;
-            TM_BEGIN();
-            status = TMLIST_INSERT(taskListPtr, (void*)taskPtr);
-            TM_END();
-            assert(status);
-        }
-
-    } /* for each variable */
-
-    PVECTOR_FREE(queryVectorPtr);
-    PVECTOR_FREE(parentQueryVectorPtr);
-
-#ifdef TEST_LEARNER
-    list_iter_t it;
-    list_iter_reset(&it, taskListPtr);
-    while (list_iter_hasNext(&it, taskListPtr)) {
-        learner_task_t* taskPtr = (learner_task_t*)list_iter_next(&it, taskListPtr);
-        printf("[task] op=%i from=%li to=%li score=%lf\n",
-               taskPtr->op, taskPtr->fromId, taskPtr->toId, taskPtr->score);
-    }
-#endif /* TEST_LEARNER */
-
-    TM_THREAD_EXIT();
-}
-
-
-/* =============================================================================
- * TMpopTask
- * -- Returns NULL is list is empty
- * =============================================================================
- */
-learner_task_t*
-TMpopTask (TM_ARGDECL  list_t* taskListPtr)
-{
-    learner_task_t* taskPtr = NULL;
-
-    list_iter_t it;
-    TMLIST_ITER_RESET(&it, taskListPtr);
-    if (TMLIST_ITER_HASNEXT(&it, taskListPtr)) {
-        taskPtr = (learner_task_t*)TMLIST_ITER_NEXT(&it, taskListPtr);
-        bool_t status = TMLIST_REMOVE(taskListPtr, (void*)taskPtr);
-        assert(status);
-    }
-
-    return taskPtr;
-}
-
-
-/* =============================================================================
- * populateParentQuery
- * -- Modifies contents of parentQueryVectorPtr
- * =============================================================================
- */
-static void
-populateParentQueryVector (net_t* netPtr,
-                           long id,
-                           query_t* queries,
-                           vector_t* parentQueryVectorPtr)
-{
-    vector_clear(parentQueryVectorPtr);
-
-    list_t* parentIdListPtr = net_getParentIdListPtr(netPtr, id);
-    list_iter_t it;
-    list_iter_reset(&it, parentIdListPtr);
-    while (list_iter_hasNext(&it, parentIdListPtr)) {
-        long parentId = (long)list_iter_next(&it, parentIdListPtr);
-        bool_t status = vector_pushBack(parentQueryVectorPtr,
-                                        (void*)&queries[parentId]);
-        assert(status);
-    }
-}
-
-
-/* =============================================================================
- * TMpopulateParentQuery
- * -- Modifies contents of parentQueryVectorPtr
- * =============================================================================
- */
-static void
-TMpopulateParentQueryVector (TM_ARGDECL
-                             net_t* netPtr,
-                             long id,
-                             query_t* queries,
-                             vector_t* parentQueryVectorPtr)
-{
-    vector_clear(parentQueryVectorPtr);
-
-    list_t* parentIdListPtr = net_getParentIdListPtr(netPtr, id);
-    list_iter_t it;
-    TMLIST_ITER_RESET(&it, parentIdListPtr);
-    while (TMLIST_ITER_HASNEXT(&it, parentIdListPtr)) {
-        long parentId = (long)TMLIST_ITER_NEXT(&it, parentIdListPtr);
-        bool_t status = PVECTOR_PUSHBACK(parentQueryVectorPtr,
-                                         (void*)&queries[parentId]);
-        assert(status);
-    }
-}
-
-
-/* =============================================================================
- * populateQueryVectors
- * -- Modifies contents of queryVectorPtr and parentQueryVectorPtr
- * =============================================================================
- */
-static void
-populateQueryVectors (net_t* netPtr,
-                      long id,
-                      query_t* queries,
-                      vector_t* queryVectorPtr,
-                      vector_t* parentQueryVectorPtr)
-{
-    populateParentQueryVector(netPtr, id, queries, parentQueryVectorPtr);
-
-    bool_t status;
-    status = vector_copy(queryVectorPtr, parentQueryVectorPtr);
-    assert(status);
-    status = vector_pushBack(queryVectorPtr, (void*)&queries[id]);
-    assert(status);
-    vector_sort(queryVectorPtr, &compareQuery);
-}
-
-
-/* =============================================================================
- * TMpopulateQueryVectors
- * -- Modifies contents of queryVectorPtr and parentQueryVectorPtr
- * =============================================================================
- */
-static void
-TMpopulateQueryVectors (TM_ARGDECL
-                        net_t* netPtr,
-                        long id,
-                        query_t* queries,
-                        vector_t* queryVectorPtr,
-                        vector_t* parentQueryVectorPtr)
-{
-    TMpopulateParentQueryVector(TM_ARG  netPtr, id, queries, parentQueryVectorPtr);
-
-    bool_t status;
-    status = PVECTOR_COPY(queryVectorPtr, parentQueryVectorPtr);
-    assert(status);
-    status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[id]);
-    assert(status);
-    PVECTOR_SORT(queryVectorPtr, &compareQuery);
-}
-
-
-/* =============================================================================
- * computeLocalLogLikelihoodHelper
- * -- Recursive helper routine
- * =============================================================================
- */
-static float
-computeLocalLogLikelihoodHelper (long i,
-                                 long numParent,
-                                 adtree_t* adtreePtr,
-                                 query_t* queries,
-                                 vector_t* queryVectorPtr,
-                                 vector_t* parentQueryVectorPtr)
-{
-    if (i >= numParent) {
-        return computeSpecificLocalLogLikelihood(adtreePtr,
-                                                 queryVectorPtr,
-                                                 parentQueryVectorPtr);
-    }
-
-    float localLogLikelihood = 0.0;
-
-    query_t* parentQueryPtr = vector_at(parentQueryVectorPtr, i);
-    long parentIndex = parentQueryPtr->index;
-
-    queries[parentIndex].value = 0;
-    localLogLikelihood += computeLocalLogLikelihoodHelper((i + 1),
-                                                          numParent,
-                                                          adtreePtr,
-                                                          queries,
-                                                          queryVectorPtr,
-                                                          parentQueryVectorPtr);
-
-    queries[parentIndex].value = 1;
-    localLogLikelihood += computeLocalLogLikelihoodHelper((i + 1),
-                                                          numParent,
-                                                          adtreePtr,
-                                                          queries,
-                                                          queryVectorPtr,
-                                                          parentQueryVectorPtr);
-
-    queries[parentIndex].value = QUERY_VALUE_WILDCARD;
-
-    return localLogLikelihood;
-}
-
-
-/* =============================================================================
- * computeLocalLogLikelihood
- * -- Populate the query vectors before passing as args
- * =============================================================================
- */
-static float
-computeLocalLogLikelihood (long id,
-                           adtree_t* adtreePtr,
-                           net_t* netPtr,
-                           query_t* queries,
-                           vector_t* queryVectorPtr,
-                           vector_t* parentQueryVectorPtr)
-{
-    long numParent = vector_getSize(parentQueryVectorPtr);
-    float localLogLikelihood = 0.0;
-
-    queries[id].value = 0;
-    localLogLikelihood += computeLocalLogLikelihoodHelper(0,
-                                                          numParent,
-                                                          adtreePtr,
-                                                          queries,
-                                                          queryVectorPtr,
-                                                          parentQueryVectorPtr);
-
-    queries[id].value = 1;
-    localLogLikelihood += computeLocalLogLikelihoodHelper(0,
-                                                          numParent,
-                                                          adtreePtr,
-                                                          queries,
-                                                          queryVectorPtr,
-                                                          parentQueryVectorPtr);
-
-    queries[id].value = QUERY_VALUE_WILDCARD;
-
-    return localLogLikelihood;
-}
-
-
-/* =============================================================================
- * TMfindBestInsertTask
- * =============================================================================
- */
-static learner_task_t
-TMfindBestInsertTask (TM_ARGDECL  findBestTaskArg_t* argPtr)
-{
-    long       toId                     = argPtr->toId;
-    learner_t* learnerPtr               = argPtr->learnerPtr;
-    query_t*   queries                  = argPtr->queries;
-    vector_t*  queryVectorPtr           = argPtr->queryVectorPtr;
-    vector_t*  parentQueryVectorPtr     = argPtr->parentQueryVectorPtr;
-    long       numTotalParent           = argPtr->numTotalParent;
-    float      basePenalty              = argPtr->basePenalty;
-    float      baseLogLikelihood        = argPtr->baseLogLikelihood;
-    bitmap_t*  invalidBitmapPtr         = argPtr->bitmapPtr;
-    queue_t*   workQueuePtr             = argPtr->workQueuePtr;
-    vector_t*  baseParentQueryVectorPtr = argPtr->aQueryVectorPtr;
-    vector_t*  baseQueryVectorPtr       = argPtr->bQueryVectorPtr;
-
-    bool_t status;
-    adtree_t* adtreePtr               = learnerPtr->adtreePtr;
-    net_t*    netPtr                  = learnerPtr->netPtr;
-    LocalBaseLogLikelihood*    localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
-
-    TMpopulateParentQueryVector(TM_ARG  netPtr, toId, queries, parentQueryVectorPtr);
-
-    /*
-     * Create base query and parentQuery
-     */
-
-    status = PVECTOR_COPY(baseParentQueryVectorPtr, parentQueryVectorPtr);
-    assert(status);
-
-    status = PVECTOR_COPY(baseQueryVectorPtr, baseParentQueryVectorPtr);
-    assert(status);
-    status = PVECTOR_PUSHBACK(baseQueryVectorPtr, (void*)&queries[toId]);
-    assert(status);
-    PVECTOR_SORT(queryVectorPtr, &compareQuery);
-
-    /*
-     * Search all possible valid operations for better local log likelihood
-     */
-
-    float bestFromId = toId; /* flag for not found */
-    float oldLocalLogLikelihood =
-        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId].value);
-    float bestLocalLogLikelihood = oldLocalLogLikelihood;
-
-    status = TMNET_FINDDESCENDANTS(netPtr, toId, invalidBitmapPtr, workQueuePtr);
-    assert(status);
-    long fromId = -1;
-
-    list_t* parentIdListPtr = net_getParentIdListPtr(netPtr, toId);
-
-    long maxNumEdgeLearned = global_maxNumEdgeLearned;
-
-    if ((maxNumEdgeLearned < 0) ||
-        (TMLIST_GETSIZE(parentIdListPtr) <= maxNumEdgeLearned))
-    {
-
-        list_iter_t it;
-        TMLIST_ITER_RESET(&it, parentIdListPtr);
-        while (TMLIST_ITER_HASNEXT(&it, parentIdListPtr)) {
-            long parentId = (long)TMLIST_ITER_NEXT(&it, parentIdListPtr);
-            bitmap_set(invalidBitmapPtr, parentId); /* invalid since already have edge */
-        }
-
-        while ((fromId = bitmap_findClear(invalidBitmapPtr, (fromId + 1))) >= 0) {
-
-            if (fromId == toId) {
-                continue;
-            }
-
-            status = PVECTOR_COPY(queryVectorPtr, baseQueryVectorPtr);
-            assert(status);
-            status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[fromId]);
-            assert(status);
-            PVECTOR_SORT(queryVectorPtr, &compareQuery);
-
-            status = PVECTOR_COPY(parentQueryVectorPtr, baseParentQueryVectorPtr);
-            assert(status);
-            status = PVECTOR_PUSHBACK(parentQueryVectorPtr, (void*)&queries[fromId]);
-            assert(status);
-            PVECTOR_SORT(parentQueryVectorPtr, &compareQuery);
-
-            float newLocalLogLikelihood =
-                computeLocalLogLikelihood(toId,
-                                          adtreePtr,
-                                          netPtr,
-                                          queries,
-                                          queryVectorPtr,
-                                          parentQueryVectorPtr);
-
-            if (newLocalLogLikelihood > bestLocalLogLikelihood) {
-                bestLocalLogLikelihood = newLocalLogLikelihood;
-                bestFromId = fromId;
-            }
-
-        } /* foreach valid parent */
-
-    } /* if have not exceeded max number of edges to learn */
-
-    /*
-     * Return best task; Note: if none is better, fromId will equal toId
-     */
-
-    learner_task_t bestTask;
-    bestTask.op     = OPERATION_INSERT;
-    bestTask.fromId = bestFromId;
-    bestTask.toId   = toId;
-    bestTask.score  = 0.0;
-
-    if (bestFromId != toId) {
-        long numRecord = adtreePtr->numRecord;
-        long numParent = TMLIST_GETSIZE(parentIdListPtr) + 1;
-        float penalty =
-            (numTotalParent + numParent * global_insertPenalty) * basePenalty;
-        float logLikelihood = numRecord * (baseLogLikelihood +
-                                           + bestLocalLogLikelihood
-                                           - oldLocalLogLikelihood);
-        float bestScore = penalty + logLikelihood;
-        bestTask.score  = bestScore;
-    }
-
-    return bestTask;
-}
-
-
-#ifdef LEARNER_TRY_REMOVE
-/* =============================================================================
- * TMfindBestRemoveTask
- * =============================================================================
- */
-static learner_task_t
-TMfindBestRemoveTask (TM_ARGDECL  findBestTaskArg_t* argPtr)
-{
-    long       toId                     = argPtr->toId;
-    learner_t* learnerPtr               = argPtr->learnerPtr;
-    query_t*   queries                  = argPtr->queries;
-    vector_t*  queryVectorPtr           = argPtr->queryVectorPtr;
-    vector_t*  parentQueryVectorPtr     = argPtr->parentQueryVectorPtr;
-    long       numTotalParent           = argPtr->numTotalParent;
-    float      basePenalty              = argPtr->basePenalty;
-    float      baseLogLikelihood        = argPtr->baseLogLikelihood;
-    vector_t*  origParentQueryVectorPtr = argPtr->aQueryVectorPtr;
-
-    bool_t status;
-    adtree_t* adtreePtr = learnerPtr->adtreePtr;
-    net_t* netPtr = learnerPtr->netPtr;
-    LocalBaseLogLikelihood* localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
-
-    TMpopulateParentQueryVector(TM_ARG
-                                netPtr, toId, queries, origParentQueryVectorPtr);
-    long numParent = PVECTOR_GETSIZE(origParentQueryVectorPtr);
-
-    /*
-     * Search all possible valid operations for better local log likelihood
-     */
-
-    float bestFromId = toId; /* flag for not found */
-    float oldLocalLogLikelihood =
-        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId].value);
-    float bestLocalLogLikelihood = oldLocalLogLikelihood;
-
-    long i;
-    for (i = 0; i < numParent; i++) {
-
-        query_t* queryPtr = (query_t*)PVECTOR_AT(origParentQueryVectorPtr, i);
-        long fromId = queryPtr->index;
-
-        /*
-         * Create parent query (subset of parents since remove an edge)
-         */
-
-        PVECTOR_CLEAR(parentQueryVectorPtr);
-
-        long p;
-        for (p = 0; p < numParent; p++) {
-            if (p != fromId) {
-                query_t* queryPtr = PVECTOR_AT(origParentQueryVectorPtr, p);
-                status = PVECTOR_PUSHBACK(parentQueryVectorPtr,
-                                          (void*)&queries[queryPtr->index]);
-                assert(status);
-            }
-        } /* create new parent query */
-
-        /*
-         * Create query
-         */
-
-        status = PVECTOR_COPY(queryVectorPtr, parentQueryVectorPtr);
-        assert(status);
-        status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[toId]);
-        assert(status);
-        PVECTOR_SORT(queryVectorPtr, &compareQuery);
-
-        /*
-         * See if removing parent is better
-         */
-
-        float newLocalLogLikelihood =
-            computeLocalLogLikelihood(toId,
-                                      adtreePtr,
-                                      netPtr,
-                                      queries,
-                                      queryVectorPtr,
-                                      parentQueryVectorPtr);
-
-        if (newLocalLogLikelihood > bestLocalLogLikelihood) {
-            bestLocalLogLikelihood = newLocalLogLikelihood;
-            bestFromId = fromId;
-        }
-
-    } /* for each parent */
-
-    /*
-     * Return best task; Note: if none is better, fromId will equal toId
-     */
-
-    learner_task_t bestTask;
-    bestTask.op     = OPERATION_REMOVE;
-    bestTask.fromId = bestFromId;
-    bestTask.toId   = toId;
-    bestTask.score  = 0.0;
-
-    if (bestFromId != toId) {
-        long numRecord = adtreePtr->numRecord;
-        float penalty = (numTotalParent - 1) * basePenalty;
-        float logLikelihood = numRecord * (baseLogLikelihood +
-                                            + bestLocalLogLikelihood
-                                            - oldLocalLogLikelihood);
-        float bestScore = penalty + logLikelihood;
-        bestTask.score  = bestScore;
-    }
-
-    return bestTask;
-}
-#endif /* LEARNER_TRY_REMOVE */
-
-
-#ifdef LEARNER_TRY_REVERSE
-/* =============================================================================
- * TMfindBestReverseTask
- * =============================================================================
- */
-static learner_task_t
-TMfindBestReverseTask (TM_ARGDECL  findBestTaskArg_t* argPtr)
-{
-    long       toId                         = argPtr->toId;
-    learner_t* learnerPtr                   = argPtr->learnerPtr;
-    query_t*   queries                      = argPtr->queries;
-    vector_t*  queryVectorPtr               = argPtr->queryVectorPtr;
-    vector_t*  parentQueryVectorPtr         = argPtr->parentQueryVectorPtr;
-    long       numTotalParent               = argPtr->numTotalParent;
-    float      basePenalty                  = argPtr->basePenalty;
-    float      baseLogLikelihood            = argPtr->baseLogLikelihood;
-    bitmap_t*  visitedBitmapPtr             = argPtr->bitmapPtr;
-    queue_t*   workQueuePtr                 = argPtr->workQueuePtr;
-    vector_t*  toOrigParentQueryVectorPtr   = argPtr->aQueryVectorPtr;
-    vector_t*  fromOrigParentQueryVectorPtr = argPtr->bQueryVectorPtr;
-
-    bool_t status;
-    adtree_t* adtreePtr = learnerPtr->adtreePtr;
-    net_t* netPtr = learnerPtr->netPtr;
-    LocalBaseLogLikelihood* localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
-
-    TMpopulateParentQueryVector(TM_ARG
-                                netPtr, toId, queries, toOrigParentQueryVectorPtr);
-    long numParent = PVECTOR_GETSIZE(toOrigParentQueryVectorPtr);
-
-    /*
-     * Search all possible valid operations for better local log likelihood
-     */
-
-    long bestFromId = toId; /* flag for not found */
-    float oldLocalLogLikelihood =
-        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId].value);
-    float bestLocalLogLikelihood = oldLocalLogLikelihood;
-    long fromId = 0;
-
-    long i;
-    for (i = 0; i < numParent; i++) {
-
-        query_t* queryPtr = (query_t*)PVECTOR_AT(toOrigParentQueryVectorPtr, i);
-        fromId = queryPtr->index;
-
-        bestLocalLogLikelihood =
-            oldLocalLogLikelihood +
-            (float)TM_SHARED_READ_F(localBaseLogLikelihoods[fromId].value);
-
-        TMpopulateParentQueryVector(TM_ARG
-                                    netPtr,
-                                    fromId,
-                                    queries,
-                                    fromOrigParentQueryVectorPtr);
-
-        /*
-         * Create parent query (subset of parents since remove an edge)
-         */
-
-        PVECTOR_CLEAR(parentQueryVectorPtr);
-
-        long p;
-        for (p = 0; p < numParent; p++) {
-            if (p != fromId) {
-                query_t* queryPtr = PVECTOR_AT(toOrigParentQueryVectorPtr, p);
-                status = PVECTOR_PUSHBACK(parentQueryVectorPtr,
-                                          (void*)&queries[queryPtr->index]);
-                assert(status);
-            }
-        } /* create new parent query */
-
-        /*
-         * Create query
-         */
-
-        status = PVECTOR_COPY(queryVectorPtr, parentQueryVectorPtr);
-        assert(status);
-        status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[toId]);
-        assert(status);
-        PVECTOR_SORT(queryVectorPtr, &compareQuery);
-
-        /*
-         * Get log likelihood for removing parent from toId
-         */
-
-        float newLocalLogLikelihood =
-            computeLocalLogLikelihood(toId,
-                                      adtreePtr,
-                                      netPtr,
-                                      queries,
-                                      queryVectorPtr,
-                                      parentQueryVectorPtr);
-
-        /*
-         * Get log likelihood for adding parent to fromId
-         */
-
-        status = PVECTOR_COPY(parentQueryVectorPtr, fromOrigParentQueryVectorPtr);
-        assert(status);
-        status = PVECTOR_PUSHBACK(parentQueryVectorPtr, (void*)&queries[toId]);
-        assert(status);
-        PVECTOR_SORT(parentQueryVectorPtr, &compareQuery);
-
-        status = PVECTOR_COPY(queryVectorPtr, parentQueryVectorPtr);
-        assert(status);
-        status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[fromId]);
-        assert(status);
-        PVECTOR_SORT(queryVectorPtr, &compareQuery);
-
-        newLocalLogLikelihood +=
-            computeLocalLogLikelihood(fromId,
-                                      adtreePtr,
-                                      netPtr,
-                                      queries,
-                                      queryVectorPtr,
-                                      parentQueryVectorPtr);
-
-        /*
-         * Record best
-         */
-
-        if (newLocalLogLikelihood > bestLocalLogLikelihood) {
-            bestLocalLogLikelihood = newLocalLogLikelihood;
-            bestFromId = fromId;
-        }
-
-    } /* for each parent */
-
-    /*
-     * Check validity of best
-     */
-
-    if (bestFromId != toId) {
-        bool_t isTaskValid = TRUE;
-        TMNET_APPLYOPERATION(netPtr, OPERATION_REMOVE, bestFromId, toId);
-        if (TMNET_ISPATH(netPtr,
-                         bestFromId,
-                         toId,
-                         visitedBitmapPtr,
-                         workQueuePtr))
-        {
-            isTaskValid = FALSE;
-        }
-        TMNET_APPLYOPERATION(netPtr, OPERATION_INSERT, bestFromId, toId);
-        if (!isTaskValid) {
-            bestFromId = toId;
-        }
-    }
-
-    /*
-     * Return best task; Note: if none is better, fromId will equal toId
-     */
-
-    learner_task_t bestTask;
-    bestTask.op     = OPERATION_REVERSE;
-    bestTask.fromId = bestFromId;
-    bestTask.toId   = toId;
-    bestTask.score  = 0.0;
-
-    if (bestFromId != toId) {
-        float fromLocalLogLikelihood =
-            (float)TM_SHARED_READ_F(localBaseLogLikelihoods[bestFromId].value);
-        long numRecord = adtreePtr->numRecord;
-        float penalty = numTotalParent * basePenalty;
-        float logLikelihood = numRecord * (baseLogLikelihood +
-                                            + bestLocalLogLikelihood
-                                            - oldLocalLogLikelihood
-                                            - fromLocalLogLikelihood);
-        float bestScore = penalty + logLikelihood;
-        bestTask.score  = bestScore;
-    }
-
-    return bestTask;
-}
-#endif /* LEARNER_TRY_REVERSE */
-
-
-/* =============================================================================
- * learnStructure
- *
- * Note it is okay if the score is not exact, as we are relaxing the greedy
- * search. This means we do not need to communicate baseLogLikelihood across
- * threads.
- * =============================================================================
- */
-static void
-learnStructure (void* argPtr)
-{
-    TM_THREAD_ENTER();
-
-    learner_t* learnerPtr = (learner_t*)argPtr;
-    net_t* netPtr = learnerPtr->netPtr;
-    adtree_t* adtreePtr = learnerPtr->adtreePtr;
-    long numRecord = adtreePtr->numRecord;
-    LocalBaseLogLikelihood* localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
-    list_t* taskListPtr = learnerPtr->taskListPtr;
-
-    float operationQualityFactor = global_operationQualityFactor;
-
-    bitmap_t* visitedBitmapPtr = PBITMAP_ALLOC(learnerPtr->adtreePtr->numVar);
-    assert(visitedBitmapPtr);
-    queue_t* workQueuePtr = PQUEUE_ALLOC(-1);
-    assert(workQueuePtr);
-
-    long numVar = adtreePtr->numVar;
-    query_t* queries = (query_t*)P_MALLOC(numVar * sizeof(query_t));
-    assert(queries);
-    long v;
-    for (v = 0; v < numVar; v++) {
-        queries[v].index = v;
-        queries[v].value = QUERY_VALUE_WILDCARD;
-    }
-
-    float basePenalty = (float)(-0.5 * log((double)numRecord));
-
-    vector_t* queryVectorPtr = PVECTOR_ALLOC(1);
-    assert(queryVectorPtr);
-    vector_t* parentQueryVectorPtr = PVECTOR_ALLOC(1);
-    assert(parentQueryVectorPtr);
-    vector_t* aQueryVectorPtr = PVECTOR_ALLOC(1);
-    assert(aQueryVectorPtr);
-    vector_t* bQueryVectorPtr = PVECTOR_ALLOC(1);
-    assert(bQueryVectorPtr);
-
-    findBestTaskArg_t arg;
-    arg.learnerPtr           = learnerPtr;
-    arg.queries              = queries;
-    arg.queryVectorPtr       = queryVectorPtr;
-    arg.parentQueryVectorPtr = parentQueryVectorPtr;
-    arg.bitmapPtr            = visitedBitmapPtr;
-    arg.workQueuePtr         = workQueuePtr;
-    arg.aQueryVectorPtr      = aQueryVectorPtr;
-    arg.bQueryVectorPtr      = bQueryVectorPtr;
-
-    while (1) {
-
-        learner_task_t* taskPtr;
-        TM_BEGIN();
-        taskPtr = TMpopTask(TM_ARG  taskListPtr);
-        TM_END();
-        if (taskPtr == NULL) {
-            break;
-        }
-
-        operation_t op = taskPtr->op;
-        long fromId = taskPtr->fromId;
-        long toId = taskPtr->toId;
-
-        bool_t isTaskValid;
-
-        TM_BEGIN();
-
-        /*
-         * Check if task is still valid
-         */
-        isTaskValid = TRUE;
-        switch (op) {
-            case OPERATION_INSERT: {
-                if (TMNET_HASEDGE(netPtr, fromId, toId) ||
-                    TMNET_ISPATH(netPtr,
-                                 toId,
-                                 fromId,
-                                 visitedBitmapPtr,
-                                 workQueuePtr))
-                {
-                    isTaskValid = FALSE;
-                }
-                break;
-            }
-            case OPERATION_REMOVE: {
-                /* Can never create cycle, so always valid */
-                break;
-            }
-            case OPERATION_REVERSE: {
-                /* Temporarily remove edge for check */
-                TMNET_APPLYOPERATION(netPtr, OPERATION_REMOVE, fromId, toId);
-                if (TMNET_ISPATH(netPtr,
-                                 fromId,
-                                 toId,
-                                 visitedBitmapPtr,
-                                 workQueuePtr))
-                {
-                    isTaskValid = FALSE;
-                }
-                TMNET_APPLYOPERATION(netPtr, OPERATION_INSERT, fromId, toId);
-                break;
-            }
-            default:
-                assert(0);
-        }
-
-#ifdef TEST_LEARNER
-        printf("[task] op=%i from=%li to=%li score=%lf valid=%s\n",
-               taskPtr->op, taskPtr->fromId, taskPtr->toId, taskPtr->score,
-               (isTaskValid ? "yes" : "no"));
-        fflush(stdout);
-#endif
-
-        /*
-         * Perform task: update graph and probabilities
-         */
-
-        if (isTaskValid) {
-            TMNET_APPLYOPERATION(netPtr, op, fromId, toId);
-        }
-
-        TM_END();
-
-        float deltaLogLikelihood = 0.0;
-
-        if (isTaskValid) {
-
-            switch (op) {
-                float newBaseLogLikelihood;
-                case OPERATION_INSERT: {
-                    TM_BEGIN();
-                    TMpopulateQueryVectors(TM_ARG
-                                           netPtr,
-                                           toId,
-                                           queries,
-                                           queryVectorPtr,
-                                           parentQueryVectorPtr);
-                    newBaseLogLikelihood =
-                        computeLocalLogLikelihood(toId,
-                                                  adtreePtr,
-                                                  netPtr,
-                                                  queries,
-                                                  queryVectorPtr,
-                                                  parentQueryVectorPtr);
-                    float toLocalBaseLogLikelihood =
-                        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId].value);
-                    deltaLogLikelihood +=
-                        toLocalBaseLogLikelihood - newBaseLogLikelihood;
-                    TM_SHARED_WRITE_F(localBaseLogLikelihoods[toId].value,
-                                      newBaseLogLikelihood);
-                    TM_END();
-                    TM_BEGIN();
-                    long numTotalParent = (long)TM_SHARED_READ(learnerPtr->numTotalParent);
-                    TM_SHARED_WRITE(learnerPtr->numTotalParent, (numTotalParent + 1));
-                    TM_END();
-                    break;
-                }
-#ifdef LEARNER_TRY_REMOVE
-                case OPERATION_REMOVE: {
-                    TM_BEGIN();
-                    TMpopulateQueryVectors(TM_ARG
-                                           netPtr,
-                                           fromId,
-                                           queries,
-                                           queryVectorPtr,
-                                           parentQueryVectorPtr);
-                    newBaseLogLikelihood =
-                        computeLocalLogLikelihood(fromId,
-                                                  adtreePtr,
-                                                  netPtr,
-                                                  queries,
-                                                  queryVectorPtr,
-                                                  parentQueryVectorPtr);
-                    float fromLocalBaseLogLikelihood =
-                        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[fromId].value);
-                    deltaLogLikelihood +=
-                        fromLocalBaseLogLikelihood - newBaseLogLikelihood;
-                    TM_SHARED_WRITE_F(localBaseLogLikelihoods[fromId].value,
-                                      newBaseLogLikelihood);
-                    TM_END();
-                    TM_BEGIN();
-                    long numTotalParent = (long)TM_SHARED_READ(learnerPtr->numTotalParent);
-                    TM_SHARED_WRITE(learnerPtr->numTotalParent, (numTotalParent - 1));
-                    TM_END();
-                    break;
-                }
-#endif /* LEARNER_TRY_REMOVE */
-#ifdef LEARNER_TRY_REVERSE
-                case OPERATION_REVERSE: {
-                    TM_BEGIN();
-                    TMpopulateQueryVectors(TM_ARG
-                                           netPtr,
-                                           fromId,
-                                           queries,
-                                           queryVectorPtr,
-                                           parentQueryVectorPtr);
-                    newBaseLogLikelihood =
-                        computeLocalLogLikelihood(fromId,
-                                                  adtreePtr,
-                                                  netPtr,
-                                                  queries,
-                                                  queryVectorPtr,
-                                                  parentQueryVectorPtr);
-                    float fromLocalBaseLogLikelihood =
-                        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[fromId].value);
-                    deltaLogLikelihood +=
-                        fromLocalBaseLogLikelihood - newBaseLogLikelihood;
-                    TM_SHARED_WRITE_F(localBaseLogLikelihoods[fromId].value,
-                                      newBaseLogLikelihood);
-                    TM_END();
-
-                    TM_BEGIN();
-                    TMpopulateQueryVectors(TM_ARG
-                                           netPtr,
-                                           toId,
-                                           queries,
-                                           queryVectorPtr,
-                                           parentQueryVectorPtr);
-                    newBaseLogLikelihood =
-                        computeLocalLogLikelihood(toId,
-                                                  adtreePtr,
-                                                  netPtr,
-                                                  queries,
-                                                  queryVectorPtr,
-                                                  parentQueryVectorPtr);
-                    float toLocalBaseLogLikelihood =
-                        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId].value);
-                    deltaLogLikelihood +=
-                        toLocalBaseLogLikelihood - newBaseLogLikelihood;
-                    TM_SHARED_WRITE_F(localBaseLogLikelihoods[toId].value,
-                                      newBaseLogLikelihood);
-                    TM_END();
-                    break;
-                }
-#endif /* LEARNER_TRY_REVERSE */
-                default:
-                    assert(0);
-            } /* switch op */
-
-        } /* if isTaskValid */
-
-        /*
-         * Update/read globals
-         */
-
-        float baseLogLikelihood;
-        long numTotalParent;
-
-        TM_BEGIN();
-        float oldBaseLogLikelihood =
-            (float)TM_SHARED_READ_F(learnerPtr->baseLogLikelihood);
-        float newBaseLogLikelihood = oldBaseLogLikelihood + deltaLogLikelihood;
-        TM_SHARED_WRITE_F(learnerPtr->baseLogLikelihood, newBaseLogLikelihood);
-        baseLogLikelihood = newBaseLogLikelihood;
-        numTotalParent = (long)TM_SHARED_READ(learnerPtr->numTotalParent);
-        TM_END();
-
-        /*
-         * Find next task
-         */
-
-        float baseScore = ((float)numTotalParent * basePenalty)
-                           + (numRecord * baseLogLikelihood);
-
-        learner_task_t bestTask;
-        bestTask.op     = NUM_OPERATION;
-        bestTask.toId   = -1;
-        bestTask.fromId = -1;
-        bestTask.score  = baseScore;
-
-        learner_task_t newTask;
-
-        arg.toId              = toId;
-        arg.numTotalParent    = numTotalParent;
-        arg.basePenalty       = basePenalty;
-        arg.baseLogLikelihood = baseLogLikelihood;
-
-        TM_BEGIN();
-        newTask = TMfindBestInsertTask(TM_ARG  &arg);
-        TM_END();
-
-        if ((newTask.fromId != newTask.toId) &&
-            (newTask.score > (bestTask.score / operationQualityFactor)))
-        {
-            bestTask = newTask;
-        }
-
-#ifdef LEARNER_TRY_REMOVE
-        TM_BEGIN();
-        newTask = TMfindBestRemoveTask(TM_ARG  &arg);
-        TM_END();
-
-        if ((newTask.fromId != newTask.toId) &&
-            (newTask.score > (bestTask.score / operationQualityFactor)))
-        {
-            bestTask = newTask;
-        }
-#endif /* LEARNER_TRY_REMOVE */
-
-#ifdef LEARNER_TRY_REVERSE
-        TM_BEGIN();
-        newTask = TMfindBestReverseTask(TM_ARG  &arg);
-        TM_END();
-
-        if ((newTask.fromId != newTask.toId) &&
-            (newTask.score > (bestTask.score / operationQualityFactor)))
-        {
-            bestTask = newTask;
-        }
-#endif /* LEARNER_TRY_REVERSE */
-
-        if (bestTask.toId != -1) {
-            learner_task_t* tasks = learnerPtr->tasks;
-            tasks[toId] = bestTask;
-            TM_BEGIN();
-            TMLIST_INSERT(taskListPtr, (void*)&tasks[toId]);
-            TM_END();
-#ifdef TEST_LEARNER
-            printf("[new]  op=%i from=%li to=%li score=%lf\n",
-                   bestTask.op, bestTask.fromId, bestTask.toId, bestTask.score);
-            fflush(stdout);
-#endif
-        }
-
-    } /* while (tasks) */
-
-    PBITMAP_FREE(visitedBitmapPtr);
-    PQUEUE_FREE(workQueuePtr);
-    PVECTOR_FREE(bQueryVectorPtr);
-    PVECTOR_FREE(aQueryVectorPtr);
-    PVECTOR_FREE(queryVectorPtr);
-    PVECTOR_FREE(parentQueryVectorPtr);
-    P_FREE(queries);
-
-    TM_THREAD_EXIT();
-}
-
-
-/* =============================================================================
- * learner_run
- * -- Call adtree_make before this
- * =============================================================================
- */
-void
-learner_run (learner_t* learnerPtr)
-{
-#ifdef OTM
-#pragma omp parallel
-    {
-        createTaskList((void*)learnerPtr);
-    }
-#pragma omp parallel
-    {
-        learnStructure((void*)learnerPtr);
-    }
-#else
-    thread_start(&createTaskList, (void*)learnerPtr);
-    thread_start(&learnStructure, (void*)learnerPtr);
-#endif
-}
-
-
-/* =============================================================================
- * learner_score
- * -- Score entire network
- * =============================================================================
- */
-float
-learner_score (learner_t* learnerPtr)
-{
-    adtree_t* adtreePtr = learnerPtr->adtreePtr;
-    net_t* netPtr = learnerPtr->netPtr;
-
-    vector_t* queryVectorPtr = vector_alloc(1);
-    assert(queryVectorPtr);
-    vector_t* parentQueryVectorPtr = vector_alloc(1);
-    assert(parentQueryVectorPtr);
-
-    long numVar = adtreePtr->numVar;
-    query_t* queries = (query_t*)malloc(numVar * sizeof(query_t));
-    assert(queries);
-    long v;
-    for (v = 0; v < numVar; v++) {
-        queries[v].index = v;
-        queries[v].value = QUERY_VALUE_WILDCARD;
-    }
-
-    long numTotalParent = 0;
-    float logLikelihood = 0.0;
-
-    for (v = 0; v < numVar; v++) {
-
-        list_t* parentIdListPtr = net_getParentIdListPtr(netPtr, v);
-        numTotalParent += list_getSize(parentIdListPtr);
-
-
-        populateQueryVectors(netPtr,
-                             v,
-                             queries,
-                             queryVectorPtr,
-                             parentQueryVectorPtr);
-        float localLogLikelihood = computeLocalLogLikelihood(v,
-                                                             adtreePtr,
-                                                             netPtr,
-                                                             queries,
-                                                             queryVectorPtr,
-                                                             parentQueryVectorPtr);
-        logLikelihood += localLogLikelihood;
-    }
-
-    vector_free(queryVectorPtr);
-    vector_free(parentQueryVectorPtr);
-    free(queries);
-
-    long numRecord = adtreePtr->numRecord;
-    float penalty = (float)(-0.5 * (double)numTotalParent * log((double)numRecord));
-    float score = penalty + numRecord * logLikelihood;
-
-    return score;
-}
-
-
-/* #############################################################################
- * TEST_LEARNER
- * #############################################################################
- */
-#ifdef TEST_LEARNER
-
-#include <stdio.h>
-
-
-static void
-testPartition (long min, long max, long n)
-{
-    long start;
-    long stop;
-
-    printf("min=%li max=%li, n=%li\n", min, max, n);
-
-    long i;
-    for (i = 0; i < n; i++) {
-        createPartition(min, max, i, n, &start, &stop);
-        printf("%li: %li -> %li\n", i, start, stop);
-    }
-    puts("");
-}
-
-
-int
-main (int argc, char* argv[])
-{
-    thread_startup(1);
-
-    puts("Starting...");
-
-    testPartition(0, 4, 8);
-    testPartition(0, 15, 8);
-    testPartition(3, 103, 7);
-
-    long numVar = 56;
-    long numRecord = 256;
-
-    random_t* randomPtr = random_alloc();
-    data_t* dataPtr = data_alloc(numVar, numRecord, randomPtr);
-    assert(dataPtr);
-    data_generate(dataPtr, 0, 10, 10);
-
-    adtree_t* adtreePtr = adtree_alloc();
-    assert(adtreePtr);
-    adtree_make(adtreePtr, dataPtr);
-
-
-    learner_t* learnerPtr = learner_alloc(dataPtr, adtreePtr, 1);
-    assert(learnerPtr);
-
-    data_free(dataPtr);
-
-    learner_run(learnerPtr);
-
-    assert(!net_isCycle(learnerPtr->netPtr));
-
-    float score = learner_score(learnerPtr);
-    printf("score = %lf\n", score);
-
-    learner_free(learnerPtr);
-
-    puts("Done.");
-
-    adtree_free(adtreePtr);
-    random_free(randomPtr);
-
-    thread_shutdown();
-
-    return 0;
-}
-
-#endif /* TEST_LEARNER */
-
-
-/* =============================================================================
- *
- * End of learner.h
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/learner.cpp stamp-g/bayes/learner.cpp
--- stamp-0.9.10/bayes/learner.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-g/bayes/learner.cpp	2017-03-21 18:16:25.000000000 +0000
@@ -0,0 +1,2239 @@
+/* =============================================================================
+ *
+ * learn.c
+ * -- Learns structure of Bayesian net from data
+ *
+ * =============================================================================
+ *
+ * Copyright (C) Stanford University, 2006.  All Rights Reserved.
+ * Author: Chi Cao Minh
+ *
+ * =============================================================================
+ *
+ * The penalized log-likelihood score (Friedman & Yahkani, 1996) is used to
+ * evaluated the "goodness" of a Bayesian net:
+ *
+ *                             M      n_j
+ *                            --- --- ---
+ *  -N_params * ln(R) / 2 + R >   >   >   P((a_j = v), X_j) ln P(a_j = v | X_j)
+ *                            --- --- ---
+ *                            j=1 X_j v=1
+ *
+ * Where:
+ *
+ *     N_params     total number of parents across all variables
+ *     R            number of records
+ *     M            number of variables
+ *     X_j          parents of the jth variable
+ *     n_j          number of attributes of the jth variable
+ *     a_j          attribute
+ *
+ * The second summation of X_j varies across all possible assignments to the
+ * values of the parents X_j.
+ *
+ * In the code:
+ *
+ *    "local log likelihood" is  P((a_j = v), X_j) ln P(a_j = v | X_j)
+ *    "log likelihood" is everything to the right of the '+', i.e., "R ... X_j)"
+ *    "base penalty" is -ln(R) / 2
+ *    "penalty" is N_params * -ln(R) / 2
+ *    "score" is the entire expression
+ *
+ * For more notes, refer to:
+ *
+ * A. Moore and M.-S. Lee. Cached sufficient statistics for efficient machine
+ * learning with large datasets. Journal of Artificial Intelligence Research 8
+ * (1998), pp 67-91.
+ *
+ * =============================================================================
+ *
+ * The search strategy uses a combination of local and global structure search.
+ * Similar to the technique described in:
+ *
+ * D. M. Chickering, D. Heckerman, and C. Meek.  A Bayesian approach to learning
+ * Bayesian networks with local structure. In Proceedings of Thirteenth
+ * Conference on Uncertainty in Artificial Intelligence (1997), pp. 80-89.
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+
+
+#include <assert.h>
+#include <math.h>
+#include <stdlib.h>
+#include "adtree.h"
+#include "data.h"
+#include "learner.h"
+#include "list.h"
+#include "net.h"
+#include "operation.h"
+#include "query.h"
+#include "random.h"
+#include "thread.h"
+#include "timer.h"
+#include "utility.h"
+#include "vector.h"
+
+#include "Galois/Galois.h"
+#include "Galois/Accumulator.h"
+#include "Galois/Bag.h"
+#include "Galois/Statistic.h"
+#include <boost/iterator/counting_iterator.hpp>
+
+struct learner_task {
+    operation_t op;
+    long fromId;
+    long toId;
+    float score;
+};
+
+typedef struct findBestTaskArg {
+    long toId;
+    learner_t* learnerPtr;
+    query_t* queries;
+    vector_t* queryVectorPtr;
+    vector_t* parentQueryVectorPtr;
+    long numTotalParent;
+    float basePenalty;
+    float baseLogLikelihood;
+    bitmap_t* bitmapPtr;
+    queue_t* workQueuePtr;
+    vector_t* aQueryVectorPtr;
+    vector_t* bQueryVectorPtr;
+} findBestTaskArg_t;
+
+#ifdef TEST_LEARNER
+long global_maxNumEdgeLearned = -1L;
+long global_insertPenalty = 1;
+float global_operationQualityFactor = 1.0F;
+#else
+extern long global_insertPenalty;
+extern long global_maxNumEdgeLearned;
+extern float global_operationQualityFactor;
+#endif
+
+#ifdef HTM
+template<typename T>
+struct WriteLog {
+    void write(T* addr, T value) {
+        *addr = value;
+    }
+
+    void clear() { }
+};
+
+#else
+template<typename T>
+struct WriteLog: public Galois::Runtime::Releasable {
+    struct Op {
+        typedef int tt_has_known_trivial_constructor;
+        T* addr;
+        T value; 
+    };
+
+    Galois::gdeque<Op> ops;
+
+    virtual ~WriteLog() { cleanup(); }
+    virtual void release() { cleanup(); }
+
+    void cleanup() {
+        while (!ops.empty()) {
+            Op& op = ops.back();
+            *op.addr = op.value;
+            ops.pop_back();
+        }
+    }
+
+    void write(T* addr, T value) {
+        Op undo = { addr, *addr };
+        *addr = value;
+        ops.push_back(undo);
+    }
+
+    void clear() {
+        ops.clear();
+    }
+};
+#endif
+
+
+/* =============================================================================
+ * DECLARATION OF TM_CALLABLE FUNCTIONS
+ * =============================================================================
+ */
+
+TM_CALLABLE
+static learner_task_t
+TMfindBestReverseTask (TM_ARGDECL  findBestTaskArg_t* argPtr, NetOpLog&);
+
+TM_CALLABLE
+static learner_task_t
+TMfindBestInsertTask (TM_ARGDECL  findBestTaskArg_t* argPtr);
+
+TM_CALLABLE
+static learner_task_t
+TMfindBestRemoveTask (TM_ARGDECL  findBestTaskArg_t* argPtr);
+
+/* =============================================================================
+ * compareTask
+ * -- Want greatest score first
+ * -- For list
+ * =============================================================================
+ */
+static long
+compareTask (const void* aPtr, const void* bPtr)
+{
+    learner_task_t* aTaskPtr = (learner_task_t*)aPtr;
+    learner_task_t* bTaskPtr = (learner_task_t*)bPtr;
+    float aScore = aTaskPtr->score;
+    float bScore = bTaskPtr->score;
+
+    if (aScore < bScore) {
+        return 1;
+    } else if (aScore > bScore) {
+        return -1;
+    } else {
+        return (aTaskPtr->toId - bTaskPtr->toId);
+    }
+}
+
+struct TaskIndexer: public std::unary_function<learner_task_t*,int> {
+    int operator()(learner_task_t* taskPtr) {
+      return -taskPtr->score / 1000;
+    }
+};
+
+struct LearnTask {
+    learner_task_t* task;
+    int phase;
+    learner_task_t newTask;
+};
+
+struct LearnTaskIndexer: public std::unary_function<LearnTask, int> {
+    int operator()(const LearnTask& p) {
+      return -p.task->score / 1000;
+    }
+};
+
+struct TaskCompare {
+    bool operator()(learner_task_t* aTaskPtr, learner_task_t* bTaskPtr) const {
+        float aScore = aTaskPtr->score;
+        float bScore = bTaskPtr->score;
+
+        if (aScore < bScore) {
+            return 1;
+        } else if (aScore > bScore) {
+            return -1;
+        } else {
+            return (aTaskPtr->toId - bTaskPtr->toId);
+        }
+    }
+};
+
+struct TaskPairCompare {
+    bool operator()(const LearnTask& a, const LearnTask& b) const {
+        learner_task_t* aTaskPtr = a.task;
+        learner_task_t* bTaskPtr = b.task;
+        float aScore = aTaskPtr->score;
+        float bScore = bTaskPtr->score;
+
+        if (aScore < bScore) {
+            return 1;
+        } else if (aScore > bScore) {
+            return -1;
+        } else {
+            return (aTaskPtr->toId - bTaskPtr->toId);
+        }
+    }
+};
+
+
+/* =============================================================================
+ * compareQuery
+ * -- Want smallest ID first
+ * -- For vector_sort
+ * =============================================================================
+ */
+static long
+compareQuery (const void* aPtr, const void* bPtr)
+{
+    query_t* aQueryPtr = (query_t*)(aPtr);
+    query_t* bQueryPtr = (query_t*)(bPtr);
+
+    return (aQueryPtr->index - bQueryPtr->index);
+}
+
+
+/* =============================================================================
+ * learner_alloc
+ * =============================================================================
+ */
+learner_t*
+learner_alloc (data_t* dataPtr, adtree_t* adtreePtr, long numThread)
+{
+    learner_t* learnerPtr;
+
+    learnerPtr = (learner_t*)malloc(sizeof(learner_t));
+    if (learnerPtr) {
+        learnerPtr->adtreePtr = adtreePtr;
+        learnerPtr->netPtr = net_alloc(dataPtr->numVar);
+        assert(learnerPtr->netPtr);
+        learnerPtr->localBaseLogLikelihoods =
+            (float*)malloc(dataPtr->numVar * sizeof(float));
+        assert(learnerPtr->localBaseLogLikelihoods);
+        learnerPtr->baseLogLikelihood = 0.0F;
+        learnerPtr->tasks =
+            (learner_task_t*)malloc(dataPtr->numVar * sizeof(learner_task_t));
+        assert(learnerPtr->tasks);
+        learnerPtr->taskListPtr = list_alloc(&compareTask); // NB: sorted!!!
+        assert(learnerPtr->taskListPtr);
+        learnerPtr->numTotalParent = 0;
+    }
+
+    return learnerPtr;
+}
+
+
+/* =============================================================================
+ * learner_free
+ * =============================================================================
+ */
+void
+learner_free (learner_t* learnerPtr)
+{
+    list_free(learnerPtr->taskListPtr);
+    free(learnerPtr->tasks);
+    free(learnerPtr->localBaseLogLikelihoods);
+    net_free(learnerPtr->netPtr);
+    free(learnerPtr);
+}
+
+
+/* =============================================================================
+ * computeSpecificLocalLogLikelihood
+ * -- Query vectors should not contain wildcards
+ * =============================================================================
+ */
+static float
+computeSpecificLocalLogLikelihood (adtree_t* adtreePtr,
+                                   vector_t* queryVectorPtr,
+                                   vector_t* parentQueryVectorPtr)
+{
+    long count = adtree_getCount(adtreePtr, queryVectorPtr);
+    if (count == 0) {
+        return 0.0;
+    }
+
+    double probability = (double)count / (double)adtreePtr->numRecord;
+    long parentCount = adtree_getCount(adtreePtr, parentQueryVectorPtr);
+
+    assert(parentCount >= count);
+    assert(parentCount > 0);
+
+    return (float)(probability * (double)log((double)count/ (double)parentCount));
+}
+
+
+/* =============================================================================
+ * createPartition
+ * =============================================================================
+ */
+static void
+createPartition (long min, long max, long id, long n,
+                 long* startPtr, long* stopPtr)
+{
+    long range = max - min;
+    long chunk = 1 > (range + n/2) / n ? 1 : (range + n/2) / n; // MAX(1, ((range + n/2) / n)); /* rounded */
+    long start = min + chunk * id;
+    long stop;
+    if (id == (n-1)) {
+        stop = max;
+    } else {
+        stop = max < (start + chunk) ? max : (start + chunk); //MIN(max, (start + chunk));
+    }
+
+    *startPtr = start;
+    *stopPtr = stop;
+}
+
+struct Fn1 {
+    adtree_t* adtreePtr;
+    float* localBaseLogLikelihoods;
+    Galois::GAccumulator<float>& accum;
+    
+    void operator()(long v) {
+        query_t queries[1];
+        vector_t queryVector;
+        vector_t parentQueryVector;
+        
+        queryVector.push_back(&queries[0]);
+
+        float localBaseLogLikelihood = 0.0;
+        queries[0].index = v;
+
+        queries[0].value = 0;
+        localBaseLogLikelihood +=
+            computeSpecificLocalLogLikelihood(adtreePtr,
+                                              &queryVector,
+                                              &parentQueryVector);
+
+        queries[0].value = 1;
+        localBaseLogLikelihood +=
+            computeSpecificLocalLogLikelihood(adtreePtr,
+                                              &queryVector,
+                                              &parentQueryVector);
+
+        localBaseLogLikelihoods[v] = localBaseLogLikelihood;
+        accum += localBaseLogLikelihood;
+
+    } /* foreach variable */
+};
+
+struct Fn2 {
+    adtree_t* adtreePtr;
+    float* localBaseLogLikelihoods;
+    float baseLogLikelihood;
+    float penalty;
+    long numVar;
+    long numRecord;
+    learner_task_t* tasks;
+    Galois::InsertBag<LearnTask>& taskList;
+
+    void operator()(long v) {
+        /*
+         * Compute base log likelihood for this variable
+         */
+        query_t queries[2];
+        query_t parentQuery;
+        vector_t queryVector;
+        vector_t parentQueryVector;
+
+        queries[0].index = v;
+        long bestLocalIndex = v;
+        float bestLocalLogLikelihood = localBaseLogLikelihoods[v];
+
+        //status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[1]);
+        //assert(status);
+        queryVector.push_back(&queries[0]);
+        queryVector.push_back(&queries[1]);
+        parentQueryVector.push_back(&parentQuery);
+
+        long vv;
+        for (vv = 0; vv < numVar; vv++) {
+
+            if (vv == v) {
+                continue;
+            }
+            parentQuery.index = vv;
+            if (v < vv) {
+                queries[0].index = v;
+                queries[1].index = vv;
+            } else {
+                queries[0].index = vv;
+                queries[1].index = v;
+            }
+
+            float newLocalLogLikelihood = 0.0;
+
+            queries[0].value = 0;
+            queries[1].value = 0;
+            parentQuery.value = 0;
+            newLocalLogLikelihood +=
+                computeSpecificLocalLogLikelihood(adtreePtr,
+                                                  &queryVector,
+                                                  &parentQueryVector);
+
+            queries[0].value = 0;
+            queries[1].value = 1;
+            parentQuery.value = ((vv < v) ? 0 : 1);
+            newLocalLogLikelihood +=
+                computeSpecificLocalLogLikelihood(adtreePtr,
+                                                  &queryVector,
+                                                  &parentQueryVector);
+
+            queries[0].value = 1;
+            queries[1].value = 0;
+            parentQuery.value = ((vv < v) ? 1 : 0);
+            newLocalLogLikelihood +=
+                computeSpecificLocalLogLikelihood(adtreePtr,
+                                                  &queryVector,
+                                                  &parentQueryVector);
+
+            queries[0].value = 1;
+            queries[1].value = 1;
+            parentQuery.value = 1;
+            newLocalLogLikelihood +=
+                computeSpecificLocalLogLikelihood(adtreePtr,
+                                                  &queryVector,
+                                                  &parentQueryVector);
+
+            if (newLocalLogLikelihood > bestLocalLogLikelihood) {
+                bestLocalIndex = vv;
+                bestLocalLogLikelihood = newLocalLogLikelihood;
+            }
+
+        } /* foreach other variable */
+
+
+        if (bestLocalIndex != v) {
+            float logLikelihood = numRecord * (baseLogLikelihood +
+                                                + bestLocalLogLikelihood
+                                                - localBaseLogLikelihoods[v]);
+            float score = penalty + logLikelihood;
+            learner_task_t* taskPtr = &tasks[v];
+            taskPtr->op = OPERATION_INSERT;
+            taskPtr->fromId = bestLocalIndex;
+            taskPtr->toId = v;
+            taskPtr->score = score;
+            LearnTask t = { taskPtr, 0 };
+            taskList.push(t);
+        }
+    } /* for each variable */
+};
+
+/* =============================================================================
+ * createTaskList
+ * -- baseLogLikelihoods and taskListPtr are updated
+ * =============================================================================
+ */
+static void
+createTaskList (void* argPtr, Galois::InsertBag<LearnTask>& taskList)
+{
+    TM_THREAD_ENTER();
+
+    learner_t* learnerPtr = (learner_t*)argPtr;
+
+    adtree_t* adtreePtr = learnerPtr->adtreePtr;
+    float* localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
+    learner_task_t* tasks = learnerPtr->tasks;
+
+    long numVar = adtreePtr->numVar;
+    long numRecord = adtreePtr->numRecord;
+    //float baseLogLikelihood = 0.0;
+    float penalty = (float)(-0.5 * log((double)numRecord)); /* only add 1 edge */
+
+    /*
+     * Compute base log likelihood for each variable and total base loglikelihood
+     */
+    Galois::GAccumulator<float> accum;
+    Fn1 fn1 = { adtreePtr, localBaseLogLikelihoods, accum };
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(numVar), fn1);
+
+    learnerPtr->baseLogLikelihood = accum.reduce();
+
+    /*
+     * For each variable, find if the addition of any edge _to_ it is better
+     */
+    // XXX in original: baseLogLikelihood instead of learnerPtr->baseLogLikelihood
+    Fn2 fn2 = { adtreePtr, localBaseLogLikelihoods, learnerPtr->baseLogLikelihood, penalty, numVar, numRecord, tasks, taskList };
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(numVar), fn2);
+
+#ifdef TEST_LEARNER
+    list_iter_t it;
+    list_iter_reset(&it, taskListPtr);
+    while (list_iter_hasNext(&it, taskListPtr)) {
+        learner_task_t* taskPtr = (learner_task_t*)list_iter_next(&it, taskListPtr);
+        printf("[task] op=%i from=%li to=%li score=%lf\n",
+               taskPtr->op, taskPtr->fromId, taskPtr->toId, taskPtr->score);
+    }
+#endif /* TEST_LEARNER */
+
+    TM_THREAD_EXIT();
+}
+
+
+/* =============================================================================
+ * populateParentQuery
+ * -- Modifies contents of parentQueryVectorPtr
+ * =============================================================================
+ */
+static void
+populateParentQueryVector (net_t* netPtr,
+                           long id,
+                           query_t* queries,
+                           vector_t* parentQueryVectorPtr)
+{
+    vector_clear(parentQueryVectorPtr);
+
+    list_t* parentIdListPtr = net_getParentIdListPtr(netPtr, id);
+    list_iter_t it;
+    list_iter_reset(&it, parentIdListPtr);
+    while (list_iter_hasNext(&it, parentIdListPtr)) {
+        long parentId = (long)list_iter_next(&it, parentIdListPtr);
+        bool_t status = vector_pushBack(parentQueryVectorPtr,
+                                        (void*)&queries[parentId]);
+        assert(status);
+    }
+}
+
+
+/* =============================================================================
+ * TMpopulateParentQuery
+ * -- Modifies contents of parentQueryVectorPtr
+ * =============================================================================
+ */
+static void
+TMpopulateParentQueryVector (TM_ARGDECL
+                             net_t* netPtr,
+                             long id,
+                             query_t* queries,
+                             vector_t* parentQueryVectorPtr)
+{
+    vector_clear(parentQueryVectorPtr);
+
+    list_t* parentIdListPtr = net_getParentIdListPtr(netPtr, id);
+    list_iter_t it;
+    TMLIST_ITER_RESET(&it, parentIdListPtr);
+    while (TMLIST_ITER_HASNEXT(&it, parentIdListPtr)) {
+        long parentId = (long)TMLIST_ITER_NEXT(&it, parentIdListPtr);
+        bool_t status = PVECTOR_PUSHBACK(parentQueryVectorPtr,
+                                         (void*)&queries[parentId]);
+        assert(status);
+    }
+}
+
+
+/* =============================================================================
+ * populateQueryVectors
+ * -- Modifies contents of queryVectorPtr and parentQueryVectorPtr
+ * =============================================================================
+ */
+static void
+populateQueryVectors (net_t* netPtr,
+                      long id,
+                      query_t* queries,
+                      vector_t* queryVectorPtr,
+                      vector_t* parentQueryVectorPtr)
+{
+    populateParentQueryVector(netPtr, id, queries, parentQueryVectorPtr);
+
+    bool_t status;
+    status = vector_copy(queryVectorPtr, parentQueryVectorPtr);
+    assert(status);
+    status = vector_pushBack(queryVectorPtr, (void*)&queries[id]);
+    assert(status);
+    vector_sort(queryVectorPtr, &compareQuery);
+}
+
+
+/* =============================================================================
+ * TMpopulateQueryVectors
+ * -- Modifies contents of queryVectorPtr and parentQueryVectorPtr
+ * =============================================================================
+ */
+static void
+TMpopulateQueryVectors (TM_ARGDECL
+                        net_t* netPtr,
+                        long id,
+                        query_t* queries,
+                        vector_t* queryVectorPtr,
+                        vector_t* parentQueryVectorPtr)
+{
+    TMpopulateParentQueryVector(TM_ARG  netPtr, id, queries, parentQueryVectorPtr);
+
+    bool_t status;
+    status = PVECTOR_COPY(queryVectorPtr, parentQueryVectorPtr);
+    assert(status);
+    status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[id]);
+    assert(status);
+    PVECTOR_SORT(queryVectorPtr, &compareQuery);
+}
+
+
+/* =============================================================================
+ * computeLocalLogLikelihoodHelper
+ * -- Recursive helper routine
+ * =============================================================================
+ */
+static float
+computeLocalLogLikelihoodHelper (long i,
+                                 long numParent,
+                                 adtree_t* adtreePtr,
+                                 query_t* queries,
+                                 vector_t* queryVectorPtr,
+                                 vector_t* parentQueryVectorPtr)
+{
+    if (i >= numParent) {
+        return computeSpecificLocalLogLikelihood(adtreePtr,
+                                                 queryVectorPtr,
+                                                 parentQueryVectorPtr);
+    }
+
+    float localLogLikelihood = 0.0;
+
+    // TODO: check if linear scan is too slow
+    query_t* parentQueryPtr = NULL;
+    auto Pit = parentQueryVectorPtr->begin();
+    std::advance(Pit, i);
+    parentQueryPtr = (query_t*) *Pit;
+    assert(parentQueryPtr);
+    long parentIndex = parentQueryPtr->index;
+
+    queries[parentIndex].value = 0;
+    localLogLikelihood += computeLocalLogLikelihoodHelper((i + 1),
+                                                          numParent,
+                                                          adtreePtr,
+                                                          queries,
+                                                          queryVectorPtr,
+                                                          parentQueryVectorPtr);
+
+    queries[parentIndex].value = 1;
+    localLogLikelihood += computeLocalLogLikelihoodHelper((i + 1),
+                                                          numParent,
+                                                          adtreePtr,
+                                                          queries,
+                                                          queryVectorPtr,
+                                                          parentQueryVectorPtr);
+
+    queries[parentIndex].value = QUERY_VALUE_WILDCARD;
+
+    return localLogLikelihood;
+}
+
+
+/* =============================================================================
+ * computeLocalLogLikelihood
+ * -- Populate the query vectors before passing as args
+ * =============================================================================
+ */
+static float
+computeLocalLogLikelihood (long id,
+                           adtree_t* adtreePtr,
+                           net_t* netPtr,
+                           query_t* queries,
+                           vector_t* queryVectorPtr,
+                           vector_t* parentQueryVectorPtr)
+{
+    long numParent = vector_getSize(parentQueryVectorPtr);
+    float localLogLikelihood = 0.0;
+
+    queries[id].value = 0;
+    localLogLikelihood += computeLocalLogLikelihoodHelper(0,
+                                                          numParent,
+                                                          adtreePtr,
+                                                          queries,
+                                                          queryVectorPtr,
+                                                          parentQueryVectorPtr);
+
+    queries[id].value = 1;
+    localLogLikelihood += computeLocalLogLikelihoodHelper(0,
+                                                          numParent,
+                                                          adtreePtr,
+                                                          queries,
+                                                          queryVectorPtr,
+                                                          parentQueryVectorPtr);
+
+    queries[id].value = QUERY_VALUE_WILDCARD;
+
+    return localLogLikelihood;
+}
+
+
+/* =============================================================================
+ * TMfindBestInsertTask
+ * =============================================================================
+ */
+static learner_task_t
+TMfindBestInsertTask (TM_ARGDECL  findBestTaskArg_t* argPtr)
+{
+    long       toId                     = argPtr->toId;
+    learner_t* learnerPtr               = argPtr->learnerPtr;
+    query_t*   queries                  = argPtr->queries;
+    vector_t*  queryVectorPtr           = argPtr->queryVectorPtr;
+    vector_t*  parentQueryVectorPtr     = argPtr->parentQueryVectorPtr;
+    long       numTotalParent           = argPtr->numTotalParent;
+    float      basePenalty              = argPtr->basePenalty;
+    float      baseLogLikelihood        = argPtr->baseLogLikelihood;
+    bitmap_t*  invalidBitmapPtr         = argPtr->bitmapPtr;
+    queue_t*   workQueuePtr             = argPtr->workQueuePtr;
+    vector_t*  baseParentQueryVectorPtr = argPtr->aQueryVectorPtr;
+    vector_t*  baseQueryVectorPtr       = argPtr->bQueryVectorPtr;
+
+    bool_t status;
+    adtree_t* adtreePtr               = learnerPtr->adtreePtr;
+    net_t*    netPtr                  = learnerPtr->netPtr;
+    float*    localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
+
+    TMpopulateParentQueryVector(TM_ARG  netPtr, toId, queries, parentQueryVectorPtr);
+
+    /*
+     * Create base query and parentQuery
+     */
+
+    status = PVECTOR_COPY(baseParentQueryVectorPtr, parentQueryVectorPtr);
+    assert(status);
+
+    status = PVECTOR_COPY(baseQueryVectorPtr, baseParentQueryVectorPtr);
+    assert(status);
+    status = PVECTOR_PUSHBACK(baseQueryVectorPtr, (void*)&queries[toId]);
+    assert(status);
+    PVECTOR_SORT(queryVectorPtr, &compareQuery);
+
+    /*
+     * Search all possible valid operations for better local log likelihood
+     */
+
+    float bestFromId = toId; /* flag for not found */
+    float oldLocalLogLikelihood =
+        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId]);
+    float bestLocalLogLikelihood = oldLocalLogLikelihood;
+
+    status = TMNET_FINDDESCENDANTS(netPtr, toId, invalidBitmapPtr, workQueuePtr);
+    assert(status);
+    long fromId = -1;
+
+    list_t* parentIdListPtr = net_getParentIdListPtr(netPtr, toId);
+
+    long maxNumEdgeLearned = global_maxNumEdgeLearned;
+
+    if ((maxNumEdgeLearned < 0) ||
+        (list_getSize(parentIdListPtr) <= maxNumEdgeLearned))
+    {
+
+        list_iter_t it;
+        list_iter_reset(&it, parentIdListPtr);
+        while (list_iter_hasNext(&it, parentIdListPtr)) {
+            long parentId = (long)list_iter_next(&it, parentIdListPtr);
+            bitmap_set(invalidBitmapPtr, parentId); /* invalid since already have edge */
+        }
+
+        while ((fromId = bitmap_findClear(invalidBitmapPtr, (fromId + 1))) >= 0) {
+
+            if (fromId == toId) {
+                continue;
+            }
+
+            status = PVECTOR_COPY(queryVectorPtr, baseQueryVectorPtr);
+            assert(status);
+            status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[fromId]);
+            assert(status);
+            PVECTOR_SORT(queryVectorPtr, &compareQuery);
+
+            status = PVECTOR_COPY(parentQueryVectorPtr, baseParentQueryVectorPtr);
+            assert(status);
+            status = PVECTOR_PUSHBACK(parentQueryVectorPtr, (void*)&queries[fromId]);
+            assert(status);
+            PVECTOR_SORT(parentQueryVectorPtr, &compareQuery);
+
+            float newLocalLogLikelihood =
+                computeLocalLogLikelihood(toId,
+                                          adtreePtr,
+                                          netPtr,
+                                          queries,
+                                          queryVectorPtr,
+                                          parentQueryVectorPtr);
+
+            if (newLocalLogLikelihood > bestLocalLogLikelihood) {
+                bestLocalLogLikelihood = newLocalLogLikelihood;
+                bestFromId = fromId;
+            }
+
+        } /* foreach valid parent */
+
+    } /* if have not exceeded max number of edges to learn */
+
+    /*
+     * Return best task; Note: if none is better, fromId will equal toId
+     */
+
+    learner_task_t bestTask;
+    bestTask.op     = OPERATION_INSERT;
+    bestTask.fromId = bestFromId;
+    bestTask.toId   = toId;
+    bestTask.score  = 0.0;
+
+    if (bestFromId != toId) {
+        long numRecord = adtreePtr->numRecord;
+        long numParent = list_getSize(parentIdListPtr) + 1;
+        float penalty =
+            (numTotalParent + numParent * global_insertPenalty) * basePenalty;
+        float logLikelihood = numRecord * (baseLogLikelihood +
+                                           + bestLocalLogLikelihood
+                                           - oldLocalLogLikelihood);
+        float bestScore = penalty + logLikelihood;
+        bestTask.score  = bestScore;
+    }
+
+    return bestTask;
+}
+
+
+#ifdef LEARNER_TRY_REMOVE
+/* =============================================================================
+ * TMfindBestRemoveTask
+ * =============================================================================
+ */
+static learner_task_t
+TMfindBestRemoveTask (TM_ARGDECL  findBestTaskArg_t* argPtr)
+{
+    long       toId                     = argPtr->toId;
+    learner_t* learnerPtr               = argPtr->learnerPtr;
+    query_t*   queries                  = argPtr->queries;
+    vector_t*  queryVectorPtr           = argPtr->queryVectorPtr;
+    vector_t*  parentQueryVectorPtr     = argPtr->parentQueryVectorPtr;
+    long       numTotalParent           = argPtr->numTotalParent;
+    float      basePenalty              = argPtr->basePenalty;
+    float      baseLogLikelihood        = argPtr->baseLogLikelihood;
+    vector_t*  origParentQueryVectorPtr = argPtr->aQueryVectorPtr;
+
+    bool_t status;
+    adtree_t* adtreePtr = learnerPtr->adtreePtr;
+    net_t* netPtr = learnerPtr->netPtr;
+    float* localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
+
+    TMpopulateParentQueryVector(TM_ARG
+                                netPtr, toId, queries, origParentQueryVectorPtr);
+    //long numParent = PVECTOR_GETSIZE(origParentQueryVectorPtr);
+
+    /*
+     * Search all possible valid operations for better local log likelihood
+     */
+
+    float bestFromId = toId; /* flag for not found */
+    float oldLocalLogLikelihood =
+        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId]);
+    float bestLocalLogLikelihood = oldLocalLogLikelihood;
+
+    long i;
+    list_iter_t Iit;
+    list_iter_reset(&Iit, origParentQueryVectorPtr);
+    for (i = 0; list_iter_hasNext(&Iit, origParentQueryVectorPtr)/*i < numParent*/; i++) {
+
+        query_t* queryPtr = (query_t*)list_iter_next(&Iit, origParentQueryVectorPtr);
+        long fromId = queryPtr->index;
+
+        /*
+         * Create parent query (subset of parents since remove an edge)
+         */
+
+        PVECTOR_CLEAR(parentQueryVectorPtr);
+
+        long p;
+        list_iter_t Pit;
+        list_iter_reset(&Pit, origParentQueryVectorPtr);
+        for (p = 0; list_iter_hasNext(&Pit, origParentQueryVectorPtr)/*p < numParent*/; p++) {
+            void * ptr = list_iter_next(&Pit, origParentQueryVectorPtr);
+            if (p != fromId) {
+                query_t* queryPtr = (query_t*) ptr;
+                status = PVECTOR_PUSHBACK(parentQueryVectorPtr,
+                                          (void*)&queries[queryPtr->index]);
+                assert(status);
+            }
+        } /* create new parent query */
+
+        /*
+         * Create query
+         */
+
+        status = PVECTOR_COPY(queryVectorPtr, parentQueryVectorPtr);
+        assert(status);
+        status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[toId]);
+        assert(status);
+        PVECTOR_SORT(queryVectorPtr, &compareQuery);
+
+        /*
+         * See if removing parent is better
+         */
+
+        float newLocalLogLikelihood =
+            computeLocalLogLikelihood(toId,
+                                      adtreePtr,
+                                      netPtr,
+                                      queries,
+                                      queryVectorPtr,
+                                      parentQueryVectorPtr);
+
+        if (newLocalLogLikelihood > bestLocalLogLikelihood) {
+            bestLocalLogLikelihood = newLocalLogLikelihood;
+            bestFromId = fromId;
+        }
+
+    } /* for each parent */
+
+    /*
+     * Return best task; Note: if none is better, fromId will equal toId
+     */
+
+    learner_task_t bestTask;
+    bestTask.op     = OPERATION_REMOVE;
+    bestTask.fromId = bestFromId;
+    bestTask.toId   = toId;
+    bestTask.score  = 0.0;
+
+    if (bestFromId != toId) {
+        long numRecord = adtreePtr->numRecord;
+        float penalty = (numTotalParent - 1) * basePenalty;
+        float logLikelihood = numRecord * (baseLogLikelihood +
+                                            + bestLocalLogLikelihood
+                                            - oldLocalLogLikelihood);
+        float bestScore = penalty + logLikelihood;
+        bestTask.score  = bestScore;
+    }
+
+    return bestTask;
+}
+#endif /* LEARNER_TRY_REMOVE */
+
+
+#ifdef LEARNER_TRY_REVERSE
+/* =============================================================================
+ * TMfindBestReverseTask
+ * =============================================================================
+ */
+static learner_task_t
+TMfindBestReverseTask (TM_ARGDECL  findBestTaskArg_t* argPtr, NetOpLog& opLog)
+{
+    long       toId                         = argPtr->toId;
+    learner_t* learnerPtr                   = argPtr->learnerPtr;
+    query_t*   queries                      = argPtr->queries;
+    vector_t*  queryVectorPtr               = argPtr->queryVectorPtr;
+    vector_t*  parentQueryVectorPtr         = argPtr->parentQueryVectorPtr;
+    long       numTotalParent               = argPtr->numTotalParent;
+    float      basePenalty                  = argPtr->basePenalty;
+    float      baseLogLikelihood            = argPtr->baseLogLikelihood;
+    bitmap_t*  visitedBitmapPtr             = argPtr->bitmapPtr;
+    queue_t*   workQueuePtr                 = argPtr->workQueuePtr;
+    vector_t*  toOrigParentQueryVectorPtr   = argPtr->aQueryVectorPtr;
+    vector_t*  fromOrigParentQueryVectorPtr = argPtr->bQueryVectorPtr;
+
+    bool_t status;
+    adtree_t* adtreePtr = learnerPtr->adtreePtr;
+    net_t* netPtr = learnerPtr->netPtr;
+    float* localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
+
+    TMpopulateParentQueryVector(TM_ARG
+                                netPtr, toId, queries, toOrigParentQueryVectorPtr);
+    //long numParent = PVECTOR_GETSIZE(toOrigParentQueryVectorPtr);
+
+    /*
+     * Search all possible valid operations for better local log likelihood
+     */
+
+    long bestFromId = toId; /* flag for not found */
+    float oldLocalLogLikelihood =
+        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId]);
+    float bestLocalLogLikelihood = oldLocalLogLikelihood;
+    long fromId = 0;
+
+    long i;
+    list_iter_t Iit;
+    list_iter_reset(&Iit, toOrigParentQueryVectorPtr);
+    for (i = 0; list_iter_hasNext(&Iit, toOrigParentQueryVectorPtr)/*i < numParent*/; i++) {
+
+        query_t* queryPtr = (query_t*)list_iter_next(&Iit, toOrigParentQueryVectorPtr);
+        fromId = queryPtr->index;
+
+        bestLocalLogLikelihood =
+            oldLocalLogLikelihood +
+            (float)TM_SHARED_READ_F(localBaseLogLikelihoods[fromId]);
+
+        TMpopulateParentQueryVector(TM_ARG
+                                    netPtr,
+                                    fromId,
+                                    queries,
+                                    fromOrigParentQueryVectorPtr);
+
+        /*
+         * Create parent query (subset of parents since remove an edge)
+         */
+
+        PVECTOR_CLEAR(parentQueryVectorPtr);
+
+        long p;
+        list_iter_t Pit;
+        list_iter_reset(&Pit, toOrigParentQueryVectorPtr);
+        for (p = 0; list_iter_hasNext(&Pit, toOrigParentQueryVectorPtr)/*p < numParent*/; p++) {
+            void* ptr = list_iter_next(&Pit, toOrigParentQueryVectorPtr);
+            if (p != fromId) {
+                query_t* queryPtr = (query_t*) ptr;
+                status = PVECTOR_PUSHBACK(parentQueryVectorPtr,
+                                          (void*)&queries[queryPtr->index]);
+                assert(status);
+            }
+        } /* create new parent query */
+
+        /*
+         * Create query
+         */
+
+        status = PVECTOR_COPY(queryVectorPtr, parentQueryVectorPtr);
+        assert(status);
+        status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[toId]);
+        assert(status);
+        PVECTOR_SORT(queryVectorPtr, &compareQuery);
+
+        /*
+         * Get log likelihood for removing parent from toId
+         */
+
+        float newLocalLogLikelihood =
+            computeLocalLogLikelihood(toId,
+                                      adtreePtr,
+                                      netPtr,
+                                      queries,
+                                      queryVectorPtr,
+                                      parentQueryVectorPtr);
+
+        /*
+         * Get log likelihood for adding parent to fromId
+         */
+
+        status = PVECTOR_COPY(parentQueryVectorPtr, fromOrigParentQueryVectorPtr);
+        assert(status);
+        status = PVECTOR_PUSHBACK(parentQueryVectorPtr, (void*)&queries[toId]);
+        assert(status);
+        PVECTOR_SORT(parentQueryVectorPtr, &compareQuery);
+
+        status = PVECTOR_COPY(queryVectorPtr, parentQueryVectorPtr);
+        assert(status);
+        status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[fromId]);
+        assert(status);
+        PVECTOR_SORT(queryVectorPtr, &compareQuery);
+
+        newLocalLogLikelihood +=
+            computeLocalLogLikelihood(fromId,
+                                      adtreePtr,
+                                      netPtr,
+                                      queries,
+                                      queryVectorPtr,
+                                      parentQueryVectorPtr);
+
+        /*
+         * Record best
+         */
+
+        if (newLocalLogLikelihood > bestLocalLogLikelihood) {
+            bestLocalLogLikelihood = newLocalLogLikelihood;
+            bestFromId = fromId;
+        }
+
+    } /* for each parent */
+
+    /*
+     * Check validity of best
+     */
+
+    if (bestFromId != toId) {
+        bool_t isTaskValid = TRUE;
+        TMNET_APPLYOPERATION(netPtr, OPERATION_REMOVE, bestFromId, toId, opLog);
+        if (TMNET_ISPATH(netPtr,
+                         bestFromId,
+                         toId,
+                         visitedBitmapPtr,
+                         workQueuePtr))
+        {
+            isTaskValid = FALSE;
+        }
+        TMNET_APPLYOPERATION(netPtr, OPERATION_INSERT, bestFromId, toId, opLog);
+        if (!isTaskValid) {
+            bestFromId = toId;
+        }
+    }
+
+    /*
+     * Return best task; Note: if none is better, fromId will equal toId
+     */
+
+    learner_task_t bestTask;
+    bestTask.op     = OPERATION_REVERSE;
+    bestTask.fromId = bestFromId;
+    bestTask.toId   = toId;
+    bestTask.score  = 0.0;
+
+    if (bestFromId != toId) {
+        float fromLocalLogLikelihood =
+            (float)TM_SHARED_READ_F(localBaseLogLikelihoods[bestFromId]);
+        long numRecord = adtreePtr->numRecord;
+        float penalty = numTotalParent * basePenalty;
+        float logLikelihood = numRecord * (baseLogLikelihood +
+                                            + bestLocalLogLikelihood
+                                            - oldLocalLogLikelihood
+                                            - fromLocalLogLikelihood);
+        float bestScore = penalty + logLikelihood;
+        bestTask.score  = bestScore;
+    }
+
+    return bestTask;
+}
+#endif /* LEARNER_TRY_REVERSE */
+
+
+/* =============================================================================
+ * learnStructure
+ *
+ * Note it is okay if the score is not exact, as we are relaxing the greedy
+ * search. This means we do not need to communicate baseLogLikelihood across
+ * threads.
+ * =============================================================================
+ */
+
+struct Fn3 {
+    learner_t* learnerPtr;
+    Galois::Runtime::PerThreadStorage<query_t*>& localQueries;
+    Galois::Runtime::PerThreadStorage<bitmap_t*>& visitedBitmapPtrs;
+
+    void operator()(unsigned tid, unsigned total) {
+        adtree_t* adtreePtr = learnerPtr->adtreePtr;
+        long numVar = adtreePtr->numVar;
+
+        query_t* queries = (query_t*)P_MALLOC(numVar * sizeof(query_t));
+        long v;
+        for (v = 0; v < numVar; v++) {
+            queries[v].index = v;
+            queries[v].value = QUERY_VALUE_WILDCARD;
+        }
+        *localQueries.getLocal() = queries;
+        
+        *visitedBitmapPtrs.getLocal() = PBITMAP_ALLOC(learnerPtr->adtreePtr->numVar);
+    }
+};
+
+struct Fn4 {
+    learner_t* learnerPtr;
+    Galois::Runtime::PerThreadStorage<query_t*>& localQueries;
+    Galois::Runtime::PerThreadStorage<bitmap_t*>& visitedBitmapPtrs;
+    float basePenalty;
+
+    void operator()(const LearnTask& p, Galois::UserContext<LearnTask>& ctx) {
+#if 1
+        switch (p.phase) {
+            case 0: applyOperation(p.task, true, ctx); break;
+            case 1: computeLikelihood(p.task, true, ctx); break;
+            case 2: findNewInsertTask(p.task, ctx); break;
+            case 3: findNewRemoveTask(p.task, p.newTask, ctx); break;
+            case 4: findNewReverseTask(p.task, p.newTask, ctx); break;
+            default: abort();
+        }
+#else
+        performOperation(p.first, ctx);
+#endif
+    }
+
+    bool applyOperation(learner_task_t* taskPtr, bool continuation, Galois::UserContext<LearnTask>& ctx) {
+        net_t* netPtr = learnerPtr->netPtr;
+
+        bitmap_t* visitedBitmapPtr = *visitedBitmapPtrs.getLocal();
+        assert(visitedBitmapPtr);
+
+        queue_t workQueue;
+
+        NetOpLog opLog;
+
+        operation_t op = taskPtr->op;
+        long fromId = taskPtr->fromId;
+        long toId = taskPtr->toId;
+
+        bool_t isTaskValid;
+
+        TM_BEGIN();
+
+        /*
+         * Check if task is still valid
+         */
+        isTaskValid = TRUE;
+        switch (op) {
+            case OPERATION_INSERT: {
+                if (TMNET_HASEDGE(netPtr, fromId, toId) ||
+                    TMNET_ISPATH(netPtr,
+                                 toId,
+                                 fromId,
+                                 visitedBitmapPtr,
+                                 &workQueue))
+                {
+                    isTaskValid = FALSE;
+                }
+                break;
+            }
+            case OPERATION_REMOVE: {
+                /* Can never create cycle, so always valid */
+                break;
+            }
+            case OPERATION_REVERSE: {
+                /* Temporarily remove edge for check */
+                TMNET_APPLYOPERATION(netPtr, OPERATION_REMOVE, fromId, toId, opLog);
+                if (TMNET_ISPATH(netPtr,
+                                 fromId,
+                                 toId,
+                                 visitedBitmapPtr,
+                                 &workQueue))
+                {
+                    isTaskValid = FALSE;
+                }
+                TMNET_APPLYOPERATION(netPtr, OPERATION_INSERT, fromId, toId, opLog);
+                break;
+            }
+            default:
+                assert(0);
+        }
+
+#ifdef TEST_LEARNER
+        printf("[task] op=%i from=%li to=%li score=%lf valid=%s\n",
+               taskPtr->op, taskPtr->fromId, taskPtr->toId, taskPtr->score,
+               (isTaskValid ? "yes" : "no"));
+        fflush(stdout);
+#endif
+
+        /*
+         * Perform task: update graph and probabilities
+         */
+
+        if (isTaskValid) {
+            TMNET_APPLYOPERATION(netPtr, op, fromId, toId, opLog);
+        }
+
+        //Galois::Runtime::checkWrite(Galois::MethodFlag::WRITE, false); // XXX: Failsafe point
+        opLog.clear();
+
+        TM_END();
+        if (isTaskValid == TRUE) {
+            LearnTask t = { taskPtr, 1 };
+            if (continuation)
+                ctx.push(t);
+            return true;
+        } else {
+            LearnTask t = { taskPtr, 1 };
+            if (continuation)
+                ctx.push(t);
+            return false;
+        }
+    }
+
+
+    void computeLikelihood(learner_task_t* taskPtr, bool continuation, Galois::UserContext<LearnTask>& ctx) {
+        net_t* netPtr = learnerPtr->netPtr;
+        adtree_t* adtreePtr = learnerPtr->adtreePtr;
+        float* localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
+        vector_t queryVector;
+        vector_t parentQueryVector;
+        WriteLog<float> floatLog;
+        query_t* queries = *localQueries.getLocal();
+        float deltaLogLikelihood = 0.0;
+        long deltaNumTotalParent = 0;
+
+        operation_t op = taskPtr->op;
+        long fromId = taskPtr->fromId;
+        long toId = taskPtr->toId;
+        switch (op) {
+            float newBaseLogLikelihood;
+            case OPERATION_INSERT: {
+                TM_BEGIN();
+                TMpopulateQueryVectors(TM_ARG
+                                       netPtr,
+                                       toId,
+                                       queries,
+                                       &queryVector,
+                                       &parentQueryVector);
+                newBaseLogLikelihood =
+                    computeLocalLogLikelihood(toId,
+                                              adtreePtr,
+                                              netPtr,
+                                              queries,
+                                              &queryVector,
+                                              &parentQueryVector);
+                float toLocalBaseLogLikelihood =
+                    (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId]);
+                deltaLogLikelihood +=
+                    toLocalBaseLogLikelihood - newBaseLogLikelihood;
+                floatLog.write(&localBaseLogLikelihoods[toId], newBaseLogLikelihood);
+                //TM_SHARED_WRITE_F(localBaseLogLikelihoods[toId],
+                //                  newBaseLogLikelihood);
+                TM_END();
+                TM_BEGIN();
+                deltaNumTotalParent = 1;
+                //long numTotalParent = (long)TM_SHARED_READ(learnerPtr->numTotalParent);
+                //TM_SHARED_WRITE(learnerPtr->numTotalParent, (numTotalParent + 1));
+                TM_END();
+                break;
+            }
+#ifdef LEARNER_TRY_REMOVE
+            case OPERATION_REMOVE: {
+                TM_BEGIN();
+                TMpopulateQueryVectors(TM_ARG
+                                       netPtr,
+                                       fromId,
+                                       queries,
+                                       &queryVector,
+                                       &parentQueryVector);
+                newBaseLogLikelihood =
+                    computeLocalLogLikelihood(fromId,
+                                              adtreePtr,
+                                              netPtr,
+                                              queries,
+                                              &queryVector,
+                                              &parentQueryVector);
+                float fromLocalBaseLogLikelihood =
+                    (float)TM_SHARED_READ_F(localBaseLogLikelihoods[fromId]);
+                deltaLogLikelihood +=
+                    fromLocalBaseLogLikelihood - newBaseLogLikelihood;
+                floatLog.write(&localBaseLogLikelihoods[fromId], newBaseLogLikelihood);
+                //TM_SHARED_WRITE_F(localBaseLogLikelihoods[fromId],
+                //                  newBaseLogLikelihood);
+                TM_END();
+                TM_BEGIN();
+                deltaNumTotalParent = -1;
+                //long numTotalParent = (long)TM_SHARED_READ(learnerPtr->numTotalParent);
+                //TM_SHARED_WRITE(learnerPtr->numTotalParent, (numTotalParent - 1));
+                TM_END();
+                break;
+            }
+#endif /* LEARNER_TRY_REMOVE */
+#ifdef LEARNER_TRY_REVERSE
+            case OPERATION_REVERSE: {
+                TM_BEGIN();
+                TMpopulateQueryVectors(TM_ARG
+                                       netPtr,
+                                       fromId,
+                                       queries,
+                                       &queryVector,
+                                       &parentQueryVector);
+                newBaseLogLikelihood =
+                    computeLocalLogLikelihood(fromId,
+                                              adtreePtr,
+                                              netPtr,
+                                              queries,
+                                              &queryVector,
+                                              &parentQueryVector);
+                float fromLocalBaseLogLikelihood =
+                    (float)TM_SHARED_READ_F(localBaseLogLikelihoods[fromId]);
+                deltaLogLikelihood +=
+                    fromLocalBaseLogLikelihood - newBaseLogLikelihood;
+                floatLog.write(&localBaseLogLikelihoods[fromId], newBaseLogLikelihood);
+                //TM_SHARED_WRITE_F(localBaseLogLikelihoods[fromId],
+                //                  newBaseLogLikelihood);
+                TM_END();
+
+                TM_BEGIN();
+                TMpopulateQueryVectors(TM_ARG
+                                       netPtr,
+                                       toId,
+                                       queries,
+                                       &queryVector,
+                                       &parentQueryVector);
+                newBaseLogLikelihood =
+                    computeLocalLogLikelihood(toId,
+                                              adtreePtr,
+                                              netPtr,
+                                              queries,
+                                              &queryVector,
+                                              &parentQueryVector);
+                float toLocalBaseLogLikelihood =
+                    (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId]);
+                deltaLogLikelihood +=
+                    toLocalBaseLogLikelihood - newBaseLogLikelihood;
+                floatLog.write(&localBaseLogLikelihoods[toId], newBaseLogLikelihood);
+                //TM_SHARED_WRITE_F(localBaseLogLikelihoods[toId],
+                //                  newBaseLogLikelihood);
+                TM_END();
+                break;
+            }
+#endif /* LEARNER_TRY_REVERSE */
+            default:
+                abort();
+        } /* switch op */
+
+        //Galois::Runtime::checkWrite(Galois::MethodFlag::WRITE, false); // XXX: Failsafe point
+        floatLog.clear();
+
+#ifdef HTM
+        if (deltaNumTotalParent)
+            learnerPtr->numTotalParent += deltaNumTotalParent;
+        if (deltaLogLikelihood)
+            learnerPtr->baseLogLikelihood += deltaLogLikelihood;
+#else
+        if (deltaNumTotalParent)
+          __sync_fetch_and_add(&learnerPtr->numTotalParent, deltaNumTotalParent);
+        if (deltaLogLikelihood) {
+            while (true) {
+                static_assert(sizeof(float) == sizeof(int), "");
+                union { float as_float; int as_int; } oldValue = { learnerPtr->baseLogLikelihood };
+                union { float as_float; int as_int; } newValue = { oldValue.as_float + deltaLogLikelihood };
+                if (__sync_bool_compare_and_swap((int*)&learnerPtr->baseLogLikelihood, oldValue.as_int, newValue.as_int))
+                  break;
+            }
+        }
+#endif
+        if (continuation) {
+            LearnTask t = { taskPtr, 2 };
+            ctx.push(t);
+        }
+    }
+
+    void findNewInsertTask(learner_task_t* taskPtr, Galois::UserContext<LearnTask>& ctx) {
+        adtree_t* adtreePtr = learnerPtr->adtreePtr;
+        long numRecord = adtreePtr->numRecord;
+        vector_t queryVector;
+        vector_t parentQueryVector;
+        vector_t aQueryVector;
+        vector_t bQueryVector;
+        bitmap_t* visitedBitmapPtr = *visitedBitmapPtrs.getLocal();
+        assert(visitedBitmapPtr);
+
+        queue_t workQueue;
+        float operationQualityFactor = global_operationQualityFactor;
+        query_t* queries = *localQueries.getLocal();
+        long toId = taskPtr->toId;
+
+        // NB: racy read of learnerPtr->numTotalParent
+        float baseLogLikelihood = learnerPtr->baseLogLikelihood;
+        // NB: racy read of learnerPtr->numTotalParent
+        long numTotalParent = learnerPtr->numTotalParent;
+        
+        /*
+         * Find next task
+         */
+
+        float baseScore = ((float)numTotalParent * basePenalty)
+                           + (numRecord * baseLogLikelihood);
+
+        learner_task_t bestTask;
+        bestTask.op     = NUM_OPERATION;
+        bestTask.toId   = -1;
+        bestTask.fromId = -1;
+        bestTask.score  = baseScore;
+
+        learner_task_t newTask;
+
+        findBestTaskArg_t arg;
+        arg.learnerPtr           = learnerPtr;
+        arg.queries              = queries;
+        arg.queryVectorPtr       = &queryVector;
+        arg.parentQueryVectorPtr = &parentQueryVector;
+        arg.bitmapPtr            = visitedBitmapPtr;
+        arg.workQueuePtr         = &workQueue;
+        arg.aQueryVectorPtr      = &aQueryVector;
+        arg.bQueryVectorPtr      = &bQueryVector;
+        arg.toId              = toId;
+        arg.numTotalParent    = numTotalParent;
+        arg.basePenalty       = basePenalty;
+        arg.baseLogLikelihood = baseLogLikelihood;
+
+        TM_BEGIN();
+        newTask = TMfindBestInsertTask(TM_ARG  &arg);
+        TM_END();
+
+        if ((newTask.fromId != newTask.toId) &&
+            (newTask.score > (bestTask.score / operationQualityFactor)))
+        {
+            bestTask = newTask;
+        }
+        LearnTask t = { taskPtr, 3, bestTask };
+        ctx.push(t);
+    }
+
+    void findNewRemoveTask(learner_task_t* taskPtr, learner_task_t bestTask, Galois::UserContext<LearnTask>& ctx) {
+        adtree_t* adtreePtr = learnerPtr->adtreePtr;
+        long numRecord = adtreePtr->numRecord;
+        vector_t queryVector;
+        vector_t parentQueryVector;
+        vector_t aQueryVector;
+        vector_t bQueryVector;
+        bitmap_t* visitedBitmapPtr = *visitedBitmapPtrs.getLocal();
+        assert(visitedBitmapPtr);
+
+        queue_t workQueue;
+        float operationQualityFactor = global_operationQualityFactor;
+        query_t* queries = *localQueries.getLocal();
+        long toId = taskPtr->toId;
+
+        // NB: racy read of learnerPtr->numTotalParent
+        float baseLogLikelihood = learnerPtr->baseLogLikelihood;
+        // NB: racy read of learnerPtr->numTotalParent
+        long numTotalParent = learnerPtr->numTotalParent;
+        
+        /*
+         * Find next task
+         */
+
+        learner_task_t newTask;
+
+        findBestTaskArg_t arg;
+        arg.learnerPtr           = learnerPtr;
+        arg.queries              = queries;
+        arg.queryVectorPtr       = &queryVector;
+        arg.parentQueryVectorPtr = &parentQueryVector;
+        arg.bitmapPtr            = visitedBitmapPtr;
+        arg.workQueuePtr         = &workQueue;
+        arg.aQueryVectorPtr      = &aQueryVector;
+        arg.bQueryVectorPtr      = &bQueryVector;
+        arg.toId              = toId;
+        arg.numTotalParent    = numTotalParent;
+        arg.basePenalty       = basePenalty;
+        arg.baseLogLikelihood = baseLogLikelihood;
+
+#ifdef LEARNER_TRY_REMOVE
+        TM_BEGIN();
+        newTask = TMfindBestRemoveTask(TM_ARG  &arg);
+        TM_END();
+
+        if ((newTask.fromId != newTask.toId) &&
+            (newTask.score > (bestTask.score / operationQualityFactor)))
+        {
+            bestTask = newTask;
+        }
+#endif /* LEARNER_TRY_REMOVE */
+        LearnTask t = { taskPtr, 4, bestTask };
+        ctx.push(t);
+    }
+
+    void findNewReverseTask(learner_task_t* taskPtr, learner_task_t bestTask, Galois::UserContext<LearnTask>& ctx) {
+        adtree_t* adtreePtr = learnerPtr->adtreePtr;
+        long numRecord = adtreePtr->numRecord;
+        vector_t queryVector;
+        vector_t parentQueryVector;
+        vector_t aQueryVector;
+        vector_t bQueryVector;
+        NetOpLog opLog;
+        bitmap_t* visitedBitmapPtr = *visitedBitmapPtrs.getLocal();
+        assert(visitedBitmapPtr);
+
+        queue_t workQueue;
+        float operationQualityFactor = global_operationQualityFactor;
+        query_t* queries = *localQueries.getLocal();
+        long toId = taskPtr->toId;
+
+        // NB: racy read of learnerPtr->numTotalParent
+        float baseLogLikelihood = learnerPtr->baseLogLikelihood;
+        // NB: racy read of learnerPtr->numTotalParent
+        long numTotalParent = learnerPtr->numTotalParent;
+        
+        /*
+         * Find next task
+         */
+
+        learner_task_t newTask;
+
+        findBestTaskArg_t arg;
+        arg.learnerPtr           = learnerPtr;
+        arg.queries              = queries;
+        arg.queryVectorPtr       = &queryVector;
+        arg.parentQueryVectorPtr = &parentQueryVector;
+        arg.bitmapPtr            = visitedBitmapPtr;
+        arg.workQueuePtr         = &workQueue;
+        arg.aQueryVectorPtr      = &aQueryVector;
+        arg.bQueryVectorPtr      = &bQueryVector;
+        arg.toId              = toId;
+        arg.numTotalParent    = numTotalParent;
+        arg.basePenalty       = basePenalty;
+        arg.baseLogLikelihood = baseLogLikelihood;
+
+#ifdef LEARNER_TRY_REVERSE
+        TM_BEGIN();
+        newTask = TMfindBestReverseTask(TM_ARG  &arg, opLog);
+        TM_END();
+
+        if ((newTask.fromId != newTask.toId) &&
+            (newTask.score > (bestTask.score / operationQualityFactor)))
+        {
+            bestTask = newTask;
+        }
+#endif /* LEARNER_TRY_REVERSE */
+
+        //Galois::Runtime::checkWrite(Galois::MethodFlag::WRITE, false); // XXX: Failsafe point
+        opLog.clear();
+
+        if (bestTask.toId != -1) {
+            learner_task_t* tasks = learnerPtr->tasks;
+            tasks[toId] = bestTask;
+            TM_BEGIN();
+            LearnTask t = { &tasks[toId], 0 };
+            ctx.push(t);
+            TM_END();
+#ifdef TEST_LEARNER
+            printf("[new]  op=%i from=%li to=%li score=%lf\n",
+                   bestTask.op, bestTask.fromId, bestTask.toId, bestTask.score);
+            fflush(stdout);
+#endif
+        }
+    }
+
+    void performOperation(learner_task_t* taskPtr, Galois::UserContext<LearnTask>& ctx) {
+        net_t* netPtr = learnerPtr->netPtr;
+        adtree_t* adtreePtr = learnerPtr->adtreePtr;
+        long numRecord = adtreePtr->numRecord;
+        float* localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
+
+        float operationQualityFactor = global_operationQualityFactor;
+
+        bitmap_t* visitedBitmapPtr = *visitedBitmapPtrs.getLocal();
+        assert(visitedBitmapPtr);
+
+        queue_t workQueue;
+
+        //long numVar = adtreePtr->numVar;
+        query_t* queries = *localQueries.getLocal();
+        assert(queries);
+
+        //float basePenalty = (float)(-0.5 * log((double)numRecord));
+
+        vector_t queryVector;
+        vector_t parentQueryVector;
+        vector_t aQueryVector;
+        vector_t bQueryVector;
+        NetOpLog opLog;
+        WriteLog<float> floatLog;
+
+        findBestTaskArg_t arg;
+        arg.learnerPtr           = learnerPtr;
+        arg.queries              = queries;
+        arg.queryVectorPtr       = &queryVector;
+        arg.parentQueryVectorPtr = &parentQueryVector;
+        arg.bitmapPtr            = visitedBitmapPtr;
+        arg.workQueuePtr         = &workQueue;
+        arg.aQueryVectorPtr      = &aQueryVector;
+        arg.bQueryVectorPtr      = &bQueryVector;
+
+        operation_t op = taskPtr->op;
+        long fromId = taskPtr->fromId;
+        long toId = taskPtr->toId;
+
+        bool_t isTaskValid;
+
+        TM_BEGIN();
+
+        /*
+         * Check if task is still valid
+         */
+        isTaskValid = TRUE;
+        switch (op) {
+            case OPERATION_INSERT: {
+                if (TMNET_HASEDGE(netPtr, fromId, toId) ||
+                    TMNET_ISPATH(netPtr,
+                                 toId,
+                                 fromId,
+                                 visitedBitmapPtr,
+                                 &workQueue))
+                {
+                    isTaskValid = FALSE;
+                }
+                break;
+            }
+            case OPERATION_REMOVE: {
+                /* Can never create cycle, so always valid */
+                break;
+            }
+            case OPERATION_REVERSE: {
+                /* Temporarily remove edge for check */
+                TMNET_APPLYOPERATION(netPtr, OPERATION_REMOVE, fromId, toId, opLog);
+                if (TMNET_ISPATH(netPtr,
+                                 fromId,
+                                 toId,
+                                 visitedBitmapPtr,
+                                 &workQueue))
+                {
+                    isTaskValid = FALSE;
+                }
+                TMNET_APPLYOPERATION(netPtr, OPERATION_INSERT, fromId, toId, opLog);
+                break;
+            }
+            default:
+                assert(0);
+        }
+
+#ifdef TEST_LEARNER
+        printf("[task] op=%i from=%li to=%li score=%lf valid=%s\n",
+               taskPtr->op, taskPtr->fromId, taskPtr->toId, taskPtr->score,
+               (isTaskValid ? "yes" : "no"));
+        fflush(stdout);
+#endif
+
+        /*
+         * Perform task: update graph and probabilities
+         */
+
+        if (isTaskValid) {
+            TMNET_APPLYOPERATION(netPtr, op, fromId, toId, opLog);
+        }
+
+        TM_END();
+
+
+        float deltaLogLikelihood = 0.0;
+        long deltaNumTotalParent = 0;
+
+        if (isTaskValid) {
+            switch (op) {
+                float newBaseLogLikelihood;
+                case OPERATION_INSERT: {
+                    TM_BEGIN();
+                    TMpopulateQueryVectors(TM_ARG
+                                           netPtr,
+                                           toId,
+                                           queries,
+                                           &queryVector,
+                                           &parentQueryVector);
+                    newBaseLogLikelihood =
+                        computeLocalLogLikelihood(toId,
+                                                  adtreePtr,
+                                                  netPtr,
+                                                  queries,
+                                                  &queryVector,
+                                                  &parentQueryVector);
+                    float toLocalBaseLogLikelihood =
+                        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId]);
+                    deltaLogLikelihood +=
+                        toLocalBaseLogLikelihood - newBaseLogLikelihood;
+                    floatLog.write(&localBaseLogLikelihoods[toId], newBaseLogLikelihood);
+                    //TM_SHARED_WRITE_F(localBaseLogLikelihoods[toId],
+                    //                  newBaseLogLikelihood);
+                    TM_END();
+                    TM_BEGIN();
+                    deltaNumTotalParent = 1;
+                    //long numTotalParent = (long)TM_SHARED_READ(learnerPtr->numTotalParent);
+                    //TM_SHARED_WRITE(learnerPtr->numTotalParent, (numTotalParent + 1));
+                    TM_END();
+                    break;
+                }
+#ifdef LEARNER_TRY_REMOVE
+                case OPERATION_REMOVE: {
+                    TM_BEGIN();
+                    TMpopulateQueryVectors(TM_ARG
+                                           netPtr,
+                                           fromId,
+                                           queries,
+                                           &queryVector,
+                                           &parentQueryVector);
+                    newBaseLogLikelihood =
+                        computeLocalLogLikelihood(fromId,
+                                                  adtreePtr,
+                                                  netPtr,
+                                                  queries,
+                                                  &queryVector,
+                                                  &parentQueryVector);
+                    float fromLocalBaseLogLikelihood =
+                        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[fromId]);
+                    deltaLogLikelihood +=
+                        fromLocalBaseLogLikelihood - newBaseLogLikelihood;
+                    floatLog.write(&localBaseLogLikelihoods[fromId], newBaseLogLikelihood);
+                    //TM_SHARED_WRITE_F(localBaseLogLikelihoods[fromId],
+                    //                  newBaseLogLikelihood);
+                    TM_END();
+                    TM_BEGIN();
+                    deltaNumTotalParent = -1;
+                    //long numTotalParent = (long)TM_SHARED_READ(learnerPtr->numTotalParent);
+                    //TM_SHARED_WRITE(learnerPtr->numTotalParent, (numTotalParent - 1));
+                    TM_END();
+                    break;
+                }
+#endif /* LEARNER_TRY_REMOVE */
+#ifdef LEARNER_TRY_REVERSE
+                case OPERATION_REVERSE: {
+                    TM_BEGIN();
+                    TMpopulateQueryVectors(TM_ARG
+                                           netPtr,
+                                           fromId,
+                                           queries,
+                                           &queryVector,
+                                           &parentQueryVector);
+                    newBaseLogLikelihood =
+                        computeLocalLogLikelihood(fromId,
+                                                  adtreePtr,
+                                                  netPtr,
+                                                  queries,
+                                                  &queryVector,
+                                                  &parentQueryVector);
+                    float fromLocalBaseLogLikelihood =
+                        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[fromId]);
+                    deltaLogLikelihood +=
+                        fromLocalBaseLogLikelihood - newBaseLogLikelihood;
+                    floatLog.write(&localBaseLogLikelihoods[fromId], newBaseLogLikelihood);
+                    //TM_SHARED_WRITE_F(localBaseLogLikelihoods[fromId],
+                    //                  newBaseLogLikelihood);
+                    TM_END();
+
+                    TM_BEGIN();
+                    TMpopulateQueryVectors(TM_ARG
+                                           netPtr,
+                                           toId,
+                                           queries,
+                                           &queryVector,
+                                           &parentQueryVector);
+                    newBaseLogLikelihood =
+                        computeLocalLogLikelihood(toId,
+                                                  adtreePtr,
+                                                  netPtr,
+                                                  queries,
+                                                  &queryVector,
+                                                  &parentQueryVector);
+                    float toLocalBaseLogLikelihood =
+                        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId]);
+                    deltaLogLikelihood +=
+                        toLocalBaseLogLikelihood - newBaseLogLikelihood;
+                    floatLog.write(&localBaseLogLikelihoods[toId], newBaseLogLikelihood);
+                    //TM_SHARED_WRITE_F(localBaseLogLikelihoods[toId],
+                    //                  newBaseLogLikelihood);
+                    TM_END();
+                    break;
+                }
+#endif /* LEARNER_TRY_REVERSE */
+                default:
+                    assert(0);
+            } /* switch op */
+
+        } /* if isTaskValid */
+
+        /*
+         * Update/read globals
+         */
+
+        // NB: racy read of learnerPtr->numTotalParent
+        float baseLogLikelihood = learnerPtr->baseLogLikelihood + deltaLogLikelihood;
+        // NB: racy read of learnerPtr->numTotalParent
+        long numTotalParent = learnerPtr->numTotalParent + deltaNumTotalParent;
+
+        TM_BEGIN();
+#if 0
+        float oldBaseLogLikelihood =
+            (float)TM_SHARED_READ_F(learnerPtr->baseLogLikelihood);
+        float newBaseLogLikelihood = oldBaseLogLikelihood + deltaLogLikelihood;
+        TM_SHARED_WRITE_F(learnerPtr->baseLogLikelihood, newBaseLogLikelihood);
+        baseLogLikelihood = newBaseLogLikelihood;
+        numTotalParent = (long)TM_SHARED_READ(learnerPtr->numTotalParent);
+#endif
+        TM_END();
+        
+        /*
+         * Find next task
+         */
+
+        float baseScore = ((float)numTotalParent * basePenalty)
+                           + (numRecord * baseLogLikelihood);
+
+        learner_task_t bestTask;
+        bestTask.op     = NUM_OPERATION;
+        bestTask.toId   = -1;
+        bestTask.fromId = -1;
+        bestTask.score  = baseScore;
+
+        learner_task_t newTask;
+
+        arg.toId              = toId;
+        arg.numTotalParent    = numTotalParent;
+        arg.basePenalty       = basePenalty;
+        arg.baseLogLikelihood = baseLogLikelihood;
+
+        TM_BEGIN();
+        newTask = TMfindBestInsertTask(TM_ARG  &arg);
+        TM_END();
+
+        if ((newTask.fromId != newTask.toId) &&
+            (newTask.score > (bestTask.score / operationQualityFactor)))
+        {
+            bestTask = newTask;
+        }
+
+#ifdef LEARNER_TRY_REMOVE
+        TM_BEGIN();
+        newTask = TMfindBestRemoveTask(TM_ARG  &arg);
+        TM_END();
+
+        if ((newTask.fromId != newTask.toId) &&
+            (newTask.score > (bestTask.score / operationQualityFactor)))
+        {
+            bestTask = newTask;
+        }
+#endif /* LEARNER_TRY_REMOVE */
+
+#ifdef LEARNER_TRY_REVERSE
+        TM_BEGIN();
+        newTask = TMfindBestReverseTask(TM_ARG  &arg, opLog);
+        TM_END();
+
+        if ((newTask.fromId != newTask.toId) &&
+            (newTask.score > (bestTask.score / operationQualityFactor)))
+        {
+            bestTask = newTask;
+        }
+#endif /* LEARNER_TRY_REVERSE */
+
+        //Galois::Runtime::checkWrite(Galois::MethodFlag::WRITE, false); // XXX: Failsafe point
+
+#ifdef HTM
+        if (deltaNumTotalParent)
+            learnerPtr->numTotalParent += deltaNumTotalParent;
+        if (deltaLogLikelihood)
+            learnerPtr->baseLogLikelihood += deltaLogLikelihood;
+#else
+        if (deltaNumTotalParent)
+          __sync_fetch_and_add(&learnerPtr->numTotalParent, deltaNumTotalParent);
+        if (deltaLogLikelihood) {
+            while (true) {
+                static_assert(sizeof(float) == sizeof(int), "");
+                union { float as_float; int as_int; } oldValue = { learnerPtr->baseLogLikelihood };
+                union { float as_float; int as_int; } newValue = { oldValue.as_float + deltaLogLikelihood };
+                if (__sync_bool_compare_and_swap((int*)&learnerPtr->baseLogLikelihood, oldValue.as_int, newValue.as_int))
+                  break;
+            }
+        }
+#endif
+
+        floatLog.clear();
+        opLog.clear();
+
+        if (bestTask.toId != -1) {
+            learner_task_t* tasks = learnerPtr->tasks;
+            tasks[toId] = bestTask;
+            TM_BEGIN();
+            LearnTask t = { &tasks[toId], 0 };
+            ctx.push(t);
+            TM_END();
+#ifdef TEST_LEARNER
+            printf("[new]  op=%i from=%li to=%li score=%lf\n",
+                   bestTask.op, bestTask.fromId, bestTask.toId, bestTask.score);
+            fflush(stdout);
+#endif
+        }
+
+    } /* while (tasks) */
+};
+
+static void
+learnStructure (void* argPtr, Galois::InsertBag<LearnTask>& taskList)
+{
+    learner_t* learnerPtr = (learner_t*)argPtr;
+
+    Galois::Runtime::PerThreadStorage<query_t*> localQueries;
+    Galois::Runtime::PerThreadStorage<bitmap_t*> visitedBitmapPtrs;
+    Fn3 fn3 = { learnerPtr, localQueries, visitedBitmapPtrs };
+
+    Galois::on_each(fn3);
+    
+    adtree_t* adtreePtr = learnerPtr->adtreePtr;
+    long numRecord = adtreePtr->numRecord;
+    float basePenalty = (float)(-0.5 * log((double)numRecord));
+    Fn4 fn4 = { learnerPtr, localQueries, visitedBitmapPtrs, basePenalty };
+    typedef Galois::WorkList::OrderedByIntegerMetric<LearnTaskIndexer, Galois::WorkList::dChunkedFIFO<4> > WL;
+    Galois::for_each(taskList.begin(), taskList.end(), fn4, Galois::wl<WL>());
+
+    for (unsigned i = 0; i < localQueries.size(); ++i) {
+        query_t* q = *localQueries.getRemote(i);
+        if (q) {
+            free(q); 
+        }
+    }
+    for (unsigned i = 0; i < visitedBitmapPtrs.size(); ++i) {
+        bitmap_t* b = *visitedBitmapPtrs.getRemote(i);
+        if (b) {
+            bitmap_free(b);
+        }
+    }
+}
+
+/* =============================================================================
+ * learner_run
+ * -- Call adtree_make before this
+ * =============================================================================
+ */
+void
+learner_run (learner_t* learnerPtr)
+{
+    Galois::reportPageAlloc("MeminfoPre");
+
+    Galois::InsertBag<LearnTask> taskList;
+    createTaskList((void*)learnerPtr, taskList);
+
+    learnStructure((void*)learnerPtr, taskList);
+    Galois::reportPageAlloc("MeminfoPost");
+}
+
+
+/* =============================================================================
+ * learner_score
+ * -- Score entire network
+ * =============================================================================
+ */
+float
+learner_score (learner_t* learnerPtr)
+{
+    adtree_t* adtreePtr = learnerPtr->adtreePtr;
+    net_t* netPtr = learnerPtr->netPtr;
+
+    vector_t* queryVectorPtr = vector_alloc(1);
+    assert(queryVectorPtr);
+    vector_t* parentQueryVectorPtr = vector_alloc(1);
+    assert(parentQueryVectorPtr);
+
+    long numVar = adtreePtr->numVar;
+    query_t* queries = (query_t*)malloc(numVar * sizeof(query_t));
+    assert(queries);
+    long v;
+    for (v = 0; v < numVar; v++) {
+        queries[v].index = v;
+        queries[v].value = QUERY_VALUE_WILDCARD;
+    }
+
+    long numTotalParent = 0;
+    float logLikelihood = 0.0;
+
+    for (v = 0; v < numVar; v++) {
+
+        list_t* parentIdListPtr = net_getParentIdListPtr(netPtr, v);
+        numTotalParent += list_getSize(parentIdListPtr);
+
+
+        populateQueryVectors(netPtr,
+                             v,
+                             queries,
+                             queryVectorPtr,
+                             parentQueryVectorPtr);
+        float localLogLikelihood = computeLocalLogLikelihood(v,
+                                                             adtreePtr,
+                                                             netPtr,
+                                                             queries,
+                                                             queryVectorPtr,
+                                                             parentQueryVectorPtr);
+        logLikelihood += localLogLikelihood;
+    }
+
+    vector_free(queryVectorPtr);
+    vector_free(parentQueryVectorPtr);
+    free(queries);
+
+    long numRecord = adtreePtr->numRecord;
+    float penalty = (float)(-0.5 * (double)numTotalParent * log((double)numRecord));
+    float score = penalty + numRecord * logLikelihood;
+
+    return score;
+}
+
+
+/* #############################################################################
+ * TEST_LEARNER
+ * #############################################################################
+ */
+#ifdef TEST_LEARNER
+
+#include <stdio.h>
+
+
+static void
+testPartition (long min, long max, long n)
+{
+    long start;
+    long stop;
+
+    printf("min=%li max=%li, n=%li\n", min, max, n);
+
+    long i;
+    for (i = 0; i < n; i++) {
+        createPartition(min, max, i, n, &start, &stop);
+        printf("%li: %li -> %li\n", i, start, stop);
+    }
+    puts("");
+}
+
+
+int
+main (int argc, char* argv[])
+{
+    thread_startup(1);
+
+    puts("Starting...");
+
+    testPartition(0, 4, 8);
+    testPartition(0, 15, 8);
+    testPartition(3, 103, 7);
+
+    long numVar = 56;
+    long numRecord = 256;
+
+    random_t* randomPtr = random_alloc();
+    data_t* dataPtr = data_alloc(numVar, numRecord, randomPtr);
+    assert(dataPtr);
+    data_generate(dataPtr, 0, 10, 10);
+
+    adtree_t* adtreePtr = adtree_alloc();
+    assert(adtreePtr);
+    adtree_make(adtreePtr, dataPtr);
+
+
+    learner_t* learnerPtr = learner_alloc(dataPtr, adtreePtr, 1);
+    assert(learnerPtr);
+
+    data_free(dataPtr);
+
+    learner_run(learnerPtr);
+
+    assert(!net_isCycle(learnerPtr->netPtr));
+
+    float score = learner_score(learnerPtr);
+    printf("score = %lf\n", score);
+
+    learner_free(learnerPtr);
+
+    puts("Done.");
+
+    adtree_free(adtreePtr);
+    random_free(randomPtr);
+
+    thread_shutdown();
+
+    return 0;
+}
+
+#endif /* TEST_LEARNER */
+
+
+/* =============================================================================
+ *
+ * End of learner.h
+ *
+ * =============================================================================
+ */
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/learner.h stamp-g/bayes/learner.h
--- stamp-0.9.10/bayes/learner.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/bayes/learner.h	2017-03-20 15:19:41.000000000 +0000
@@ -78,26 +78,26 @@
 #include "net.h"
 #include "query.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct learner_task learner_task_t;
 
 #define CACHE_LINE_SIZE (64)
 
-typedef struct LocalBaseLogLikelihood {
-  XTM_DECL_LOCKABLE(float, value);
-} LocalBaseLogLikelihood;
-
 typedef struct learner {
     adtree_t* adtreePtr;
     net_t* netPtr;
-    LocalBaseLogLikelihood* localBaseLogLikelihoods;
+    float* localBaseLogLikelihoods;
     char pad1[CACHE_LINE_SIZE - sizeof(float*)];
-    XTM_DECL_LOCKABLE(float, baseLogLikelihood);
+    float baseLogLikelihood;
     char pad2[CACHE_LINE_SIZE - sizeof(float)];
     learner_task_t* tasks;
     char pad3[CACHE_LINE_SIZE - sizeof(learner_task_t*)];
     list_t* taskListPtr;
     char pad4[CACHE_LINE_SIZE - sizeof(list_t*)];
-    XTM_DECL_LOCKABLE(long, numTotalParent);
+    long numTotalParent;
     char pad5[CACHE_LINE_SIZE - sizeof(long)];
 } learner_t;
 
@@ -134,6 +134,9 @@
 float
 learner_score (learner_t* learnerPtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* LEARNER_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/net.c stamp-g/bayes/net.c
--- stamp-0.9.10/bayes/net.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/bayes/net.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,989 +0,0 @@
-/* =============================================================================
- *
- * net.c
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <stdlib.h>
-#include "bitmap.h"
-#include "learner.h"
-#include "list.h"
-#include "net.h"
-#include "operation.h"
-#include "queue.h"
-#include "tm.h"
-#include "vector.h"
-
-typedef enum net_node_mark {
-    NET_NODE_MARK_INIT = 0,
-    NET_NODE_MARK_DONE = 1,
-    NET_NODE_MARK_TEST = 2,
-} net_node_mark_t;
-
-typedef struct net_node {
-    long id;
-    list_t* parentIdListPtr;
-    list_t* childIdListPtr;
-    net_node_mark_t mark;
-} net_node_t;
-
-struct net {
-    vector_t* nodeVectorPtr;
-};
-
-
-/* =============================================================================
- * compareId
- * =============================================================================
- */
-static long
-compareId (const void* aPtr, const void* bPtr)
-{
-    long a = (long)aPtr;
-    long b = (long)bPtr;
-
-    return (a - b);
-}
-
-
-/* =============================================================================
- * allocNode
- * =============================================================================
- */
-static net_node_t*
-allocNode (long id)
-{
-    net_node_t* nodePtr;
-
-    nodePtr = (net_node_t*)malloc(sizeof(net_node_t));
-    if (nodePtr) {
-        nodePtr->parentIdListPtr = list_alloc(&compareId);
-        if (nodePtr->parentIdListPtr == NULL) {
-            free(nodePtr);
-            return NULL;
-        }
-        nodePtr->childIdListPtr = list_alloc(&compareId);
-        if (nodePtr->childIdListPtr == NULL) {
-            list_free(nodePtr->parentIdListPtr);
-            free(nodePtr);
-            return NULL;
-        }
-        nodePtr->id = id;
-    }
-
-    return nodePtr;
-}
-
-
-/* =============================================================================
- * freeNode
- * =============================================================================
- */
-static void
-freeNode (net_node_t* nodePtr)
-{
-    Plist_free(nodePtr->childIdListPtr);
-    Plist_free(nodePtr->parentIdListPtr);
-    free(nodePtr);
-}
-
-
-/* =============================================================================
- * net_alloc
- * =============================================================================
- */
-net_t*
-net_alloc (long numNode)
-{
-    net_t* netPtr;
-
-    netPtr = (net_t*)malloc(sizeof(net_t));
-    if (netPtr) {
-        vector_t* nodeVectorPtr = vector_alloc(numNode);
-        if (nodeVectorPtr == NULL) {
-            free(netPtr);
-            return NULL;
-        }
-        long i;
-        for (i = 0; i < numNode; i++) {
-            net_node_t* nodePtr = allocNode(i);
-            if (nodePtr == NULL) {
-                long j;
-                for (j = 0; j < i; j++) {
-                    nodePtr = (net_node_t*)vector_at(nodeVectorPtr, j);
-                    freeNode(nodePtr);
-                }
-                vector_free(nodeVectorPtr);
-                free(netPtr);
-                return NULL;
-            }
-            bool_t status = vector_pushBack(nodeVectorPtr, (void*)nodePtr);
-            assert(status);
-        }
-        netPtr->nodeVectorPtr = nodeVectorPtr;
-    }
-
-    return netPtr;
-}
-
-
-/* =============================================================================
- * net_free
- * =============================================================================
- */
-void
-net_free (net_t* netPtr)
-{
-    long i;
-    vector_t* nodeVectorPtr = netPtr->nodeVectorPtr;
-    long numNode = vector_getSize(nodeVectorPtr);
-    for (i = 0; i < numNode; i++) {
-        net_node_t* nodePtr = (net_node_t*)vector_at(nodeVectorPtr, i);
-        freeNode(nodePtr);
-    }
-    vector_free(netPtr->nodeVectorPtr);
-    free(netPtr);
-}
-
-
-/* =============================================================================
- * insertEdge
- * =============================================================================
- */
-static void
-insertEdge (net_t* netPtr, long fromId, long toId)
-{
-    vector_t* nodeVectorPtr = netPtr->nodeVectorPtr;
-    bool_t status;
-
-    net_node_t* childNodePtr = (net_node_t*)vector_at(nodeVectorPtr, toId);
-    list_t* parentIdListPtr = childNodePtr->parentIdListPtr;
-    status = list_insert(parentIdListPtr, (void*)fromId);
-    assert(status);
-
-    net_node_t* parentNodePtr = (net_node_t*)vector_at(nodeVectorPtr, fromId);
-    list_t* childIdListPtr = parentNodePtr->childIdListPtr;
-    status = list_insert(childIdListPtr, (void*)toId);
-    assert(status);
-}
-
-
-/* =============================================================================
- * TMinsertEdge
- * =============================================================================
- */
-static void
-TMinsertEdge (TM_ARGDECL  net_t* netPtr, long fromId, long toId)
-{
-    vector_t* nodeVectorPtr = netPtr->nodeVectorPtr;
-    bool_t status;
-
-    net_node_t* childNodePtr = (net_node_t*)vector_at(nodeVectorPtr, toId);
-    list_t* parentIdListPtr = childNodePtr->parentIdListPtr;
-    status = TMLIST_INSERT(parentIdListPtr, (void*)fromId);
-    assert(status);
-
-    net_node_t* parentNodePtr = (net_node_t*)vector_at(nodeVectorPtr, fromId);
-    list_t* childIdListPtr = parentNodePtr->childIdListPtr;
-    status = TMLIST_INSERT(childIdListPtr, (void*)toId);
-    assert(status);
-}
-
-
-/* =============================================================================
- * removeEdge
- * =============================================================================
- */
-static void
-removeEdge (net_t* netPtr, long fromId, long toId)
-{
-    vector_t* nodeVectorPtr = netPtr->nodeVectorPtr;
-    bool_t status;
-
-    net_node_t* childNodePtr = (net_node_t*)vector_at(nodeVectorPtr, toId);
-    list_t* parentIdListPtr = childNodePtr->parentIdListPtr;
-    status = list_remove(parentIdListPtr, (void*)fromId);
-    assert(status);
-
-    net_node_t* parentNodePtr = (net_node_t*)vector_at(nodeVectorPtr, fromId);
-    list_t* childIdListPtr = parentNodePtr->childIdListPtr;
-    status = list_remove(childIdListPtr, (void*)toId);
-    assert(status);
-}
-
-
-/* =============================================================================
- * TMremoveEdge
- * =============================================================================
- */
-static void
-TMremoveEdge (TM_ARGDECL  net_t* netPtr, long fromId, long toId)
-{
-    vector_t* nodeVectorPtr = netPtr->nodeVectorPtr;
-    bool_t status;
-
-    net_node_t* childNodePtr = (net_node_t*)vector_at(nodeVectorPtr, toId);
-    list_t* parentIdListPtr = childNodePtr->parentIdListPtr;
-    status = TMLIST_REMOVE(parentIdListPtr, (void*)fromId);
-    assert(status);
-
-    net_node_t* parentNodePtr = (net_node_t*)vector_at(nodeVectorPtr, fromId);
-    list_t* childIdListPtr = parentNodePtr->childIdListPtr;
-    status = TMLIST_REMOVE(childIdListPtr, (void*)toId);
-    assert(status);
-}
-
-
-/* =============================================================================
- * reverseEdge
- * =============================================================================
- */
-static void
-reverseEdge (net_t* netPtr, long fromId, long toId)
-{
-    removeEdge(netPtr, fromId, toId);
-    insertEdge(netPtr, toId, fromId);
-}
-
-
-/* =============================================================================
- * TMreverseEdge
- * =============================================================================
- */
-static void
-TMreverseEdge (TM_ARGDECL  net_t* netPtr, long fromId, long toId)
-{
-    TMremoveEdge(TM_ARG  netPtr, fromId, toId);
-    TMinsertEdge(TM_ARG  netPtr, toId, fromId);
-}
-
-
-/* =============================================================================
- * net_applyOperation
- * =============================================================================
- */
-void
-net_applyOperation (net_t* netPtr, operation_t op, long fromId, long toId)
-{
-    switch (op) {
-        case OPERATION_INSERT:  insertEdge(netPtr, fromId, toId);  break;
-        case OPERATION_REMOVE:  removeEdge(netPtr, fromId, toId);  break;
-        case OPERATION_REVERSE: reverseEdge(netPtr, fromId, toId); break;
-        default:
-            assert(0);
-    }
-}
-
-
-/* =============================================================================
- * TMnet_applyOperation
- * =============================================================================
- */
-void
-TMnet_applyOperation (TM_ARGDECL
-                      net_t* netPtr, operation_t op, long fromId, long toId)
-{
-    switch (op) {
-        case OPERATION_INSERT:  TMinsertEdge(TM_ARG   netPtr, fromId, toId); break;
-        case OPERATION_REMOVE:  TMremoveEdge(TM_ARG   netPtr, fromId, toId); break;
-        case OPERATION_REVERSE: TMreverseEdge(TM_ARG  netPtr, fromId, toId); break;
-        default:
-            assert(0);
-    }
-}
-
-
-/* =============================================================================
- * net_hasEdge
- * =============================================================================
- */
-bool_t
-net_hasEdge (net_t* netPtr, long fromId, long toId)
-{
-    vector_t* nodeVectorPtr = netPtr->nodeVectorPtr;
-    net_node_t* childNodePtr = (net_node_t*)vector_at(nodeVectorPtr, toId);
-    list_t* parentIdListPtr = childNodePtr->parentIdListPtr;
-
-    list_iter_t it;
-    list_iter_reset(&it, parentIdListPtr);
-    while (list_iter_hasNext(&it, parentIdListPtr)) {
-        long parentId = (long)list_iter_next(&it, parentIdListPtr);
-        if (parentId == fromId) {
-            return TRUE;
-        }
-    }
-
-    return FALSE;
-}
-
-
-/* =============================================================================
- * TMnet_hasEdge
- * =============================================================================
- */
-bool_t
-TMnet_hasEdge (TM_ARGDECL  net_t* netPtr, long fromId, long toId)
-{
-    vector_t* nodeVectorPtr = netPtr->nodeVectorPtr;
-    net_node_t* childNodePtr = (net_node_t*)vector_at(nodeVectorPtr, toId);
-    list_t* parentIdListPtr = childNodePtr->parentIdListPtr;
-
-    list_iter_t it;
-    TMLIST_ITER_RESET(&it, parentIdListPtr);
-    while (TMLIST_ITER_HASNEXT(&it, parentIdListPtr)) {
-        long parentId = (long)TMLIST_ITER_NEXT(&it, parentIdListPtr);
-        if (parentId == fromId) {
-            return TRUE;
-        }
-    }
-
-    return FALSE;
-}
-
-
-/* =============================================================================
- * net_isPath
- * =============================================================================
- */
-bool_t
-net_isPath (net_t* netPtr,
-            long fromId,
-            long toId,
-            bitmap_t* visitedBitmapPtr,
-            queue_t* workQueuePtr)
-{
-    bool_t status;
-
-    vector_t* nodeVectorPtr = netPtr->nodeVectorPtr;
-    assert(visitedBitmapPtr->numBit == vector_getSize(nodeVectorPtr));
-
-    bitmap_clearAll(visitedBitmapPtr);
-    queue_clear(workQueuePtr);
-
-    status = queue_push(workQueuePtr, (void*)fromId);
-    assert(status);
-
-    while (!queue_isEmpty(workQueuePtr)) {
-        long id = (long)queue_pop(workQueuePtr);
-        if (id == toId) {
-            queue_clear(workQueuePtr);
-            return TRUE;
-        }
-        status = bitmap_set(visitedBitmapPtr, id);
-        assert(status);
-        net_node_t* nodePtr = (net_node_t*)vector_at(nodeVectorPtr, id);
-        list_t* childIdListPtr = nodePtr->childIdListPtr;
-        list_iter_t it;
-        list_iter_reset(&it, childIdListPtr);
-        while (list_iter_hasNext(&it, childIdListPtr)) {
-            long childId = (long)list_iter_next(&it, childIdListPtr);
-            if (!bitmap_isSet(visitedBitmapPtr, childId)) {
-                status = queue_push(workQueuePtr, (void*)childId);
-                assert(status);
-            }
-        }
-    }
-
-    return FALSE;
-}
-
-
-/* =============================================================================
- * TMnet_isPath
- * =============================================================================
- */
-bool_t
-TMnet_isPath (TM_ARGDECL
-              net_t* netPtr,
-              long fromId,
-              long toId,
-              bitmap_t* visitedBitmapPtr,
-              queue_t* workQueuePtr)
-{
-    bool_t status;
-
-    vector_t* nodeVectorPtr = netPtr->nodeVectorPtr;
-    assert(visitedBitmapPtr->numBit == vector_getSize(nodeVectorPtr));
-
-    PBITMAP_CLEARALL(visitedBitmapPtr);
-    PQUEUE_CLEAR(workQueuePtr);
-
-    status = PQUEUE_PUSH(workQueuePtr, (void*)fromId);
-    assert(status);
-
-    while (!PQUEUE_ISEMPTY(workQueuePtr)) {
-        long id = (long)queue_pop(workQueuePtr);
-        if (id == toId) {
-            queue_clear(workQueuePtr);
-            return TRUE;
-        }
-        status = PBITMAP_SET(visitedBitmapPtr, id);
-        assert(status);
-        net_node_t* nodePtr = (net_node_t*)vector_at(nodeVectorPtr, id);
-        list_t* childIdListPtr = nodePtr->childIdListPtr;
-        list_iter_t it;
-        TMLIST_ITER_RESET(&it, childIdListPtr);
-        while (TMLIST_ITER_HASNEXT(&it, childIdListPtr)) {
-            long childId = (long)TMLIST_ITER_NEXT(&it, childIdListPtr);
-            if (!PBITMAP_ISSET(visitedBitmapPtr, childId)) {
-                status = PQUEUE_PUSH(workQueuePtr, (void*)childId);
-                assert(status);
-            }
-        }
-    }
-
-    return FALSE;
-}
-
-
-/* =============================================================================
- * isCycle
- * =============================================================================
- */
-static bool_t
-isCycle (vector_t* nodeVectorPtr, net_node_t* nodePtr)
-{
-    switch (nodePtr->mark) {
-        case NET_NODE_MARK_INIT: {
-            nodePtr->mark = NET_NODE_MARK_TEST;
-            list_t* childIdListPtr = nodePtr->childIdListPtr;
-            list_iter_t it;
-            list_iter_reset(&it, childIdListPtr);
-            while (list_iter_hasNext(&it, childIdListPtr)) {
-                long childId = (long)list_iter_next(&it, childIdListPtr);
-                net_node_t* childNodePtr =
-                    (net_node_t*)vector_at(nodeVectorPtr, childId);
-                if (isCycle(nodeVectorPtr, childNodePtr)) {
-                    return TRUE;
-                }
-            }
-            break;
-        }
-        case NET_NODE_MARK_TEST:
-            return TRUE;
-        case NET_NODE_MARK_DONE:
-            return FALSE;
-            break;
-        default:
-            assert(0);
-    }
-
-    nodePtr->mark = NET_NODE_MARK_DONE;
-    return FALSE;
-}
-
-
-/* =============================================================================
- * net_isCycle
- * =============================================================================
- */
-bool_t
-net_isCycle (net_t* netPtr)
-{
-    vector_t* nodeVectorPtr = netPtr->nodeVectorPtr;
-    long numNode = vector_getSize(nodeVectorPtr);
-    long n;
-    for (n = 0; n < numNode; n++) {
-        net_node_t* nodePtr = (net_node_t*)vector_at(nodeVectorPtr, n);
-        nodePtr->mark = NET_NODE_MARK_INIT;
-    }
-
-    for (n = 0; n < numNode; n++) {
-        net_node_t* nodePtr = (net_node_t*)vector_at(nodeVectorPtr, n);
-        switch (nodePtr->mark) {
-            case NET_NODE_MARK_INIT:
-                if (isCycle(nodeVectorPtr, nodePtr)) {
-                    return TRUE;
-                }
-                break;
-            case NET_NODE_MARK_DONE:
-                /* do nothing */
-                break;
-            case NET_NODE_MARK_TEST:
-                assert(0);
-                break;
-            default:
-                assert(0);
-                break;
-        }
-    }
-
-    return FALSE;
-}
-
-
-/* =============================================================================
- * net_getParentIdListPtr
- * =============================================================================
- */
-list_t*
-net_getParentIdListPtr (net_t* netPtr, long id)
-{
-    net_node_t* nodePtr = (net_node_t*)vector_at(netPtr->nodeVectorPtr, id);
-    assert(nodePtr);
-
-    return nodePtr->parentIdListPtr;
-}
-
-
-/* =============================================================================
- * net_getChildIdListPtr
- * =============================================================================
- */
-list_t*
-net_getChildIdListPtr (net_t* netPtr, long id)
-{
-    net_node_t* nodePtr = (net_node_t*)vector_at(netPtr->nodeVectorPtr, id);
-    assert(nodePtr);
-
-    return nodePtr->childIdListPtr;
-}
-
-
-/* =============================================================================
- * net_findAncestors
- * -- Contents of bitmapPtr set to 1 if ancestor, else 0
- * -- Returns false if id is not root node (i.e., has cycle back id)
- * =============================================================================
- */
-bool_t
-net_findAncestors (net_t* netPtr,
-                   long id,
-                   bitmap_t* ancestorBitmapPtr,
-                   queue_t* workQueuePtr)
-{
-    bool_t status;
-
-    vector_t* nodeVectorPtr = netPtr->nodeVectorPtr;
-    assert(ancestorBitmapPtr->numBit == vector_getSize(nodeVectorPtr));
-
-    bitmap_clearAll(ancestorBitmapPtr);
-    queue_clear(workQueuePtr);
-
-    {
-        net_node_t* nodePtr = (net_node_t*)vector_at(nodeVectorPtr, id);
-        list_t* parentIdListPtr = nodePtr->parentIdListPtr;
-        list_iter_t it;
-        list_iter_reset(&it, parentIdListPtr);
-        while (list_iter_hasNext(&it, parentIdListPtr)) {
-            long parentId = (long)list_iter_next(&it, parentIdListPtr);
-            status = bitmap_set(ancestorBitmapPtr, parentId);
-            assert(status);
-            status = queue_push(workQueuePtr, (void*)parentId);
-            assert(status);
-        }
-    }
-
-    while (!queue_isEmpty(workQueuePtr)) {
-        long parentId = (long)queue_pop(workQueuePtr);
-        if (parentId == id) {
-            queue_clear(workQueuePtr);
-            return FALSE;
-        }
-        net_node_t* nodePtr = (net_node_t*)vector_at(nodeVectorPtr, parentId);
-        list_t* grandParentIdListPtr = nodePtr->parentIdListPtr;
-        list_iter_t it;
-        list_iter_reset(&it, grandParentIdListPtr);
-        while (list_iter_hasNext(&it, grandParentIdListPtr)) {
-            long grandParentId = (long)list_iter_next(&it, grandParentIdListPtr);
-            if (!bitmap_isSet(ancestorBitmapPtr, grandParentId)) {
-                status = bitmap_set(ancestorBitmapPtr, grandParentId);
-                assert(status);
-                status = queue_push(workQueuePtr, (void*)grandParentId);
-                assert(status);
-            }
-        }
-    }
-
-    return TRUE;
-}
-
-
-/* =============================================================================
- * TMnet_findAncestors
- * -- Contents of bitmapPtr set to 1 if ancestor, else 0
- * -- Returns false if id is not root node (i.e., has cycle back id)
- * =============================================================================
- */
-bool_t
-TMnet_findAncestors (TM_ARGDECL
-                     net_t* netPtr,
-                     long id,
-                     bitmap_t* ancestorBitmapPtr,
-                     queue_t* workQueuePtr)
-{
-    bool_t status;
-
-    vector_t* nodeVectorPtr = netPtr->nodeVectorPtr;
-    assert(ancestorBitmapPtr->numBit == vector_getSize(nodeVectorPtr));
-
-    PBITMAP_CLEARALL(ancestorBitmapPtr);
-    PQUEUE_CLEAR(workQueuePtr);
-
-    {
-        net_node_t* nodePtr = (net_node_t*)vector_at(nodeVectorPtr, id);
-        list_t* parentIdListPtr = nodePtr->parentIdListPtr;
-        list_iter_t it;
-        TMLIST_ITER_RESET(&it, parentIdListPtr);
-        while (TMLIST_ITER_HASNEXT(&it, parentIdListPtr)) {
-            long parentId = (long)TMLIST_ITER_NEXT(&it, parentIdListPtr);
-            status = PBITMAP_SET(ancestorBitmapPtr, parentId);
-            assert(status);
-            status = PQUEUE_PUSH(workQueuePtr, (void*)parentId);
-            assert(status);
-        }
-    }
-
-    while (!PQUEUE_ISEMPTY(workQueuePtr)) {
-        long parentId = (long)PQUEUE_POP(workQueuePtr);
-        if (parentId == id) {
-            PQUEUE_CLEAR(workQueuePtr);
-            return FALSE;
-        }
-        net_node_t* nodePtr = (net_node_t*)vector_at(nodeVectorPtr, parentId);
-        list_t* grandParentIdListPtr = nodePtr->parentIdListPtr;
-        list_iter_t it;
-        TMLIST_ITER_RESET(&it, grandParentIdListPtr);
-        while (TMLIST_ITER_HASNEXT(&it, grandParentIdListPtr)) {
-            long grandParentId = (long)TMLIST_ITER_NEXT(&it, grandParentIdListPtr);
-            if (!PBITMAP_ISSET(ancestorBitmapPtr, grandParentId)) {
-                status = PBITMAP_SET(ancestorBitmapPtr, grandParentId);
-                assert(status);
-                status = PQUEUE_PUSH(workQueuePtr, (void*)grandParentId);
-                assert(status);
-            }
-        }
-    }
-
-    return TRUE;
-}
-
-
-/* =============================================================================
- * net_findDescendants
- * -- Contents of bitmapPtr set to 1 if descendants, else 0
- * -- Returns false if id is not root node (i.e., has cycle back id)
- * =============================================================================
- */
-bool_t
-net_findDescendants (net_t* netPtr,
-                     long id,
-                     bitmap_t* descendantBitmapPtr,
-                     queue_t* workQueuePtr)
-{
-    bool_t status;
-
-    vector_t* nodeVectorPtr = netPtr->nodeVectorPtr;
-    assert(descendantBitmapPtr->numBit == vector_getSize(nodeVectorPtr));
-
-    bitmap_clearAll(descendantBitmapPtr);
-    queue_clear(workQueuePtr);
-
-    {
-        net_node_t* nodePtr = (net_node_t*)vector_at(nodeVectorPtr, id);
-        list_t* childIdListPtr = nodePtr->childIdListPtr;
-        list_iter_t it;
-        list_iter_reset(&it, childIdListPtr);
-        while (list_iter_hasNext(&it, childIdListPtr)) {
-            long childId = (long)list_iter_next(&it, childIdListPtr);
-            status = bitmap_set(descendantBitmapPtr, childId);
-            assert(status);
-            status = queue_push(workQueuePtr, (void*)childId);
-            assert(status);
-        }
-    }
-
-    while (!queue_isEmpty(workQueuePtr)) {
-        long childId = (long)queue_pop(workQueuePtr);
-        if (childId == id) {
-            queue_clear(workQueuePtr);
-            return FALSE;
-        }
-        net_node_t* nodePtr = (net_node_t*)vector_at(nodeVectorPtr, childId);
-        list_t* grandChildIdListPtr = nodePtr->childIdListPtr;
-        list_iter_t it;
-        list_iter_reset(&it, grandChildIdListPtr);
-        while (list_iter_hasNext(&it, grandChildIdListPtr)) {
-            long grandChildId = (long)list_iter_next(&it, grandChildIdListPtr);
-            if (!bitmap_isSet(descendantBitmapPtr, grandChildId)) {
-                status = bitmap_set(descendantBitmapPtr, grandChildId);
-                assert(status);
-                status = queue_push(workQueuePtr, (void*)grandChildId);
-                assert(status);
-            }
-        }
-    }
-
-    return TRUE;
-}
-
-
-/* =============================================================================
- * TMnet_findDescendants
- * -- Contents of bitmapPtr set to 1 if descendants, else 0
- * -- Returns false if id is not root node (i.e., has cycle back id)
- * =============================================================================
- */
-bool_t
-TMnet_findDescendants (TM_ARGDECL
-                       net_t* netPtr,
-                       long id,
-                       bitmap_t* descendantBitmapPtr,
-                       queue_t* workQueuePtr)
-{
-    bool_t status;
-
-    vector_t* nodeVectorPtr = netPtr->nodeVectorPtr;
-    assert(descendantBitmapPtr->numBit == vector_getSize(nodeVectorPtr));
-
-    PBITMAP_CLEARALL(descendantBitmapPtr);
-    PQUEUE_CLEAR(workQueuePtr);
-
-    {
-        net_node_t* nodePtr = (net_node_t*)vector_at(nodeVectorPtr, id);
-        list_t* childIdListPtr = nodePtr->childIdListPtr;
-        list_iter_t it;
-        TMLIST_ITER_RESET(&it, childIdListPtr);
-        while (TMLIST_ITER_HASNEXT(&it, childIdListPtr)) {
-            long childId = (long)TMLIST_ITER_NEXT(&it, childIdListPtr);
-            status = PBITMAP_SET(descendantBitmapPtr, childId);
-            assert(status);
-            status = PQUEUE_PUSH(workQueuePtr, (void*)childId);
-            assert(status);
-        }
-    }
-
-    while (!PQUEUE_ISEMPTY(workQueuePtr)) {
-        long childId = (long)PQUEUE_POP(workQueuePtr);
-        if (childId == id) {
-            queue_clear(workQueuePtr);
-            return FALSE;
-        }
-        net_node_t* nodePtr = (net_node_t*)vector_at(nodeVectorPtr, childId);
-        list_t* grandChildIdListPtr = nodePtr->childIdListPtr;
-        list_iter_t it;
-        TMLIST_ITER_RESET(&it, grandChildIdListPtr);
-        while (TMLIST_ITER_HASNEXT(&it, grandChildIdListPtr)) {
-            long grandChildId = (long)TMLIST_ITER_NEXT(&it, grandChildIdListPtr);
-            if (!PBITMAP_ISSET(descendantBitmapPtr, grandChildId)) {
-                status = PBITMAP_SET(descendantBitmapPtr, grandChildId);
-                assert(status);
-                status = PQUEUE_PUSH(workQueuePtr, (void*)grandChildId);
-                assert(status);
-            }
-        }
-    }
-
-    return TRUE;
-}
-
-
-/* =============================================================================
- * net_generateRandomEdges
- * =============================================================================
- */
-void
-net_generateRandomEdges (net_t* netPtr,
-                         long maxNumParent,
-                         long percentParent,
-                         random_t* randomPtr)
-{
-    vector_t* nodeVectorPtr = netPtr->nodeVectorPtr;
-
-    long numNode = vector_getSize(nodeVectorPtr);
-    bitmap_t* visitedBitmapPtr = bitmap_alloc(numNode);
-    assert(visitedBitmapPtr);
-    queue_t* workQueuePtr = queue_alloc(-1);
-
-    long n;
-
-    for (n = 0; n < numNode; n++) {
-        long p;
-        for (p = 0; p < maxNumParent; p++) {
-            long value = random_generate(randomPtr) % 100;
-            if (value < percentParent) {
-                long parent = random_generate(randomPtr) % numNode;
-                if ((parent != n) &&
-                    !net_hasEdge(netPtr, parent, n) &&
-                    !net_isPath(netPtr, n, parent, visitedBitmapPtr, workQueuePtr))
-                {
-#ifdef TEST_NET
-                    printf("node=%li parent=%li\n", n, parent);
-#endif
-                    insertEdge(netPtr, parent, n);
-                }
-            }
-        }
-    }
-
-    assert(!net_isCycle(netPtr));
-
-    bitmap_free(visitedBitmapPtr);
-    queue_free(workQueuePtr);
-}
-
-
-/* #############################################################################
- * TEST_NET
- * #############################################################################
- */
-#ifdef TEST_NET
-
-#include <stdio.h>
-
-
-int
-main ()
-{
-    long numNode = 100;
-
-    puts("Starting tests...");
-
-    bool_t status;
-
-    net_t* netPtr = net_alloc(numNode);
-    assert(netPtr);
-    bitmap_t* visitedBitmapPtr = bitmap_alloc(numNode);
-    assert(visitedBitmapPtr);
-    queue_t* workQueuePtr = queue_alloc(-1);
-    assert(workQueuePtr);
-
-    assert(!net_isCycle(netPtr));
-
-    long aId = 31;
-    long bId = 14;
-    long cId = 5;
-    long dId = 92;
-
-    net_applyOperation(netPtr, OPERATION_INSERT, aId, bId);
-    assert(net_isPath(netPtr, aId, bId, visitedBitmapPtr, workQueuePtr));
-    assert(!net_isPath(netPtr, bId, aId, visitedBitmapPtr, workQueuePtr));
-    assert(!net_isPath(netPtr, aId, cId, visitedBitmapPtr, workQueuePtr));
-    assert(!net_isPath(netPtr, aId, dId, visitedBitmapPtr, workQueuePtr));
-    assert(!net_isCycle(netPtr));
-
-    net_applyOperation(netPtr, OPERATION_INSERT, bId, cId);
-    net_applyOperation(netPtr, OPERATION_INSERT, aId, cId);
-    net_applyOperation(netPtr, OPERATION_INSERT, dId, aId);
-    assert(!net_isCycle(netPtr));
-    net_applyOperation(netPtr, OPERATION_INSERT, cId, dId);
-    assert(net_isCycle(netPtr));
-    net_applyOperation(netPtr, OPERATION_REVERSE, cId, dId);
-    assert(!net_isCycle(netPtr));
-    net_applyOperation(netPtr, OPERATION_REVERSE, dId, cId);
-    assert(net_isCycle(netPtr));
-    assert(net_isPath(netPtr, aId, dId, visitedBitmapPtr, workQueuePtr));
-    net_applyOperation(netPtr, OPERATION_REMOVE, cId, dId);
-    assert(!net_isPath(netPtr, aId, dId, visitedBitmapPtr, workQueuePtr));
-
-    bitmap_t* ancestorBitmapPtr = bitmap_alloc(numNode);
-    assert(ancestorBitmapPtr);
-    status = net_findAncestors(netPtr, cId, ancestorBitmapPtr, workQueuePtr);
-    assert(status);
-    assert(bitmap_isSet(ancestorBitmapPtr, aId));
-    assert(bitmap_isSet(ancestorBitmapPtr, bId));
-    assert(bitmap_isSet(ancestorBitmapPtr, dId));
-    assert(bitmap_getNumSet(ancestorBitmapPtr) == 3);
-
-    bitmap_t* descendantBitmapPtr = bitmap_alloc(numNode);
-    assert(descendantBitmapPtr);
-    status = net_findDescendants(netPtr, aId, descendantBitmapPtr, workQueuePtr);
-    assert(status);
-    assert(bitmap_isSet(descendantBitmapPtr, bId));
-    assert(bitmap_isSet(descendantBitmapPtr, cId));
-    assert(bitmap_getNumSet(descendantBitmapPtr) == 2);
-
-    bitmap_free(visitedBitmapPtr);
-    queue_free(workQueuePtr);
-    bitmap_free(ancestorBitmapPtr);
-    bitmap_free(descendantBitmapPtr);
-    net_free(netPtr);
-
-    random_t* randomPtr = random_alloc();
-    assert(randomPtr);
-    netPtr = net_alloc(numNode);
-    assert(netPtr);
-    net_generateRandomEdges(netPtr, 10, 10, randomPtr);
-    net_free(netPtr);
-
-    puts("All tests passed.");
-
-    return 0;
-}
-
-
-#endif /* TEST_NET */
-
-
-/* =============================================================================
- *
- * End of net.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/net.cpp stamp-g/bayes/net.cpp
--- stamp-0.9.10/bayes/net.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-g/bayes/net.cpp	2017-03-20 15:19:41.000000000 +0000
@@ -0,0 +1,1050 @@
+/* =============================================================================
+ *
+ * net.c
+ *
+ * =============================================================================
+ *
+ * Copyright (C) Stanford University, 2006.  All Rights Reserved.
+ * Author: Chi Cao Minh
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+
+
+#include <assert.h>
+#include <stdlib.h>
+#include "bitmap.h"
+#include "learner.h"
+#include "list.h"
+#include "net.h"
+#include "operation.h"
+#include "queue.h"
+#include "tm.h"
+#include "vector.h"
+#include <deque>
+
+typedef enum net_node_mark {
+    NET_NODE_MARK_INIT = 0,
+    NET_NODE_MARK_DONE = 1,
+    NET_NODE_MARK_TEST = 2,
+} net_node_mark_t;
+
+typedef struct net_node {
+    long id;
+    list_t* parentIdListPtr;
+    list_t* childIdListPtr;
+    net_node_mark_t mark;
+} net_node_t;
+
+typedef std::deque<net_node_t*> NodeVector;
+
+struct net {
+    NodeVector* nodeVectorPtr;
+};
+
+
+/* =============================================================================
+ * compareId
+ * =============================================================================
+ */
+static long
+compareId (const void* aPtr, const void* bPtr)
+{
+    long a = (long)aPtr;
+    long b = (long)bPtr;
+
+    return (a - b);
+}
+
+
+/* =============================================================================
+ * allocNode
+ * =============================================================================
+ */
+static net_node_t*
+allocNode (long id)
+{
+    net_node_t* nodePtr;
+
+    nodePtr = (net_node_t*)malloc(sizeof(net_node_t));
+    if (nodePtr) {
+        nodePtr->parentIdListPtr = list_alloc(&compareId);
+        if (nodePtr->parentIdListPtr == NULL) {
+            free(nodePtr);
+            return NULL;
+        }
+        nodePtr->childIdListPtr = list_alloc(&compareId);
+        if (nodePtr->childIdListPtr == NULL) {
+            list_free(nodePtr->parentIdListPtr);
+            free(nodePtr);
+            return NULL;
+        }
+        nodePtr->id = id;
+    }
+
+    return nodePtr;
+}
+
+
+/* =============================================================================
+ * freeNode
+ * =============================================================================
+ */
+static void
+freeNode (net_node_t* nodePtr)
+{
+    list_free(nodePtr->childIdListPtr);
+    list_free(nodePtr->parentIdListPtr);
+    free(nodePtr);
+}
+
+
+/* =============================================================================
+ * net_alloc
+ * =============================================================================
+ */
+net_t*
+net_alloc (long numNode)
+{
+    net_t* netPtr;
+
+    netPtr = new net_t;
+    if (netPtr) {
+        NodeVector* nodeVectorPtr = new NodeVector;
+        if (nodeVectorPtr == NULL) {
+            free(netPtr);
+            return NULL;
+        }
+        long i;
+        for (i = 0; i < numNode; i++) {
+            net_node_t* nodePtr = allocNode(i);
+            if (nodePtr == NULL) {
+                long j;
+                for (j = 0; j < i; j++) {
+                    nodePtr = nodeVectorPtr->at(j);
+                    freeNode(nodePtr);
+                }
+                delete nodeVectorPtr;
+                delete netPtr;
+                return NULL;
+            }
+            nodeVectorPtr->push_back(nodePtr);
+        }
+        netPtr->nodeVectorPtr = nodeVectorPtr;
+    }
+
+    return netPtr;
+}
+
+
+/* =============================================================================
+ * net_free
+ * =============================================================================
+ */
+void
+net_free (net_t* netPtr)
+{
+    long i;
+    NodeVector* nodeVectorPtr = netPtr->nodeVectorPtr;
+    long numNode = nodeVectorPtr->size();
+    for (i = 0; i < numNode; i++) {
+        net_node_t* nodePtr = nodeVectorPtr->at(i);
+        freeNode(nodePtr);
+    }
+    delete netPtr->nodeVectorPtr;
+    delete netPtr;
+}
+
+/* =============================================================================
+ * insertEdge
+ * =============================================================================
+ */
+
+static bool_t
+list_insert_helper(list_t* p, void* k) {
+    p->push_front(k);
+    auto ii = p->begin();
+    auto ei = p->end();
+    auto jj = ii;
+    ++jj;
+
+    for (; jj != ei; ++ii, ++jj) {
+        if (*ii > *jj)
+            std::swap(*ii, *jj);
+        else
+            break;
+    }
+    return TRUE;
+}
+
+static void
+insertEdge (net_t* netPtr, long fromId, long toId)
+{
+    NodeVector* nodeVectorPtr = netPtr->nodeVectorPtr;
+    bool_t status;
+
+    net_node_t* childNodePtr = nodeVectorPtr->at(toId);//(net_node_t*)vector_at(nodeVectorPtr, toId);
+    list_t* parentIdListPtr = childNodePtr->parentIdListPtr;
+    status = list_insert_helper(parentIdListPtr, (void*)fromId);
+    assert(status);
+
+    net_node_t* parentNodePtr = nodeVectorPtr->at(fromId);//(net_node_t*)vector_at(nodeVectorPtr, fromId);
+    list_t* childIdListPtr = parentNodePtr->childIdListPtr;
+    status = list_insert_helper(childIdListPtr, (void*)toId);
+    assert(status);
+}
+
+
+/* =============================================================================
+ * TMinsertEdge
+ * =============================================================================
+ */
+static void
+TMinsertEdge (TM_ARGDECL  net_t* netPtr, long fromId, long toId)
+{
+    NodeVector* nodeVectorPtr = netPtr->nodeVectorPtr;
+    bool_t status;
+
+    nodeVectorPtr->at(toId)->parentIdListPtr->acquire();
+    //nodeVectorPtr->at(toId)->childIdListPtr->acquire();
+    nodeVectorPtr->at(fromId)->childIdListPtr->acquire();
+    //nodeVectorPtr->at(fromId)->parentIdListPtr->acquire();
+
+    net_node_t* childNodePtr = nodeVectorPtr->at(toId);
+    list_t* parentIdListPtr = childNodePtr->parentIdListPtr;
+    status = list_insert_helper(parentIdListPtr, (void*)fromId);
+    assert(status);
+
+    net_node_t* parentNodePtr = nodeVectorPtr->at(fromId);
+    list_t* childIdListPtr = parentNodePtr->childIdListPtr;
+    status = list_insert_helper(childIdListPtr, (void*)toId);
+    assert(status);
+}
+
+// Helper to maintain sorted id order
+static bool_t list_remove_helper(list_t* p, void* k) {
+    auto ii = std::find(p->begin(), p->end(), k);
+    auto ei = p->end();
+    if (ii == ei)
+        return FALSE;
+    auto jj = ii;
+    ++jj;
+
+    for (; jj != ei; ++ii, ++jj) {
+        std::swap(*ii, *jj);
+    }
+    p->pop_back();
+    return TRUE;
+}
+
+/* =============================================================================
+ * removeEdge
+ * =============================================================================
+ */
+static void
+removeEdge (net_t* netPtr, long fromId, long toId)
+{
+    //vector_t* nodeVectorPtr = netPtr->nodeVectorPtr;
+    NodeVector* nodeVectorPtr = netPtr->nodeVectorPtr;
+    bool_t status;
+
+    net_node_t* childNodePtr = nodeVectorPtr->at(toId);//(net_node_t*)vector_at(nodeVectorPtr, toId);
+    list_t* parentIdListPtr = childNodePtr->parentIdListPtr;
+    status = list_remove_helper(parentIdListPtr, (void*)fromId);
+    assert(status);
+
+    net_node_t* parentNodePtr = nodeVectorPtr->at(fromId);//(net_node_t*)vector_at(nodeVectorPtr, fromId);
+    list_t* childIdListPtr = parentNodePtr->childIdListPtr;
+    status = list_remove_helper(childIdListPtr, (void*)toId);
+    assert(status);
+}
+
+
+/* =============================================================================
+ * TMremoveEdge
+ * =============================================================================
+ */
+static void
+TMremoveEdge (TM_ARGDECL  net_t* netPtr, long fromId, long toId)
+{
+    NodeVector* nodeVectorPtr = netPtr->nodeVectorPtr;
+    bool_t status;
+
+    nodeVectorPtr->at(toId)->parentIdListPtr->acquire();
+    //nodeVectorPtr->at(toId)->childIdListPtr->acquire();
+    nodeVectorPtr->at(fromId)->childIdListPtr->acquire();
+    //nodeVectorPtr->at(fromId)->parentIdListPtr->acquire();
+
+    net_node_t* childNodePtr = nodeVectorPtr->at(toId);
+    list_t* parentIdListPtr = childNodePtr->parentIdListPtr;
+    status = list_remove_helper(parentIdListPtr, (void*)fromId);
+    assert(status);
+
+    net_node_t* parentNodePtr = nodeVectorPtr->at(fromId);
+    list_t* childIdListPtr = parentNodePtr->childIdListPtr;
+    status = list_remove_helper(childIdListPtr, (void*)toId);
+    assert(status);
+}
+
+
+/* =============================================================================
+ * reverseEdge
+ * =============================================================================
+ */
+static void
+reverseEdge (net_t* netPtr, long fromId, long toId)
+{
+    removeEdge(netPtr, fromId, toId);
+    insertEdge(netPtr, toId, fromId);
+}
+
+
+/* =============================================================================
+ * TMreverseEdge
+ * =============================================================================
+ */
+static void
+TMreverseEdge (TM_ARGDECL  net_t* netPtr, long fromId, long toId)
+{
+    NodeVector* nodeVectorPtr = netPtr->nodeVectorPtr;
+    nodeVectorPtr->at(toId)->parentIdListPtr->acquire();
+    nodeVectorPtr->at(toId)->childIdListPtr->acquire();
+    nodeVectorPtr->at(fromId)->childIdListPtr->acquire();
+    nodeVectorPtr->at(fromId)->parentIdListPtr->acquire();
+
+    removeEdge(netPtr, fromId, toId);
+    insertEdge(netPtr, toId, fromId);
+}
+
+
+/* =============================================================================
+ * net_applyOperation
+ * =============================================================================
+ */
+void
+net_applyOperation (net_t* netPtr, operation_t op, long fromId, long toId)
+{
+    switch (op) {
+        case OPERATION_INSERT:  insertEdge(netPtr, fromId, toId);  break;
+        case OPERATION_REMOVE:  removeEdge(netPtr, fromId, toId);  break;
+        case OPERATION_REVERSE: reverseEdge(netPtr, fromId, toId); break;
+        default:
+            assert(0);
+    }
+}
+
+
+/* =============================================================================
+ * TMnet_applyOperation
+ * =============================================================================
+ */
+void
+TMnet_applyOperation (TM_ARGDECL
+                      net_t* netPtr, operation_t op, long fromId, long toId, NetOpLog& opLog)
+{
+    switch (op) {
+        case OPERATION_INSERT:  TMinsertEdge(TM_ARG   netPtr, fromId, toId); break;
+        case OPERATION_REMOVE:  TMremoveEdge(TM_ARG   netPtr, fromId, toId); break;
+        case OPERATION_REVERSE: TMreverseEdge(TM_ARG  netPtr, fromId, toId); break;
+        default:
+            assert(0);
+    }
+    opLog.insert(netPtr, op, fromId, toId);
+}
+
+
+/* =============================================================================
+ * net_hasEdge
+ * =============================================================================
+ */
+bool_t
+net_hasEdge (net_t* netPtr, long fromId, long toId)
+{
+    NodeVector* nodeVectorPtr = netPtr->nodeVectorPtr;
+    net_node_t* childNodePtr = nodeVectorPtr->at(toId);
+    list_t* parentIdListPtr = childNodePtr->parentIdListPtr;
+
+    list_iter_t it;
+    list_iter_reset(&it, parentIdListPtr);
+    while (list_iter_hasNext(&it, parentIdListPtr)) {
+        long parentId = (long)list_iter_next(&it, parentIdListPtr);
+        if (parentId == fromId) {
+            return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+
+/* =============================================================================
+ * TMnet_hasEdge
+ * =============================================================================
+ */
+bool_t
+TMnet_hasEdge (TM_ARGDECL  net_t* netPtr, long fromId, long toId)
+{
+    NodeVector* nodeVectorPtr = netPtr->nodeVectorPtr;
+    net_node_t* childNodePtr = nodeVectorPtr->at(toId);
+    list_t* parentIdListPtr = childNodePtr->parentIdListPtr;
+
+    //childNodePtr->childIdListPtr->acquire();
+
+    list_iter_t it;
+    TMLIST_ITER_RESET(&it, parentIdListPtr);
+    while (TMLIST_ITER_HASNEXT(&it, parentIdListPtr)) {
+        long parentId = (long)TMLIST_ITER_NEXT(&it, parentIdListPtr);
+        if (parentId == fromId) {
+            return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+
+/* =============================================================================
+ * net_isPath
+ * =============================================================================
+ */
+bool_t
+net_isPath (net_t* netPtr,
+            long fromId,
+            long toId,
+            bitmap_t* visitedBitmapPtr,
+            queue_t* workQueuePtr)
+{
+    bool_t status;
+
+    NodeVector* nodeVectorPtr = netPtr->nodeVectorPtr;
+    assert((unsigned)visitedBitmapPtr->numBit == nodeVectorPtr->size());//vector_getSize(nodeVectorPtr));
+
+    bitmap_clearAll(visitedBitmapPtr);
+    queue_clear(workQueuePtr);
+
+    status = queue_push(workQueuePtr, (void*)fromId);
+    assert(status);
+
+    while (!queue_isEmpty(workQueuePtr)) {
+        long id = (long)queue_pop(workQueuePtr);
+        if (id == toId) {
+            queue_clear(workQueuePtr);
+            return TRUE;
+        }
+        status = bitmap_set(visitedBitmapPtr, id);
+        assert(status);
+        net_node_t* nodePtr = nodeVectorPtr->at(id);//(net_node_t*)vector_at(nodeVectorPtr, id);
+        list_t* childIdListPtr = nodePtr->childIdListPtr;
+        list_iter_t it;
+        list_iter_reset(&it, childIdListPtr);
+        while (list_iter_hasNext(&it, childIdListPtr)) {
+            long childId = (long)list_iter_next(&it, childIdListPtr);
+            if (!bitmap_isSet(visitedBitmapPtr, childId)) {
+                status = queue_push(workQueuePtr, (void*)childId);
+                assert(status);
+            }
+        }
+    }
+
+    return FALSE;
+}
+
+
+/* =============================================================================
+ * TMnet_isPath
+ * =============================================================================
+ */
+bool_t
+TMnet_isPath (TM_ARGDECL
+              net_t* netPtr,
+              long fromId,
+              long toId,
+              bitmap_t* visitedBitmapPtr,
+              queue_t* workQueuePtr)
+{
+    bool_t status;
+
+    NodeVector* nodeVectorPtr = netPtr->nodeVectorPtr;
+    assert((unsigned)visitedBitmapPtr->numBit == nodeVectorPtr->size());//vector_getSize(nodeVectorPtr));
+
+    PBITMAP_CLEARALL(visitedBitmapPtr);
+    PQUEUE_CLEAR(workQueuePtr);
+
+    status = PQUEUE_PUSH(workQueuePtr, (void*)fromId);
+    assert(status);
+
+    while (!PQUEUE_ISEMPTY(workQueuePtr)) {
+        long id = (long)queue_pop(workQueuePtr);
+        nodeVectorPtr->at(id)->childIdListPtr->acquire();
+        if (id == toId) {
+            queue_clear(workQueuePtr);
+            return TRUE;
+        }
+        status = PBITMAP_SET(visitedBitmapPtr, id);
+        assert(status);
+        net_node_t* nodePtr = nodeVectorPtr->at(id);
+        list_t* childIdListPtr = nodePtr->childIdListPtr;
+        list_iter_t it;
+        //TMLIST_ITER_RESET(&it, childIdListPtr);
+        list_iter_reset(&it, childIdListPtr);
+        while (list_iter_hasNext(&it, childIdListPtr)) {
+            long childId = (long)list_iter_next(&it, childIdListPtr);
+            if (!PBITMAP_ISSET(visitedBitmapPtr, childId)) {
+                status = PQUEUE_PUSH(workQueuePtr, (void*)childId);
+                assert(status);
+            }
+        }
+    }
+
+    return FALSE;
+}
+
+
+/* =============================================================================
+ * isCycle
+ * =============================================================================
+ */
+static bool_t
+isCycle (NodeVector* nodeVectorPtr, net_node_t* nodePtr)
+{
+    switch (nodePtr->mark) {
+        case NET_NODE_MARK_INIT: {
+            nodePtr->mark = NET_NODE_MARK_TEST;
+            list_t* childIdListPtr = nodePtr->childIdListPtr;
+            list_iter_t it;
+            list_iter_reset(&it, childIdListPtr);
+            while (list_iter_hasNext(&it, childIdListPtr)) {
+                long childId = (long)list_iter_next(&it, childIdListPtr);
+                net_node_t* childNodePtr = nodeVectorPtr->at(childId);//(net_node_t*)vector_at(nodeVectorPtr, childId);
+                if (isCycle(nodeVectorPtr, childNodePtr)) {
+                    return TRUE;
+                }
+            }
+            break;
+        }
+        case NET_NODE_MARK_TEST:
+            return TRUE;
+        case NET_NODE_MARK_DONE:
+            return FALSE;
+            break;
+        default:
+            assert(0);
+    }
+
+    nodePtr->mark = NET_NODE_MARK_DONE;
+    return FALSE;
+}
+
+
+/* =============================================================================
+ * net_isCycle
+ * =============================================================================
+ */
+bool_t
+net_isCycle (net_t* netPtr)
+{
+    NodeVector* nodeVectorPtr = netPtr->nodeVectorPtr;
+    long numNode = nodeVectorPtr->size();//vector_getSize(nodeVectorPtr);
+    long n;
+    for (n = 0; n < numNode; n++) {
+        net_node_t* nodePtr = nodeVectorPtr->at(n);//(net_node_t*)vector_at(nodeVectorPtr, n);
+        nodePtr->mark = NET_NODE_MARK_INIT;
+    }
+
+    for (n = 0; n < numNode; n++) {
+        net_node_t* nodePtr = nodeVectorPtr->at(n);//(net_node_t*)vector_at(nodeVectorPtr, n);
+        switch (nodePtr->mark) {
+            case NET_NODE_MARK_INIT:
+                if (isCycle(nodeVectorPtr, nodePtr)) {
+                    return TRUE;
+                }
+                break;
+            case NET_NODE_MARK_DONE:
+                /* do nothing */
+                break;
+            case NET_NODE_MARK_TEST:
+                assert(0);
+                break;
+            default:
+                assert(0);
+                break;
+        }
+    }
+
+    return FALSE;
+}
+
+
+/* =============================================================================
+ * net_getParentIdListPtr
+ * =============================================================================
+ */
+list_t*
+net_getParentIdListPtr (net_t* netPtr, long id)
+{
+    net_node_t* nodePtr = netPtr->nodeVectorPtr->at(id);
+    assert(nodePtr);
+
+    return nodePtr->parentIdListPtr;
+}
+
+
+/* =============================================================================
+ * net_getChildIdListPtr
+ * =============================================================================
+ */
+list_t*
+net_getChildIdListPtr (net_t* netPtr, long id)
+{
+    net_node_t* nodePtr = netPtr->nodeVectorPtr->at(id);
+    assert(nodePtr);
+
+    return nodePtr->childIdListPtr;
+}
+
+
+/* =============================================================================
+ * net_findAncestors
+ * -- Contents of bitmapPtr set to 1 if ancestor, else 0
+ * -- Returns false if id is not root node (i.e., has cycle back id)
+ * =============================================================================
+ */
+bool_t
+net_findAncestors (net_t* netPtr,
+                   long id,
+                   bitmap_t* ancestorBitmapPtr,
+                   queue_t* workQueuePtr)
+{
+    bool_t status;
+
+    NodeVector* nodeVectorPtr = netPtr->nodeVectorPtr;
+    assert((unsigned)ancestorBitmapPtr->numBit == nodeVectorPtr->size());//vector_getSize(nodeVectorPtr));
+
+    bitmap_clearAll(ancestorBitmapPtr);
+    queue_clear(workQueuePtr);
+
+    {
+        net_node_t* nodePtr = nodeVectorPtr->at(id);//(net_node_t*)vector_at(nodeVectorPtr, id);
+        list_t* parentIdListPtr = nodePtr->parentIdListPtr;
+        list_iter_t it;
+        list_iter_reset(&it, parentIdListPtr);
+        while (list_iter_hasNext(&it, parentIdListPtr)) {
+            long parentId = (long)list_iter_next(&it, parentIdListPtr);
+            status = bitmap_set(ancestorBitmapPtr, parentId);
+            assert(status);
+            status = queue_push(workQueuePtr, (void*)parentId);
+            assert(status);
+        }
+    }
+
+    while (!queue_isEmpty(workQueuePtr)) {
+        long parentId = (long)queue_pop(workQueuePtr);
+        if (parentId == id) {
+            queue_clear(workQueuePtr);
+            return FALSE;
+        }
+        net_node_t* nodePtr = nodeVectorPtr->at(parentId);//(net_node_t*)vector_at(nodeVectorPtr, parentId);
+        list_t* grandParentIdListPtr = nodePtr->parentIdListPtr;
+        list_iter_t it;
+        list_iter_reset(&it, grandParentIdListPtr);
+        while (list_iter_hasNext(&it, grandParentIdListPtr)) {
+            long grandParentId = (long)list_iter_next(&it, grandParentIdListPtr);
+            if (!bitmap_isSet(ancestorBitmapPtr, grandParentId)) {
+                status = bitmap_set(ancestorBitmapPtr, grandParentId);
+                assert(status);
+                status = queue_push(workQueuePtr, (void*)grandParentId);
+                assert(status);
+            }
+        }
+    }
+
+    return TRUE;
+}
+
+
+/* =============================================================================
+ * TMnet_findAncestors
+ * -- Contents of bitmapPtr set to 1 if ancestor, else 0
+ * -- Returns false if id is not root node (i.e., has cycle back id)
+ * =============================================================================
+ */
+bool_t
+TMnet_findAncestors (TM_ARGDECL
+                     net_t* netPtr,
+                     long id,
+                     bitmap_t* ancestorBitmapPtr,
+                     queue_t* workQueuePtr)
+{
+    bool_t status;
+
+    NodeVector* nodeVectorPtr = netPtr->nodeVectorPtr;
+    assert((unsigned)ancestorBitmapPtr->numBit == nodeVectorPtr->size());
+
+    PBITMAP_CLEARALL(ancestorBitmapPtr);
+    PQUEUE_CLEAR(workQueuePtr);
+
+    {
+        net_node_t* nodePtr = nodeVectorPtr->at(id);
+        list_t* parentIdListPtr = nodePtr->parentIdListPtr;
+        list_iter_t it;
+        TMLIST_ITER_RESET(&it, parentIdListPtr);
+        while (TMLIST_ITER_HASNEXT(&it, parentIdListPtr)) {
+            long parentId = (long)TMLIST_ITER_NEXT(&it, parentIdListPtr);
+            status = PBITMAP_SET(ancestorBitmapPtr, parentId);
+            assert(status);
+            status = PQUEUE_PUSH(workQueuePtr, (void*)parentId);
+            assert(status);
+        }
+    }
+
+    while (!PQUEUE_ISEMPTY(workQueuePtr)) {
+        long parentId = (long)PQUEUE_POP(workQueuePtr);
+        nodeVectorPtr->at(parentId)->parentIdListPtr->acquire();
+
+        if (parentId == id) {
+            PQUEUE_CLEAR(workQueuePtr);
+            return FALSE;
+        }
+        net_node_t* nodePtr = nodeVectorPtr->at(parentId);
+        list_t* grandParentIdListPtr = nodePtr->parentIdListPtr;
+        list_iter_t it;
+        //TMLIST_ITER_RESET(&it, grandParentIdListPtr);
+        list_iter_reset(&it, grandParentIdListPtr);
+        while (list_iter_hasNext(&it, grandParentIdListPtr)) {
+            long grandParentId = (long)list_iter_next(&it, grandParentIdListPtr);
+            if (!PBITMAP_ISSET(ancestorBitmapPtr, grandParentId)) {
+                status = PBITMAP_SET(ancestorBitmapPtr, grandParentId);
+                assert(status);
+                status = PQUEUE_PUSH(workQueuePtr, (void*)grandParentId);
+                assert(status);
+            }
+        }
+    }
+
+    return TRUE;
+}
+
+
+/* =============================================================================
+ * net_findDescendants
+ * -- Contents of bitmapPtr set to 1 if descendants, else 0
+ * -- Returns false if id is not root node (i.e., has cycle back id)
+ * =============================================================================
+ */
+bool_t
+net_findDescendants (net_t* netPtr,
+                     long id,
+                     bitmap_t* descendantBitmapPtr,
+                     queue_t* workQueuePtr)
+{
+    bool_t status;
+
+    NodeVector* nodeVectorPtr = netPtr->nodeVectorPtr;
+    assert((unsigned)descendantBitmapPtr->numBit == nodeVectorPtr->size());//vector_getSize(nodeVectorPtr));
+
+    bitmap_clearAll(descendantBitmapPtr);
+    queue_clear(workQueuePtr);
+
+    {
+        net_node_t* nodePtr = nodeVectorPtr->at(id);//(net_node_t*)vector_at(nodeVectorPtr, id);
+        list_t* childIdListPtr = nodePtr->childIdListPtr;
+        list_iter_t it;
+        list_iter_reset(&it, childIdListPtr);
+        while (list_iter_hasNext(&it, childIdListPtr)) {
+            long childId = (long)list_iter_next(&it, childIdListPtr);
+            status = bitmap_set(descendantBitmapPtr, childId);
+            assert(status);
+            status = queue_push(workQueuePtr, (void*)childId);
+            assert(status);
+        }
+    }
+
+    while (!queue_isEmpty(workQueuePtr)) {
+        long childId = (long)queue_pop(workQueuePtr);
+        if (childId == id) {
+            queue_clear(workQueuePtr);
+            return FALSE;
+        }
+        net_node_t* nodePtr = nodeVectorPtr->at(childId);//(net_node_t*)vector_at(nodeVectorPtr, childId);
+        list_t* grandChildIdListPtr = nodePtr->childIdListPtr;
+        list_iter_t it;
+        list_iter_reset(&it, grandChildIdListPtr);
+        while (list_iter_hasNext(&it, grandChildIdListPtr)) {
+            long grandChildId = (long)list_iter_next(&it, grandChildIdListPtr);
+            if (!bitmap_isSet(descendantBitmapPtr, grandChildId)) {
+                status = bitmap_set(descendantBitmapPtr, grandChildId);
+                assert(status);
+                status = queue_push(workQueuePtr, (void*)grandChildId);
+                assert(status);
+            }
+        }
+    }
+
+    return TRUE;
+}
+
+
+/* =============================================================================
+ * TMnet_findDescendants
+ * -- Contents of bitmapPtr set to 1 if descendants, else 0
+ * -- Returns false if id is not root node (i.e., has cycle back id)
+ * =============================================================================
+ */
+bool_t
+TMnet_findDescendants (TM_ARGDECL
+                       net_t* netPtr,
+                       long id,
+                       bitmap_t* descendantBitmapPtr,
+                       queue_t* workQueuePtr)
+{
+    bool_t status;
+
+    NodeVector* nodeVectorPtr = netPtr->nodeVectorPtr;
+    assert((unsigned)descendantBitmapPtr->numBit == nodeVectorPtr->size());
+
+    PBITMAP_CLEARALL(descendantBitmapPtr);
+    PQUEUE_CLEAR(workQueuePtr);
+
+    {
+        net_node_t* nodePtr = nodeVectorPtr->at(id);
+        list_t* childIdListPtr = nodePtr->childIdListPtr;
+        list_iter_t it;
+        TMLIST_ITER_RESET(&it, childIdListPtr);
+        while (TMLIST_ITER_HASNEXT(&it, childIdListPtr)) {
+            long childId = (long)TMLIST_ITER_NEXT(&it, childIdListPtr);
+            status = PBITMAP_SET(descendantBitmapPtr, childId);
+            assert(status);
+            status = PQUEUE_PUSH(workQueuePtr, (void*)childId);
+            assert(status);
+        }
+    }
+
+    while (!PQUEUE_ISEMPTY(workQueuePtr)) {
+        long childId = (long)PQUEUE_POP(workQueuePtr);
+        nodeVectorPtr->at(childId)->childIdListPtr->acquire();
+        if (childId == id) {
+            queue_clear(workQueuePtr);
+            return FALSE;
+        }
+        net_node_t* nodePtr = nodeVectorPtr->at(childId);
+        list_t* grandChildIdListPtr = nodePtr->childIdListPtr;
+        list_iter_t it;
+        //TMLIST_ITER_RESET(&it, grandChildIdListPtr);
+        list_iter_reset(&it, grandChildIdListPtr);
+        while (list_iter_hasNext(&it, grandChildIdListPtr)) {
+            long grandChildId = (long)list_iter_next(&it, grandChildIdListPtr);
+            if (!PBITMAP_ISSET(descendantBitmapPtr, grandChildId)) {
+                status = PBITMAP_SET(descendantBitmapPtr, grandChildId);
+                assert(status);
+                status = PQUEUE_PUSH(workQueuePtr, (void*)grandChildId);
+                assert(status);
+            }
+        }
+    }
+
+    return TRUE;
+}
+
+
+/* =============================================================================
+ * net_generateRandomEdges
+ * =============================================================================
+ */
+void
+net_generateRandomEdges (net_t* netPtr,
+                         long maxNumParent,
+                         long percentParent,
+                         random_t* randomPtr)
+{
+    //vector_t* nodeVectorPtr = netPtr->nodeVectorPtr;
+    NodeVector* nodeVectorPtr = netPtr->nodeVectorPtr;
+
+    long numNode = nodeVectorPtr->size();//vector_getSize(nodeVectorPtr);
+    bitmap_t* visitedBitmapPtr = bitmap_alloc(numNode);
+    assert(visitedBitmapPtr);
+    queue_t* workQueuePtr = queue_alloc(-1);
+
+    long n;
+
+    for (n = 0; n < numNode; n++) {
+        long p;
+        for (p = 0; p < maxNumParent; p++) {
+            long value = random_generate(randomPtr) % 100;
+            if (value < percentParent) {
+                long parent = random_generate(randomPtr) % numNode;
+                if ((parent != n) &&
+                    !net_hasEdge(netPtr, parent, n) &&
+                    !net_isPath(netPtr, n, parent, visitedBitmapPtr, workQueuePtr))
+                {
+#ifdef TEST_NET
+                    printf("node=%li parent=%li\n", n, parent);
+#endif
+                    insertEdge(netPtr, parent, n);
+                }
+            }
+        }
+    }
+
+    assert(!net_isCycle(netPtr));
+
+    bitmap_free(visitedBitmapPtr);
+    queue_free(workQueuePtr);
+}
+
+
+/* #############################################################################
+ * TEST_NET
+ * #############################################################################
+ */
+#ifdef TEST_NET
+
+#include <stdio.h>
+
+
+int
+main ()
+{
+    long numNode = 100;
+
+    puts("Starting tests...");
+
+    bool_t status;
+
+    net_t* netPtr = net_alloc(numNode);
+    assert(netPtr);
+    bitmap_t* visitedBitmapPtr = bitmap_alloc(numNode);
+    assert(visitedBitmapPtr);
+    queue_t* workQueuePtr = queue_alloc(-1);
+    assert(workQueuePtr);
+
+    assert(!net_isCycle(netPtr));
+
+    long aId = 31;
+    long bId = 14;
+    long cId = 5;
+    long dId = 92;
+
+    net_applyOperation(netPtr, OPERATION_INSERT, aId, bId);
+    assert(net_isPath(netPtr, aId, bId, visitedBitmapPtr, workQueuePtr));
+    assert(!net_isPath(netPtr, bId, aId, visitedBitmapPtr, workQueuePtr));
+    assert(!net_isPath(netPtr, aId, cId, visitedBitmapPtr, workQueuePtr));
+    assert(!net_isPath(netPtr, aId, dId, visitedBitmapPtr, workQueuePtr));
+    assert(!net_isCycle(netPtr));
+
+    net_applyOperation(netPtr, OPERATION_INSERT, bId, cId);
+    net_applyOperation(netPtr, OPERATION_INSERT, aId, cId);
+    net_applyOperation(netPtr, OPERATION_INSERT, dId, aId);
+    assert(!net_isCycle(netPtr));
+    net_applyOperation(netPtr, OPERATION_INSERT, cId, dId);
+    assert(net_isCycle(netPtr));
+    net_applyOperation(netPtr, OPERATION_REVERSE, cId, dId);
+    assert(!net_isCycle(netPtr));
+    net_applyOperation(netPtr, OPERATION_REVERSE, dId, cId);
+    assert(net_isCycle(netPtr));
+    assert(net_isPath(netPtr, aId, dId, visitedBitmapPtr, workQueuePtr));
+    net_applyOperation(netPtr, OPERATION_REMOVE, cId, dId);
+    assert(!net_isPath(netPtr, aId, dId, visitedBitmapPtr, workQueuePtr));
+
+    bitmap_t* ancestorBitmapPtr = bitmap_alloc(numNode);
+    assert(ancestorBitmapPtr);
+    status = net_findAncestors(netPtr, cId, ancestorBitmapPtr, workQueuePtr);
+    assert(status);
+    assert(bitmap_isSet(ancestorBitmapPtr, aId));
+    assert(bitmap_isSet(ancestorBitmapPtr, bId));
+    assert(bitmap_isSet(ancestorBitmapPtr, dId));
+    assert(bitmap_getNumSet(ancestorBitmapPtr) == 3);
+
+    bitmap_t* descendantBitmapPtr = bitmap_alloc(numNode);
+    assert(descendantBitmapPtr);
+    status = net_findDescendants(netPtr, aId, descendantBitmapPtr, workQueuePtr);
+    assert(status);
+    assert(bitmap_isSet(descendantBitmapPtr, bId));
+    assert(bitmap_isSet(descendantBitmapPtr, cId));
+    assert(bitmap_getNumSet(descendantBitmapPtr) == 2);
+
+    bitmap_free(visitedBitmapPtr);
+    queue_free(workQueuePtr);
+    bitmap_free(ancestorBitmapPtr);
+    bitmap_free(descendantBitmapPtr);
+    net_free(netPtr);
+
+    random_t* randomPtr = random_alloc();
+    assert(randomPtr);
+    netPtr = net_alloc(numNode);
+    assert(netPtr);
+    net_generateRandomEdges(netPtr, 10, 10, randomPtr);
+    net_free(netPtr);
+
+    puts("All tests passed.");
+
+    return 0;
+}
+
+
+#endif /* TEST_NET */
+
+
+/* =============================================================================
+ *
+ * End of net.c
+ *
+ * =============================================================================
+ */
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/net.h stamp-g/bayes/net.h
--- stamp-0.9.10/bayes/net.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/bayes/net.h	2017-03-20 15:19:41.000000000 +0000
@@ -79,6 +79,10 @@
 #include "queue.h"
 #include "tm.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct net net_t;
 
 
@@ -245,11 +249,11 @@
                          random_t* randomPtr);
 
 
-#define TMNET_APPLYOPERATION(net, op, from, to)     TMnet_applyOperation(TM_ARG \
+#define TMNET_APPLYOPERATION(net, op, from, to, log)     TMnet_applyOperation(TM_ARG \
                                                                          net, \
                                                                          op, \
                                                                          from, \
-                                                                         to)
+                                                                         to, log)
 #define TMNET_HASEDGE(net, from, to)                TMnet_hasEdge(TM_ARG \
                                                                   net, \
                                                                   from, \
@@ -271,6 +275,74 @@
                                                                           bmp, \
                                                                           wq)
 
+#ifdef __cplusplus
+}
+#endif
+
+#ifdef __cplusplus
+#include <deque>
+#include "Galois/gdeque.h"
+
+#ifdef HTM
+struct NetOpLog {
+    void insert(net_t* netPtr, operation_t op, long fromId, long toId) { }
+
+    void clear() { }
+};
+#else
+struct NetOpLog: public Galois::Runtime::Releasable {
+    struct NetOp {
+        typedef int tt_has_known_trivial_constructor;
+        net_t* netPtr;
+        operation_t op;
+        long fromId;
+        long toId;
+    };
+
+    Galois::gdeque<NetOp> ops;
+
+    virtual ~NetOpLog() {
+        cleanup();
+    }
+
+    virtual void release() { cleanup(); }
+
+    void cleanup() {
+        while (!ops.empty()) {
+            NetOp& op = ops.back();
+            switch (op.op) {
+                case OPERATION_INSERT:
+                    net_applyOperation(op.netPtr, OPERATION_REMOVE, op.fromId, op.toId); 
+                    break;
+                case OPERATION_REMOVE:
+                    net_applyOperation(op.netPtr, OPERATION_INSERT, op.fromId, op.toId); 
+                    break;
+                case OPERATION_REVERSE:
+                    net_applyOperation(op.netPtr, OPERATION_REMOVE, op.toId, op.fromId); 
+                    net_applyOperation(op.netPtr, OPERATION_INSERT, op.fromId, op.toId); 
+                    break;
+                default: abort();
+            }
+            ops.pop_back();
+        }
+    }
+
+    void insert(net_t* netPtr, operation_t op, long fromId, long toId) {
+      NetOp o = { netPtr, op, fromId, toId };
+      ops.push_back(o);
+    }
+
+    void clear() {
+        ops.clear();
+    }
+};
+#endif
+
+void
+TMnet_applyOperation(net_t* netPtr, operation_t op, long fromId, long toId, NetOpLog& opLog);
+
+#endif
+
 #endif /* NET_H */
 
 
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/operation.h stamp-g/bayes/operation.h
--- stamp-0.9.10/bayes/operation.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/bayes/operation.h	2017-03-20 15:19:41.000000000 +0000
@@ -72,6 +72,10 @@
 #ifndef OPERATION_H
 #define OPERATION_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 /*
  * All operations are performed from:other to:this
  */
@@ -83,6 +87,9 @@
     NUM_OPERATION
 } operation_t;
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* OPERATION_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/query.h stamp-g/bayes/query.h
--- stamp-0.9.10/bayes/query.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/bayes/query.h	2017-03-20 15:19:41.000000000 +0000
@@ -72,6 +72,9 @@
 #ifndef QUERY_H
 #define QUERY_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 #define QUERY_VALUE_WILDCARD (-1L)
 
@@ -80,6 +83,9 @@
     long value;
 } query_t;
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* QUERY_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/sort.h stamp-g/bayes/sort.h
--- stamp-0.9.10/bayes/sort.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/bayes/sort.h	2017-03-20 15:19:41.000000000 +0000
@@ -103,6 +103,9 @@
 #ifndef SORT_H
 #define SORT_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 /* =============================================================================
  * sort
@@ -116,6 +119,9 @@
       long n,
       long offset);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* SORT_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/genome/CMakeLists.txt stamp-g/genome/CMakeLists.txt
--- stamp-0.9.10/genome/CMakeLists.txt	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/genome/CMakeLists.txt	2017-03-20 15:19:41.000000000 +0000
@@ -4,23 +4,27 @@
 #
 # ==============================================================================
 
-add_definitions(-DLIST_NO_DUPLICATES -DCHUNK_STEP1=12)
+#add_definitions(-DLIST_NO_DUPLICATES -DCHUNK_STEP1=12)
+add_definitions(-DCHUNK_STEP1=12 -DUSE_HASH_LIST_MAP)
 
 set(sources
 	gene.c 
 	genome.c 
 	segments.c 
-	sequencer.c 
-	table.c 
-	${LIB_DIR}/bitmap.c 
-	${LIB_DIR}/hash.c 
-	${LIB_DIR}/hashtable.c 
-	${LIB_DIR}/pair.c 
+	sequencer.cpp 
+        #table.c 
+        ${LIB_DIR}/bitmap.c 
+        ${LIB_DIR}/hash.c 
+        #${LIB_DIR}/hashtable.c 
+        #${LIB_DIR}/pair.c 
+        ${LIB_DIR}/deque.cpp
+        ${LIB_DIR}/map.cpp
 	${LIB_DIR}/random.c 
-	${LIB_DIR}/list.c 
+        #${LIB_DIR}/list.c 
 	${LIB_DIR}/mt19937ar.c 
-	${LIB_DIR}/thread.c 
-	${LIB_DIR}/vector.c)
+        ${LIB_DIR}/thread.cpp
+        #${LIB_DIR}/vector.c
+        )
 
 app(genome ${sources})
 
diff -x .git -x inputs -Naur stamp-0.9.10/genome/gene.h stamp-g/genome/gene.h
--- stamp-0.9.10/genome/gene.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/genome/gene.h	2017-03-20 15:19:41.000000000 +0000
@@ -77,6 +77,9 @@
 #include "bitmap.h"
 #include "random.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef struct gene {
     long length;
@@ -111,6 +114,9 @@
 void
 gene_free (gene_t* genePtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* GENE_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/genome/genome.c stamp-g/genome/genome.c
--- stamp-0.9.10/genome/genome.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/genome/genome.c	2017-03-20 15:19:41.000000000 +0000
@@ -220,29 +220,34 @@
     puts("done.");
     printf("Gene length     = %li\n", genePtr->length);
     printf("Segment length  = %li\n", segmentsPtr->length);
-    printf("Number segments = %li\n", vector_getSize(segmentsPtr->contentsPtr));
+    {
+      list_iter_t it;
+      list_iter_reset(&it, segmentsPtr->contentsPtr);
+      long numSegments = 0;
+      while (list_iter_hasNext(&it, segmentsPtr->contentsPtr)) {
+        numSegments += 1;
+        list_iter_next(&it, segmentsPtr->contentsPtr);
+      }
+      //printf("Number segments = %li\n", vector_getSize(segmentsPtr->contentsPtr));
+      printf("Number segments = %li\n", numSegments);
+    }
     fflush(stdout);
 
     /* Benchmark */
     printf("Sequencing gene... ");
     fflush(stdout);
-    TIMER_READ(start);
+
     GOTO_SIM();
     thread_begin_timing();
-#ifdef OTM
-#pragma omp parallel
-    {
-        sequencer_run(sequencerPtr);
-    }
-#else
-    thread_start(sequencer_run, (void*)sequencerPtr);
-#endif
+    TIMER_READ(start);
+    
+    sequencer_run(sequencerPtr);
+
+    TIMER_READ(stop);
     thread_end_timing();
     GOTO_REAL();
-    TIMER_READ(stop);
     puts("done.");
     printf("Time = %lf\n", TIMER_DIFF_SECONDS(start, stop));
-    printf("STAMP time = %lf\n", TIMER_DIFF_SECONDS(start, stop));
     fflush(stdout);
 
     /* Check result */
diff -x .git -x inputs -Naur stamp-0.9.10/genome/nucleotide.h stamp-g/genome/nucleotide.h
--- stamp-0.9.10/genome/nucleotide.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/genome/nucleotide.h	2017-03-20 15:19:41.000000000 +0000
@@ -72,6 +72,9 @@
 #ifndef NUCLEOTIDE_H
 #define NUCLEOTIDE_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef enum nucleotide_type {
     NUCLEOTIDE_ADENINE  = 'a',
@@ -81,6 +84,9 @@
     NUCLEOTIDE_NUM_TYPE = 4
 } nucleotide_type_t;
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* NUCLEOTIDE_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/genome/segments.c stamp-g/genome/segments.c
--- stamp-0.9.10/genome/segments.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/genome/segments.c	2017-03-20 15:19:41.000000000 +0000
@@ -212,7 +212,17 @@
 void
 segments_free (segments_t* segmentsPtr)
 {
-    free(vector_at(segmentsPtr->contentsPtr, 0));
+    //free(vector_at(segmentsPtr->contentsPtr, 0));
+    {
+      list_iter_t it;
+      list_iter_reset(&it, segmentsPtr->contentsPtr);
+      while (list_iter_hasNext(&it, segmentsPtr->contentsPtr)) {
+        void * ptr = list_iter_next(&it, segmentsPtr->contentsPtr);
+        free(ptr);
+        break;
+      }
+    }
+    
     vector_free(segmentsPtr->contentsPtr);
     free(segmentsPtr->strings);
     free(segmentsPtr);
@@ -253,24 +263,28 @@
     segments_create(segmentsPtr, genePtr, randomPtr);
 
     assert(segmentsPtr->minNum == minNumSegment);
-    assert(vector_getSize(segmentsPtr->contentsPtr) >= minNumSegment);
 
     if (doPrint) {
         printf("Gene = %s\n", genePtr->contents);
     }
 
+
     /* Check that each segment occurs in gene */
-    for (i = 0; i < vector_getSize(segmentsPtr->contentsPtr); i++) {
-        char *charPtr = strstr(genePtr->contents,
-                               (char*)vector_at(segmentsPtr->contentsPtr, i));
+    list_iter_it it;
+    list_iter_reset(&it, segmentsPtr->contentsPtr);
+    for (i = 0; list_iter_hasNext(&it, segmentsPtr->contentsPtr); i++) {
+        char* content = (char*) list_iter_next(&it, segmentsPtr->contentsPtr);
+        char *charPtr = strstr(genePtr->contents, content);
+
         assert(charPtr != NULL);
         j = charPtr - genePtr->contents;
         bitmap_set(startBitmapPtr, j);
         if (doPrint) {
             printf("Segment %li (@%li) = %s\n",
-                   i, j, (char*)vector_at(segmentsPtr->contentsPtr, i));
+                   i, j, content);
         }
     }
+    assert(i >= minNumSegment);
 
     /* Check that there is complete overlap */
     assert(bitmap_isSet(startBitmapPtr, 0));
diff -x .git -x inputs -Naur stamp-0.9.10/genome/segments.h stamp-g/genome/segments.h
--- stamp-0.9.10/genome/segments.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/genome/segments.h	2017-03-20 15:19:41.000000000 +0000
@@ -78,6 +78,9 @@
 #include "random.h"
 #include "vector.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef struct segments {
     long length;
@@ -116,6 +119,9 @@
 void
 segments_free (segments_t* segmentsPtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* SEGMENTS_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/genome/sequencer.c stamp-g/genome/sequencer.c
--- stamp-0.9.10/genome/sequencer.c	2017-03-21 17:41:16.000000000 +0000
+++ stamp-g/genome/sequencer.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,948 +0,0 @@
-/* =============================================================================
- *
- * sequencer.c
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * Algorithm overview:
- *
- * 1) Remove duplicate segments by using hash-set
- * 2) Match segments using hash-based comparisons
- *    - Cycles are prevented by tracking starts/ends of matched chains
- * 3) Build sequence
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include "tm.h"
-
-#include <assert.h>
-#include <stdlib.h>
-#include <string.h>
-#include "hash.h"
-#include "hashtable.h"
-#include "segments.h"
-#include "sequencer.h"
-#include "table.h"
-#include "thread.h"
-#include "utility.h"
-#include "vector.h"
-#include "types.h"
-
-
-struct endInfoEntry {
-    bool_t isEnd;
-    long jumpToNext;
-};
-
-struct constructEntry {
-    XTM_DECL_LOCKABLE(bool_t, isStart);
-    XTM_DECL_LOCKABLE(char*, segment);
-    ulong_t endHash;
-    XTM_DECL_LOCKABLE(struct constructEntry*, startPtr);
-    struct constructEntry* nextPtr;
-    XTM_DECL_LOCKABLE(struct constructEntry*, endPtr);
-    XTM_DECL_LOCKABLE(long, overlap);
-    XTM_DECL_LOCKABLE(long, length);
-};
-
-
-/* =============================================================================
- * hashString
- * -- uses sdbm hash function
- * =============================================================================
- */
-static ulong_t
-hashString (char* str)
-{
-    ulong_t hash = 0;
-    long c;
-
-    /* Note: Do not change this hashing scheme */
-    while ((c = *str++) != '\0') {
-        hash = c + (hash << 6) + (hash << 16) - hash;
-    }
-
-    return (ulong_t)hash;
-}
-
-
-/* =============================================================================
- * hashSegment
- * -- For hashtable
- * =============================================================================
- */
-static ulong_t
-hashSegment (const void* keyPtr)
-{
-    return (ulong_t)hash_sdbm((char*)keyPtr); /* can be any "good" hash function */
-}
-
-
-/* =============================================================================
- * compareSegment
- * -- For hashtable
- * =============================================================================
- */
-static long
-compareSegment (const pair_t* a, const pair_t* b)
-{
-    return strcmp((char*)(a->firstPtr), (char*)(b->firstPtr));
-}
-
-
-/* =============================================================================
- * sequencer_alloc
- * -- Returns NULL on failure
- * =============================================================================
- */
-sequencer_t*
-sequencer_alloc (long geneLength, long segmentLength, segments_t* segmentsPtr)
-{
-    sequencer_t* sequencerPtr;
-    long maxNumUniqueSegment = geneLength - segmentLength + 1;
-    long i;
-
-    sequencerPtr = (sequencer_t*)malloc(sizeof(sequencer_t));
-    if (sequencerPtr == NULL) {
-        return NULL;
-    }
-
-    sequencerPtr->uniqueSegmentsPtr =
-        hashtable_alloc(geneLength, &hashSegment, &compareSegment, -1, -1);
-    if (sequencerPtr->uniqueSegmentsPtr == NULL) {
-        return NULL;
-    }
-
-    /* For finding a matching entry */
-    sequencerPtr->endInfoEntries =
-        (endInfoEntry_t*)malloc(maxNumUniqueSegment * sizeof(endInfoEntry_t));
-    for (i = 0; i < maxNumUniqueSegment; i++) {
-        endInfoEntry_t* endInfoEntryPtr = &sequencerPtr->endInfoEntries[i];
-        endInfoEntryPtr->isEnd = TRUE;
-        endInfoEntryPtr->jumpToNext = 1;
-    }
-    sequencerPtr->startHashToConstructEntryTables =
-        (table_t**)malloc(segmentLength * sizeof(table_t*));
-    if (sequencerPtr->startHashToConstructEntryTables == NULL) {
-        return NULL;
-    }
-    for (i = 1; i < segmentLength; i++) { /* 0 is dummy entry */
-        sequencerPtr->startHashToConstructEntryTables[i] =
-            table_alloc(geneLength, NULL);
-        if (sequencerPtr->startHashToConstructEntryTables[i] == NULL) {
-            return NULL;
-        }
-    }
-    sequencerPtr->segmentLength = segmentLength;
-
-    /* For constructing sequence */
-    sequencerPtr->constructEntries =
-        (constructEntry_t*)malloc(maxNumUniqueSegment * sizeof(constructEntry_t));
-    if (sequencerPtr->constructEntries == NULL) {
-        return NULL;
-    }
-    for (i= 0; i < maxNumUniqueSegment; i++) {
-        constructEntry_t* constructEntryPtr = &sequencerPtr->constructEntries[i];
-        XTM_LOCKABLE_VALUE(constructEntryPtr->isStart) = TRUE;
-        XTM_LOCKABLE_INIT(constructEntryPtr->isStart);
-        XTM_LOCKABLE_VALUE(constructEntryPtr->segment) = NULL;
-        XTM_LOCKABLE_INIT(constructEntryPtr->segment);
-        constructEntryPtr->endHash = 0;
-        XTM_LOCKABLE_VALUE(constructEntryPtr->startPtr) = constructEntryPtr;
-        XTM_LOCKABLE_INIT(constructEntryPtr->startPtr);
-        constructEntryPtr->nextPtr = NULL;
-        XTM_LOCKABLE_VALUE(constructEntryPtr->endPtr) = constructEntryPtr;
-        XTM_LOCKABLE_INIT(constructEntryPtr->endPtr);
-        XTM_LOCKABLE_VALUE(constructEntryPtr->overlap) = 0;
-        XTM_LOCKABLE_INIT(constructEntryPtr->overlap);
-        XTM_LOCKABLE_VALUE(constructEntryPtr->length) = segmentLength;
-        XTM_LOCKABLE_INIT(constructEntryPtr->length);
-    }
-    sequencerPtr->hashToConstructEntryTable = table_alloc(geneLength, NULL);
-    if (sequencerPtr->hashToConstructEntryTable == NULL) {
-        return NULL;
-    }
-
-    sequencerPtr->segmentsPtr = segmentsPtr;
-
-    return sequencerPtr;
-}
-
-
-/* =============================================================================
- * sequencer_run
- * =============================================================================
- */
-void
-sequencer_run (void* argPtr)
-{
-    TM_THREAD_ENTER();
-
-    long threadId = thread_getId();
-
-    sequencer_t* sequencerPtr = (sequencer_t*)argPtr;
-
-    hashtable_t*      uniqueSegmentsPtr;
-    endInfoEntry_t*   endInfoEntries;
-    table_t**         startHashToConstructEntryTables;
-    constructEntry_t* constructEntries;
-    table_t*          hashToConstructEntryTable;
-
-    uniqueSegmentsPtr               = sequencerPtr->uniqueSegmentsPtr;
-    endInfoEntries                  = sequencerPtr->endInfoEntries;
-    startHashToConstructEntryTables = sequencerPtr->startHashToConstructEntryTables;
-    constructEntries                = sequencerPtr->constructEntries;
-    hashToConstructEntryTable       = sequencerPtr->hashToConstructEntryTable;
-
-    segments_t* segmentsPtr         = sequencerPtr->segmentsPtr;
-    assert(segmentsPtr);
-    vector_t*   segmentsContentsPtr = segmentsPtr->contentsPtr;
-    long        numSegment          = vector_getSize(segmentsContentsPtr);
-    long        segmentLength       = segmentsPtr->length;
-
-    long i;
-    long j;
-    long i_start;
-    long i_stop;
-    long numUniqueSegment;
-    long substringLength;
-    long entryIndex;
-
-    /*
-     * Step 1: Remove duplicate segments
-     */
-#if defined(HTM) || defined(STM)
-    long numThread = thread_getNumThread();
-    {
-        /* Choose disjoint segments [i_start,i_stop) for each thread */
-        long partitionSize = (numSegment + numThread/2) / numThread; /* with rounding */
-        i_start = threadId * partitionSize;
-        if (threadId == (numThread - 1)) {
-            i_stop = numSegment;
-        } else {
-            i_stop = i_start + partitionSize;
-        }
-    }
-#else /* !(HTM || STM) */
-    i_start = 0;
-    i_stop = numSegment;
-#endif /* !(HTM || STM) */
-    for (i = i_start; i < i_stop; i+=CHUNK_STEP1) {
-        TM_BEGIN();
-        {
-            long ii;
-            long ii_stop = MIN(i_stop, (i+CHUNK_STEP1));
-            for (ii = i; ii < ii_stop; ii++) {
-                void* segment = vector_at(segmentsContentsPtr, ii);
-                TMHASHTABLE_INSERT(uniqueSegmentsPtr,
-                                   segment,
-                                   segment);
-            } /* ii */
-        }
-        TM_END();
-    }
-
-    thread_barrier_wait();
-
-    /*
-     * Step 2a: Iterate over unique segments and compute hashes.
-     *
-     * For the gene "atcg", the hashes for the end would be:
-     *
-     *     "t", "tc", and "tcg"
-     *
-     * And for the gene "tcgg", the hashes for the start would be:
-     *
-     *    "t", "tc", and "tcg"
-     *
-     * The names are "end" and "start" because if a matching pair is found,
-     * they are the substring of the end part of the pair and the start
-     * part of the pair respectively. In the above example, "tcg" is the
-     * matching substring so:
-     *
-     *     (end)    (start)
-     *     a[tcg] + [tcg]g  = a[tcg]g    (overlap = "tcg")
-     */
-
-    /* uniqueSegmentsPtr is constant now */
-    numUniqueSegment = hashtable_getSize(uniqueSegmentsPtr);
-    entryIndex = 0;
-
-#if defined(HTM) || defined(STM)
-    {
-        /* Choose disjoint segments [i_start,i_stop) for each thread */
-        long num = uniqueSegmentsPtr->numBucket;
-        long partitionSize = (num + numThread/2) / numThread; /* with rounding */
-        i_start = threadId * partitionSize;
-        if (threadId == (numThread - 1)) {
-            i_stop = num;
-        } else {
-            i_stop = i_start + partitionSize;
-        }
-    }
-    {
-        /* Approximate disjoint segments of element allocation in constructEntries */
-        long partitionSize = (numUniqueSegment + numThread/2) / numThread; /* with rounding */
-        entryIndex = threadId * partitionSize;
-    }
-#else /* !(HTM || STM) */
-    i_start = 0;
-    i_stop = uniqueSegmentsPtr->numBucket;
-    entryIndex = 0;
-#endif /* !(HTM || STM) */
-
-    for (i = i_start; i < i_stop; i++) {
-
-        list_t* chainPtr = uniqueSegmentsPtr->buckets[i];
-        list_iter_t it;
-        list_iter_reset(&it, chainPtr);
-
-        while (list_iter_hasNext(&it, chainPtr)) {
-
-            char* segment =
-                (char*)((pair_t*)list_iter_next(&it, chainPtr))->firstPtr;
-            constructEntry_t* constructEntryPtr;
-            long j;
-            ulong_t startHash;
-            bool_t status;
-
-            /* Find an empty constructEntries entry */
-            TM_BEGIN();
-            while (((void*)TM_SHARED_READ_P(constructEntries[entryIndex].segment)) != NULL) {
-                entryIndex = (entryIndex + 1) % numUniqueSegment; /* look for empty */
-            }
-            constructEntryPtr = &constructEntries[entryIndex];
-            TM_SHARED_WRITE_P(constructEntryPtr->segment, segment);
-            TM_END();
-            entryIndex = (entryIndex + 1) % numUniqueSegment;
-
-            /*
-             * Save hashes (sdbm algorithm) of segment substrings
-             *
-             * endHashes will be computed for shorter substrings after matches
-             * have been made (in the next phase of the code). This will reduce
-             * the number of substrings for which hashes need to be computed.
-             *
-             * Since we can compute startHashes incrementally, we go ahead
-             * and compute all of them here.
-             */
-            /* constructEntryPtr is local now */
-            constructEntryPtr->endHash = (ulong_t)hashString(&segment[1]);
-
-            startHash = 0;
-            for (j = 1; j < segmentLength; j++) {
-                startHash = (ulong_t)segment[j-1] +
-                            (startHash << 6) + (startHash << 16) - startHash;
-                TM_BEGIN();
-                status = TMTABLE_INSERT(startHashToConstructEntryTables[j],
-                                        (ulong_t)startHash,
-                                        (void*)constructEntryPtr );
-                TM_END();
-                assert(status);
-            }
-
-            /*
-             * For looking up construct entries quickly
-             */
-            startHash = (ulong_t)segment[j-1] +
-                        (startHash << 6) + (startHash << 16) - startHash;
-            TM_BEGIN();
-            status = TMTABLE_INSERT(hashToConstructEntryTable,
-                                    (ulong_t)startHash,
-                                    (void*)constructEntryPtr);
-            TM_END();
-            assert(status);
-        }
-    }
-
-    thread_barrier_wait();
-
-    /*
-     * Step 2b: Match ends to starts by using hash-based string comparison.
-     */
-    for (substringLength = segmentLength-1; substringLength > 0; substringLength--) {
-
-        table_t* startHashToConstructEntryTablePtr =
-            startHashToConstructEntryTables[substringLength];
-        list_t** buckets = startHashToConstructEntryTablePtr->buckets;
-        long numBucket = startHashToConstructEntryTablePtr->numBucket;
-
-        long index_start;
-        long index_stop;
-
-#if defined(HTM) || defined(STM)
-        {
-            /* Choose disjoint segments [index_start,index_stop) for each thread */
-            long partitionSize = (numUniqueSegment + numThread/2) / numThread; /* with rounding */
-            index_start = threadId * partitionSize;
-            if (threadId == (numThread - 1)) {
-                index_stop = numUniqueSegment;
-            } else {
-                index_stop = index_start + partitionSize;
-            }
-        }
-#else /* !(HTM || STM) */
-        index_start = 0;
-        index_stop = numUniqueSegment;
-#endif /* !(HTM || STM) */
-
-        /* Iterating over disjoint itervals in the range [0, numUniqueSegment) */
-        for (entryIndex = index_start;
-             entryIndex < index_stop;
-             entryIndex += endInfoEntries[entryIndex].jumpToNext)
-        {
-            if (!endInfoEntries[entryIndex].isEnd) {
-                continue;
-            }
-
-            /*  ConstructEntries[entryIndex] is local data */
-            constructEntry_t* endConstructEntryPtr =
-                &constructEntries[entryIndex];
-            char* endSegment = XTM_LOCKABLE_VALUE(endConstructEntryPtr->segment);
-            ulong_t endHash = endConstructEntryPtr->endHash;
-
-            list_t* chainPtr = buckets[endHash % numBucket]; /* buckets: constant data */
-            list_iter_t it;
-            list_iter_reset(&it, chainPtr);
-
-            /* Linked list at chainPtr is constant */
-            while (list_iter_hasNext(&it, chainPtr)) {
-
-                constructEntry_t* startConstructEntryPtr =
-                    (constructEntry_t*)list_iter_next(&it, chainPtr);
-                char* startSegment = XTM_LOCKABLE_VALUE(startConstructEntryPtr->segment);
-                long newLength = 0;
-
-                /* endConstructEntryPtr is local except for properties startPtr/endPtr/length */
-                TM_BEGIN();
-
-                /* Check if matches */
-                if (TM_SHARED_READ(startConstructEntryPtr->isStart) &&
-                    (TM_SHARED_READ_P(endConstructEntryPtr->startPtr) != startConstructEntryPtr) &&
-                    (strncmp(startSegment,
-                             &endSegment[segmentLength - substringLength],
-                             substringLength) == 0))
-                {
-                    TM_SHARED_WRITE(startConstructEntryPtr->isStart, FALSE);
-
-                    constructEntry_t* startConstructEntry_endPtr;
-                    constructEntry_t* endConstructEntry_startPtr;
-
-                    /* Update endInfo (appended something so no longer end) */
-                    TM_LOCAL_WRITE(endInfoEntries[entryIndex].isEnd, FALSE);
-
-                    /* Update segment chain construct info */
-                    startConstructEntry_endPtr =
-                        (constructEntry_t*)TM_SHARED_READ_P(startConstructEntryPtr->endPtr);
-                    endConstructEntry_startPtr =
-                        (constructEntry_t*)TM_SHARED_READ_P(endConstructEntryPtr->startPtr);
-
-                    assert(startConstructEntry_endPtr);
-                    assert(endConstructEntry_startPtr);
-                    TM_SHARED_WRITE_P(startConstructEntry_endPtr->startPtr,
-                                      endConstructEntry_startPtr);
-                    TM_LOCAL_WRITE_P(endConstructEntryPtr->nextPtr,
-                                     startConstructEntryPtr);
-                    TM_SHARED_WRITE_P(endConstructEntry_startPtr->endPtr,
-                                      startConstructEntry_endPtr);
-                    TM_SHARED_WRITE(endConstructEntryPtr->overlap, substringLength);
-                    newLength = (long)TM_SHARED_READ(endConstructEntry_startPtr->length) +
-                                (long)TM_SHARED_READ(startConstructEntryPtr->length) -
-                                substringLength;
-                    TM_SHARED_WRITE(endConstructEntry_startPtr->length, newLength);
-                } /* if (matched) */
-
-                TM_END();
-
-                if (!endInfoEntries[entryIndex].isEnd) { /* if there was a match */
-                    break;
-                }
-            } /* iterate over chain */
-
-        } /* for (endIndex < numUniqueSegment) */
-
-        thread_barrier_wait();
-
-        /*
-         * Step 2c: Update jump values and hashes
-         *
-         * endHash entries of all remaining ends are updated to the next
-         * substringLength. Additionally jumpToNext entries are updated such
-         * that they allow to skip non-end entries. Currently this is sequential
-         * because parallelization did not perform better.
-.        */
-
-        if (threadId == 0) {
-            if (substringLength > 1) {
-                long index = segmentLength - substringLength + 1;
-                /* initialization if j and i: with i being the next end after j=0 */
-                for (i = 1; !endInfoEntries[i].isEnd; i+=endInfoEntries[i].jumpToNext) {
-                    /* find first non-null */
-                }
-                /* entry 0 is handled seperately from the loop below */
-                endInfoEntries[0].jumpToNext = i;
-                if (endInfoEntries[0].isEnd) {
-                    constructEntry_t* constructEntryPtr = &constructEntries[0];
-                    char* segment = XTM_LOCKABLE_VALUE(constructEntryPtr->segment);
-                    constructEntryPtr->endHash = (ulong_t)hashString(&segment[index]);
-                }
-                /* Continue scanning (do not reset i) */
-                for (j = 0; i < numUniqueSegment; i+=endInfoEntries[i].jumpToNext) {
-                    if (endInfoEntries[i].isEnd) {
-                        constructEntry_t* constructEntryPtr = &constructEntries[i];
-                        char* segment = XTM_LOCKABLE_VALUE(constructEntryPtr->segment);
-                        constructEntryPtr->endHash = (ulong_t)hashString(&segment[index]);
-                        endInfoEntries[j].jumpToNext = MAX(1, (i - j));
-                        j = i;
-                    }
-                }
-                endInfoEntries[j].jumpToNext = i - j;
-            }
-        }
-
-        thread_barrier_wait();
-
-    } /* for (substringLength > 0) */
-
-
-    thread_barrier_wait();
-
-    /*
-     * Step 3: Build sequence string
-     */
-    if (threadId == 0) {
-
-        long totalLength = 0;
-
-        for (i = 0; i < numUniqueSegment; i++) {
-            constructEntry_t* constructEntryPtr = &constructEntries[i];
-            if (XTM_LOCKABLE_VALUE(constructEntryPtr->isStart)) {
-              totalLength += XTM_LOCKABLE_VALUE(constructEntryPtr->length);
-            }
-        }
-
-        sequencerPtr->sequence = (char*)P_MALLOC((totalLength+1) * sizeof(char));
-        char* sequence = sequencerPtr->sequence;
-        assert(sequence);
-
-        char* copyPtr = sequence;
-        long sequenceLength = 0;
-
-        for (i = 0; i < numUniqueSegment; i++) {
-            constructEntry_t* constructEntryPtr = &constructEntries[i];
-            /* If there are several start segments, we append in arbitrary order  */
-            if (XTM_LOCKABLE_VALUE(constructEntryPtr->isStart)) {
-                long newSequenceLength = sequenceLength + XTM_LOCKABLE_VALUE(constructEntryPtr->length);
-                assert( newSequenceLength <= totalLength );
-                copyPtr = sequence + sequenceLength;
-                sequenceLength = newSequenceLength;
-                do {
-                    long numChar = segmentLength - XTM_LOCKABLE_VALUE(constructEntryPtr->overlap);
-                    if ((copyPtr + numChar) > (sequence + newSequenceLength)) {
-                        TM_PRINT0("ERROR: sequence length != actual length\n");
-                        break;
-                    }
-                    memcpy(copyPtr,
-                           XTM_LOCKABLE_VALUE(constructEntryPtr->segment),
-                           (numChar * sizeof(char)));
-                    copyPtr += numChar;
-                } while ((constructEntryPtr = constructEntryPtr->nextPtr) != NULL);
-                assert(copyPtr <= (sequence + sequenceLength));
-            }
-        }
-
-        assert(sequence != NULL);
-        sequence[sequenceLength] = '\0';
-    }
-
-    TM_THREAD_EXIT();
-}
-
-
-/* =============================================================================
- * sequencer_free
- * =============================================================================
- */
-void
-sequencer_free (sequencer_t* sequencerPtr)
-{
-    long i;
-
-    table_free(sequencerPtr->hashToConstructEntryTable);
-    free(sequencerPtr->constructEntries);
-    for (i = 1; i < sequencerPtr->segmentLength; i++) {
-        table_free(sequencerPtr->startHashToConstructEntryTables[i]);
-    }
-    free(sequencerPtr->startHashToConstructEntryTables);
-    free(sequencerPtr->endInfoEntries);
-#if 0
-    /* TODO: fix mixed sequential/parallel allocation */
-    hashtable_free(sequencerPtr->uniqueSegmentsPtr);
-    if (sequencerPtr->sequence != NULL) {
-        free(sequencerPtr->sequence);
-    }
-#endif
-    free(sequencerPtr);
-}
-
-
-/* =============================================================================
- * TEST_SEQUENCER
- * =============================================================================
- */
-#ifdef TEST_SEQUENCER
-
-
-#include <assert.h>
-#include <stdio.h>
-#include "segments.h"
-
-
-char* gene1 = "gatcggcagc";
-char* segments1[] = {
-    "atcg",
-    "gcag",
-    "tcgg",
-    "cagc",
-    "gatc",
-    NULL
-};
-
-char* gene2 = "aaagc";
-char* segments2[] = {
-    "aaa",
-    "aag",
-    "agc",
-    NULL
-};
-
-char* gene3 = "aaacaaagaaat";
-char* segments3[] = {
-    "aaac",
-    "aaag",
-    "aaat",
-    NULL
-};
-
-char* gene4 = "ttggctacgtatcgcacggt";
-char* segments4[] = {
-    "cgtatcgc",
-    "tcgcacgg",
-    "gtatcgca",
-    "tatcgcac",
-    "atcgcacg",
-    "ttggctac",
-    "ctacgtat",
-    "acgtatcg",
-    "ctacgtat",
-    "cgtatcgc",
-    "atcgcacg",
-    "ggctacgt",
-    "tacgtatc",
-    "tcgcacgg",
-    "ttggctac",
-    "ggctacgt",
-    "atcgcacg",
-    "tatcgcac",
-    "cgtatcgc",
-    "acgtatcg",
-    "gtatcgca",
-    "gtatcgca",
-    "cgcacggt",
-    "tatcgcac",
-    "ttggctac",
-    "atcgcacg",
-    "acgtatcg",
-    "gtatcgca",
-    "ttggctac",
-    "tggctacg",
-    NULL
-};
-
-char* gene5 = "gatcggcagctggtacggcg";
-char* segments5[] = {
-    "atcggcag",
-    "gtacggcg",
-    "gatcggca",
-    "cagctggt",
-    "tggtacgg",
-    "gatcggca",
-    "gatcggca",
-    "tcggcagc",
-    "ggtacggc",
-    "tggtacgg",
-    "tcggcagc",
-    "gcagctgg",
-    "gatcggca",
-    "gctggtac",
-    "gatcggca",
-    "ctggtacg",
-    "ggcagctg",
-    "tcggcagc",
-    "gtacggcg",
-    "gcagctgg",
-    "ggcagctg",
-    "tcggcagc",
-    "cagctggt",
-    "tggtacgg",
-    "cagctggt",
-    "gcagctgg",
-    "gctggtac",
-    "cggcagct",
-    "agctggta",
-    "ctggtacg",
-    NULL
-};
-
-char* gene6 = "ttggtgagccgtaagactcc";
-char* segments6[] = {
-    "cgtaagac",
-    "taagactc",
-    "gtgagccg",
-    "gagccgta",
-    "gccgtaag",
-    "tgagccgt",
-    "gccgtaag",
-    "cgtaagac",
-    "ttggtgag",
-    "agccgtaa",
-    "gccgtaag",
-    "aagactcc",
-    "ggtgagcc",
-    "ttggtgag",
-    "agccgtaa",
-    "gagccgta",
-    "aagactcc",
-    "ttggtgag",
-    "gtaagact",
-    "ccgtaaga",
-    "ttggtgag",
-    "gagccgta",
-    "ggtgagcc",
-    "gagccgta",
-    "gccgtaag",
-    "aagactcc",
-    "gtaagact",
-    "ccgtaaga",
-    "tgagccgt",
-    "ttggtgag",
-    NULL
-};
-
-char* gene7 = "gatcggcagctggtacggcg";
-char* segments7[] = {
-    "atcggcag",
-    "gtacggcg",
-    "gatcggca",
-    "cagctggt",
-    "tggtacgg",
-    "gatcggca",
-    "gatcggca",
-    "tcggcagc",
-    "ggtacggc",
-    "tggtacgg",
-    "tcggcagc",
-    "gcagctgg",
-    "gatcggca",
-    "gctggtac",
-    "gatcggca",
-    "ctggtacg",
-    "ggcagctg",
-    "tcggcagc",
-    "gtacggcg",
-    "gcagctgg",
-    "ggcagctg",
-    "tcggcagc",
-    "cagctggt",
-    "tggtacgg",
-    "cagctggt",
-    "gcagctgg",
-    "gctggtac",
-    "cggcagct",
-    "agctggta",
-    "ctggtacg",
-    NULL
-};
-
-char* gene8 = "ttggtgagccgtaagactcc";
-char* segments8[] = {
-    "cgtaagac",
-    "taagactc",
-    "gtgagccg",
-    "gagccgta",
-    "gccgtaag",
-    "tgagccgt",
-    "gccgtaag",
-    "cgtaagac",
-    "ttggtgag",
-    "agccgtaa",
-    "gccgtaag",
-    "aagactcc",
-    "ggtgagcc",
-    "ttggtgag",
-    "agccgtaa",
-    "gagccgta",
-    "aagactcc",
-    "ttggtgag",
-    "gtaagact",
-    "ccgtaaga",
-    "ttggtgag",
-    "gagccgta",
-    "ggtgagcc",
-    "gagccgta",
-    "gccgtaag",
-    "aagactcc",
-    "gtaagact",
-    "ccgtaaga",
-    "tgagccgt",
-    "ttggtgag",
-    NULL
-};
-
-
-static segments_t*
-createSegments (char* segments[])
-{
-    long i = 0;
-    segments_t* segmentsPtr = (segments_t*)malloc(sizeof(segments));
-
-    segmentsPtr->length = strlen(segments[0]);
-    segmentsPtr->contentsPtr = vector_alloc(1);
-
-    while (segments[i] != NULL) {
-        bool_t status = vector_pushBack(segmentsPtr->contentsPtr,
-                                        (void*)segments[i]);
-        assert(status);
-        i++;
-    }
-
-    segmentsPtr->minNum = vector_getSize(segmentsPtr->contentsPtr);
-
-    return segmentsPtr;
-}
-
-
-static void
-tester (char* gene, char* segments[])
-{
-    segments_t* segmentsPtr;
-    sequencer_t* sequencerPtr;
-
-    segmentsPtr = createSegments(segments);
-    sequencerPtr = sequencer_alloc(strlen(gene), segmentsPtr->length, segmentsPtr);
-
-    sequencer_run((void*)sequencerPtr);
-
-    printf("gene     = %s\n", gene);
-    printf("sequence = %s\n", sequencerPtr->sequence);
-    assert(strcmp(sequencerPtr->sequence, gene) == 0);
-
-    sequencer_free(sequencerPtr);
-}
-
-
-int
-main ()
-{
-    bool_t status = memory_init(1, 4, 2);
-    assert(status);
-    thread_startup(1);
-
-    puts("Starting...");
-
-    /* Simple test */
-    tester(gene1, segments1);
-
-    /* Simple test with aliasing segments */
-    tester(gene2, segments2);
-
-    /* Simple test with non-overlapping segments */
-    tester(gene3, segments3);
-
-    /* Complex tests */
-    tester(gene4, segments4);
-    tester(gene5, segments5);
-    tester(gene6, segments6);
-    tester(gene7, segments7);
-    tester(gene8, segments8);
-
-    puts("Passed all tests.");
-
-    return 0;
-}
-
-
-#endif /* TEST_SEQUENCER */
-
-
-/* =============================================================================
- *
- * End of sequencer.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/genome/sequencer.cpp stamp-g/genome/sequencer.cpp
--- stamp-0.9.10/genome/sequencer.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-g/genome/sequencer.cpp	2017-03-20 15:19:41.000000000 +0000
@@ -0,0 +1,1165 @@
+/* =============================================================================
+ *
+ * sequencer.c
+ *
+ * =============================================================================
+ *
+ * Copyright (C) Stanford University, 2006.  All Rights Reserved.
+ * Author: Chi Cao Minh
+ *
+ * =============================================================================
+ *
+ * Algorithm overview:
+ *
+ * 1) Remove duplicate segments by using hash-set
+ * 2) Match segments using hash-based comparisons
+ *    - Cycles are prevented by tracking starts/ends of matched chains
+ * 3) Build sequence
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+
+
+#include "tm.h"
+
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include "hash.h"
+#include "map.h"
+#include "segments.h"
+#include "sequencer.h"
+//#include "table.h"
+#include "thread.h"
+#include "utility.h"
+#include "vector.h"
+#include "types.h"
+#include "Galois/Galois.h"
+#include "Galois/Bag.h"
+#include <boost/iterator/counting_iterator.hpp>
+#include <boost/iterator/iterator_adaptor.hpp>
+
+struct endInfoEntry {
+    bool_t isEnd;
+    long jumpToNext;
+};
+
+struct constructEntry {
+    bool_t isStart;
+    char* segment;
+    ulong_t endHash;
+    struct constructEntry* startPtr;
+    struct constructEntry* nextPtr;
+    struct constructEntry* endPtr;
+    long overlap;
+    long length;
+};
+
+
+/* =============================================================================
+ * hashString
+ * -- uses sdbm hash function
+ * =============================================================================
+ */
+static ulong_t
+hashString (char* str)
+{
+    ulong_t hash = 0;
+    long c;
+
+    /* Note: Do not change this hashing scheme */
+    while ((c = *str++) != '\0') {
+        hash = c + (hash << 6) + (hash << 16) - hash;
+    }
+
+    return (ulong_t)hash;
+}
+
+
+/* =============================================================================
+ * hashSegment
+ * -- For hashtable
+ * =============================================================================
+ */
+static ulong_t
+hashSegment (void* keyPtr)
+{
+    return (ulong_t)hash_sdbm((char*)keyPtr); /* can be any "good" hash function */
+}
+
+
+/* =============================================================================
+ * compareSegment
+ * -- For hashtable
+ * =============================================================================
+ */
+static long
+compareSegment (void* a, void* b)
+{
+    return strcmp((char*)(a), (char*)(b));
+}
+
+
+static Galois::InsertBag<list_t> *listsPtr;
+static Galois::Runtime::PerThreadStorage<hashtable> *perThreadUniqueSegmentsPtr;
+
+/* =============================================================================
+ * sequencer_alloc
+ * -- Returns NULL on failure
+ * =============================================================================
+ */
+sequencer_t*
+sequencer_alloc (long geneLength, long segmentLength, segments_t* segmentsPtr)
+{
+    sequencer_t* sequencerPtr;
+    long maxNumUniqueSegment = geneLength - segmentLength + 1;
+    long i;
+
+    sequencerPtr = (sequencer_t*)malloc(sizeof(sequencer_t));
+    if (sequencerPtr == NULL) {
+        return NULL;
+    }
+
+    sequencerPtr->uniqueSegmentsPtr =
+        hashtable_alloc(geneLength, &hashSegment, &compareSegment);
+    if (sequencerPtr->uniqueSegmentsPtr == NULL) {
+        return NULL;
+    }
+
+    perThreadUniqueSegmentsPtr = new Galois::Runtime::PerThreadStorage<hashtable>(geneLength, &hashSegment, &compareSegment);
+    listsPtr = new Galois::InsertBag<list_t>;
+
+    /* For finding a matching entry */
+    sequencerPtr->endInfoEntries =
+        (endInfoEntry_t*)malloc(maxNumUniqueSegment * sizeof(endInfoEntry_t));
+    for (i = 0; i < maxNumUniqueSegment; i++) {
+        endInfoEntry_t* endInfoEntryPtr = &sequencerPtr->endInfoEntries[i];
+        endInfoEntryPtr->isEnd = TRUE;
+        endInfoEntryPtr->jumpToNext = 1;
+    }
+    sequencerPtr->startHashToConstructEntryTables =
+        (table_t**)malloc(segmentLength * sizeof(table_t*));
+    if (sequencerPtr->startHashToConstructEntryTables == NULL) {
+        return NULL;
+    }
+    for (i = 1; i < segmentLength; i++) { /* 0 is dummy entry */
+        sequencerPtr->startHashToConstructEntryTables[i] =
+            table_alloc(geneLength, NULL);
+        if (sequencerPtr->startHashToConstructEntryTables[i] == NULL) {
+            return NULL;
+        }
+    }
+    sequencerPtr->segmentLength = segmentLength;
+
+    /* For constructing sequence */
+    sequencerPtr->constructEntries =
+        (constructEntry_t*)malloc(maxNumUniqueSegment * sizeof(constructEntry_t));
+    if (sequencerPtr->constructEntries == NULL) {
+        return NULL;
+    }
+    for (i= 0; i < maxNumUniqueSegment; i++) {
+        constructEntry_t* constructEntryPtr = &sequencerPtr->constructEntries[i];
+        constructEntryPtr->isStart = TRUE;
+        constructEntryPtr->segment = NULL;
+        constructEntryPtr->endHash = 0;
+        constructEntryPtr->startPtr = constructEntryPtr;
+        constructEntryPtr->nextPtr = NULL;
+        constructEntryPtr->endPtr = constructEntryPtr;
+        constructEntryPtr->overlap = 0;
+        constructEntryPtr->length = segmentLength;
+    }
+    sequencerPtr->hashToConstructEntryTable = table_alloc(geneLength, NULL);
+    if (sequencerPtr->hashToConstructEntryTable == NULL) {
+        return NULL;
+    }
+
+    Galois::preAlloc(15 * Galois::getActiveThreads() + Galois::Runtime::MM::numPageAllocTotal() * 4);
+    sequencerPtr->segmentsPtr = segmentsPtr;
+
+    return sequencerPtr;
+}
+
+struct Fn1 {
+    hashtable_t* uniqueSegmentsPtr;
+
+    Fn1(
+    hashtable_t* _uniqueSegmentsPtr):
+      uniqueSegmentsPtr(_uniqueSegmentsPtr) { }
+
+    void operator()(void* segment, Galois::UserContext<void*>&) {
+        TMMAP_INSERT(uniqueSegmentsPtr, segment, segment);
+    }
+};
+
+struct Fn2 {
+    struct ArgType {
+      char* segment;
+      long entryIndex;
+      long index;
+      ulong_t hash;
+    };
+
+    table_t**         startHashToConstructEntryTables;
+    constructEntry_t* constructEntries;
+    table_t*          hashToConstructEntryTable;
+    long segmentLength;
+    Galois::InsertBag<list_t>& lists;
+
+    void operator()(const ArgType& p, Galois::UserContext<ArgType>& ctx) {
+        char* segment = p.segment;
+        long entryIndex = p.entryIndex;
+        constructEntry_t* constructEntryPtr = &constructEntries[entryIndex];
+
+        if (p.index == 0) {
+            constructEntryPtr->segment = segment;
+            constructEntryPtr->endHash = (ulong_t)hashString(&segment[1]);
+            ArgType n = { p.segment, p.entryIndex, p.index + 1, p.hash };
+            ctx.push(n);
+        } else if (p.index < segmentLength) {
+            ulong_t startHash = (ulong_t)segment[p.index-1] + (p.hash << 6) + (p.hash << 16) - p.hash;
+            TMMAP_ACQUIRE(startHashToConstructEntryTables[p.index], (void*)startHash);
+            list_t* list = (list_t*) MAP_FIND(startHashToConstructEntryTables[p.index], startHash);
+            if (!list) {
+              list = &lists.emplace();
+              MAP_INSERT(startHashToConstructEntryTables[p.index], startHash, list);
+            }
+            list_insert(list, constructEntryPtr);
+            ArgType n = { p.segment, p.entryIndex, p.index + 1, startHash };
+            ctx.push(n);
+        } else {
+            ulong_t startHash = (ulong_t)segment[p.index-1] + (p.hash << 6) + (p.hash << 16) - p.hash;
+            TMMAP_ACQUIRE(hashToConstructEntryTable, (void*)startHash);
+            list_t* list = (list_t*) MAP_FIND(hashToConstructEntryTable, startHash);
+            if (!list) {
+                list = &lists.emplace();
+                MAP_INSERT(hashToConstructEntryTable, startHash, list);
+            }
+            list_insert(list, constructEntryPtr);
+        }
+    }
+};
+
+struct Fn3 {
+    Galois::Runtime::Lockable* locks;
+
+    void operator()(long i) {
+        new (&locks[i]) Galois::Runtime::Lockable();
+    }
+};
+
+struct Fn4Inplace {
+    typedef int tt_needs_per_iter_alloc;
+
+#ifdef HTM
+    struct WriteLog: private boost::noncopyable {
+      WriteLog(const Galois::PerIterAllocTy& a) { }
+
+      void write(long* addr, long val) {
+        *addr = val;
+      }
+
+      void writePtr(constructEntry** addr, constructEntry* ptr) {
+        *addr = ptr;
+      }
+
+      void clear() { }
+    };
+
+#else
+    struct WriteLog: private boost::noncopyable, public Galois::Runtime::Releasable {
+      struct Op {
+        long *addr;
+        long val;
+      };
+      typedef Galois::PerIterAllocTy::rebind<Op>::other DequeAllocator;
+      std::deque<Op, DequeAllocator> ops;
+
+      WriteLog(const Galois::PerIterAllocTy& a): ops(a) { }
+
+      virtual ~WriteLog() { cleanup(); }
+      virtual void release() { cleanup(); }
+
+      void cleanup() {
+          while (!ops.empty()) {
+              Op& op = ops.back();
+              *op.addr = op.val;
+              ops.pop_back();
+          }
+      }
+      void write(long* addr, long val) {
+        Op op = { addr, *addr };
+        ops.push_back(op);
+        *addr = val;
+      }
+
+      void writePtr(constructEntry** addr, constructEntry* ptr) {
+        Op op = { (long*) addr, (intptr_t) *addr };
+        ops.push_back(op);
+        *addr = ptr;
+      }
+
+      void clear() { ops.clear(); }
+    };
+#endif
+
+    constructEntry_t* constructEntries;
+    endInfoEntry_t*   endInfoEntries;
+    table_t* startHashToConstructEntryTablePtr;
+    long segmentLength;
+    long substringLength;
+    Galois::Runtime::Lockable* locks;
+
+    void execute(long entryIndex, WriteLog& log) {
+        /*  ConstructEntries[entryIndex] is local data */
+        constructEntry_t* endConstructEntryPtr = &constructEntries[entryIndex];
+        Galois::Runtime::acquire(&locks[entryIndex], Galois::MethodFlag::ALL);
+        char* endSegment = endConstructEntryPtr->segment;
+        ulong_t endHash = endConstructEntryPtr->endHash;
+
+        // find from startHash
+        list_t* chainPtr = (list_t*) MAP_FIND(startHashToConstructEntryTablePtr, (void*) endHash);
+        if (!chainPtr)
+          return;
+
+        list_iter_t it;
+        list_iter_reset(&it, chainPtr);
+
+        /* Linked list at chainPtr is constant */
+        while (list_iter_hasNext(&it, chainPtr)) {
+            constructEntry_t* startConstructEntryPtr =
+                (constructEntry_t*)list_iter_next(&it, chainPtr);
+            Galois::Runtime::acquire(&locks[std::distance(constructEntries, startConstructEntryPtr)],
+                Galois::MethodFlag::ALL);
+            char* startSegment = startConstructEntryPtr->segment;
+            long newLength = 0;
+
+            /* endConstructEntryPtr is local except for properties startPtr/endPtr/length */
+            TM_BEGIN();
+
+            /* Check if matches */
+            if (TM_SHARED_READ(startConstructEntryPtr->isStart) &&
+                (TM_SHARED_READ_P(endConstructEntryPtr->startPtr) != startConstructEntryPtr) &&
+                (strncmp(startSegment,
+                         &endSegment[segmentLength - substringLength],
+                         substringLength) == 0))
+            {
+                log.write(&startConstructEntryPtr->isStart, FALSE);
+
+                constructEntry_t* startConstructEntry_endPtr;
+                constructEntry_t* endConstructEntry_startPtr;
+
+                /* Update endInfo (appended something so no longer end) */
+                log.write(&endInfoEntries[entryIndex].isEnd, FALSE);
+
+                /* Update segment chain construct info */
+                startConstructEntry_endPtr =
+                    (constructEntry_t*)TM_SHARED_READ_P(startConstructEntryPtr->endPtr);
+                Galois::Runtime::acquire(&locks[std::distance(constructEntries, startConstructEntry_endPtr)],
+                    Galois::MethodFlag::ALL);
+                endConstructEntry_startPtr =
+                    (constructEntry_t*)TM_SHARED_READ_P(endConstructEntryPtr->startPtr);
+                Galois::Runtime::acquire(&locks[std::distance(constructEntries, endConstructEntry_startPtr)],
+                    Galois::MethodFlag::ALL);
+                assert(startConstructEntry_endPtr);
+                assert(endConstructEntry_startPtr);
+                log.writePtr(&startConstructEntry_endPtr->startPtr,
+                                  endConstructEntry_startPtr);
+                log.writePtr(&endConstructEntryPtr->nextPtr,
+                                 startConstructEntryPtr);
+                log.writePtr(&endConstructEntry_startPtr->endPtr,
+                                  startConstructEntry_endPtr);
+                log.write(&endConstructEntryPtr->overlap, substringLength);
+                newLength = (long)TM_SHARED_READ(endConstructEntry_startPtr->length) +
+                            (long)TM_SHARED_READ(startConstructEntryPtr->length) -
+                            substringLength;
+                log.write(&endConstructEntry_startPtr->length, newLength);
+            } /* if (matched) */
+
+            TM_END();
+
+            if (!endInfoEntries[entryIndex].isEnd) { /* if there was a match */
+                break;
+            }
+        } /* iterate over chain */
+    }
+
+    void operator()(long entryIndex, Galois::UserContext<long>& ctx) {
+        if (!endInfoEntries[entryIndex].isEnd) {
+            return;
+        }
+        WriteLog log(ctx.getPerIterAlloc());
+        execute(entryIndex, log);
+        log.clear();
+    }
+};
+
+struct Fn4Continuation {
+    typedef int tt_does_not_need_push;
+    constructEntry_t* constructEntries;
+    endInfoEntry_t*   endInfoEntries;
+    table_t* startHashToConstructEntryTablePtr;
+    long segmentLength;
+    long substringLength;
+    Galois::Runtime::Lockable* locks;
+
+    struct Continuation {
+        constructEntry_t* startConstructEntryPtr;
+        bool breakLoop;
+        constructEntry_t** addr_startConstructEntry_endPtr_startPtr;
+        constructEntry_t* endConstructEntry_startPtr;
+        constructEntry_t** addr_endConstructEntryPtr_nextPtr;
+        constructEntry_t** addr_endConstructEntryPtr_startPtr_endPtr;
+        constructEntry_t* startConstructEntry_endPtr;
+        long* addr_endConstructEntryPtr_overlap;
+        long* addr_endConstructEntry_startPtr_length;
+        long newLength;
+    };
+
+    void acquire(long entryIndex, Continuation& continuation) {
+        /*  ConstructEntries[entryIndex] is local data */
+        constructEntry_t* endConstructEntryPtr = &constructEntries[entryIndex];
+#ifndef HTM
+        Galois::Runtime::acquire(&locks[entryIndex], Galois::MethodFlag::ALL);
+#endif
+        char* endSegment = endConstructEntryPtr->segment;
+        ulong_t endHash = endConstructEntryPtr->endHash;
+
+        // find from startHash
+        list_t* chainPtr = (list_t*) MAP_FIND(startHashToConstructEntryTablePtr, (void*) endHash);
+        if (!chainPtr)
+          return;
+
+        list_iter_t it;
+        list_iter_reset(&it, chainPtr);
+
+        /* Linked list at chainPtr is constant */
+        while (list_iter_hasNext(&it, chainPtr)) {
+
+            constructEntry_t* startConstructEntryPtr =
+                (constructEntry_t*)list_iter_next(&it, chainPtr);
+#ifndef HTM
+            Galois::Runtime::acquire(&locks[std::distance(constructEntries, startConstructEntryPtr)],
+                Galois::MethodFlag::ALL);
+#endif
+            char* startSegment = startConstructEntryPtr->segment;
+            long newLength = 0;
+
+            /* endConstructEntryPtr is local except for properties startPtr/endPtr/length */
+            TM_BEGIN();
+
+            bool breakLoop = false;
+
+            /* Check if matches */
+            if (TM_SHARED_READ(startConstructEntryPtr->isStart) &&
+                (TM_SHARED_READ_P(endConstructEntryPtr->startPtr) != startConstructEntryPtr) &&
+                (strncmp(startSegment,
+                         &endSegment[segmentLength - substringLength],
+                         substringLength) == 0))
+            {
+                
+                //TM_SHARED_WRITE(startConstructEntryPtr->isStart, FALSE);
+                continuation.startConstructEntryPtr = startConstructEntryPtr;
+
+                constructEntry_t* startConstructEntry_endPtr;
+                constructEntry_t* endConstructEntry_startPtr;
+
+                /* Update endInfo (appended something so no longer end) */
+                //TM_LOCAL_WRITE(endInfoEntries[entryIndex].isEnd, FALSE);
+                continuation.breakLoop = true;
+                breakLoop = true;
+
+                /* Update segment chain construct info */
+                startConstructEntry_endPtr =
+                    (constructEntry_t*)TM_SHARED_READ_P(startConstructEntryPtr->endPtr);
+#ifndef HTM
+                Galois::Runtime::acquire(&locks[std::distance(constructEntries, startConstructEntry_endPtr)],
+                    Galois::MethodFlag::ALL);
+#endif
+
+                endConstructEntry_startPtr =
+                    (constructEntry_t*)TM_SHARED_READ_P(endConstructEntryPtr->startPtr);
+#ifndef HTM
+                Galois::Runtime::acquire(&locks[std::distance(constructEntries, endConstructEntry_startPtr)],
+                    Galois::MethodFlag::ALL);
+#endif
+                assert(startConstructEntry_endPtr);
+                assert(endConstructEntry_startPtr);
+                continuation.addr_startConstructEntry_endPtr_startPtr = &startConstructEntry_endPtr->startPtr;
+                continuation.endConstructEntry_startPtr = endConstructEntry_startPtr;
+                continuation.addr_endConstructEntryPtr_nextPtr = &endConstructEntryPtr->nextPtr;
+                continuation.addr_endConstructEntryPtr_startPtr_endPtr = &endConstructEntry_startPtr->endPtr;
+                continuation.startConstructEntry_endPtr = startConstructEntry_endPtr;
+                continuation.addr_endConstructEntryPtr_overlap = &endConstructEntryPtr->overlap;
+                newLength = (long)TM_SHARED_READ(endConstructEntry_startPtr->length) +
+                            (long)TM_SHARED_READ(startConstructEntryPtr->length) -
+                            substringLength;
+                continuation.addr_endConstructEntry_startPtr_length = &endConstructEntry_startPtr->length;
+                continuation.newLength = newLength;
+            } /* if (matched) */
+
+            TM_END();
+
+            if (breakLoop) { /* if there was a match */
+                break;
+            }
+        } /* iterate over chain */
+    }
+
+    void mutate(long entryIndex, Continuation& continuation) {
+        /*  ConstructEntries[entryIndex] is local data */
+        constructEntry_t* endConstructEntryPtr = &constructEntries[entryIndex];
+
+        continuation.startConstructEntryPtr->isStart = FALSE;
+
+        endInfoEntries[entryIndex].isEnd = FALSE;
+
+        *continuation.addr_startConstructEntry_endPtr_startPtr = continuation.endConstructEntry_startPtr;
+        *continuation.addr_endConstructEntryPtr_nextPtr = continuation.startConstructEntryPtr;
+        *continuation.addr_endConstructEntryPtr_startPtr_endPtr = continuation.startConstructEntry_endPtr;
+        *continuation.addr_endConstructEntryPtr_overlap = substringLength;
+        *continuation.addr_endConstructEntry_startPtr_length = continuation.newLength;
+    }
+
+    void operator()(long entryIndex, Galois::UserContext<long>&) {
+      (*this)(entryIndex);
+    }
+
+    void operator()(long entryIndex) {
+        if (!endInfoEntries[entryIndex].isEnd) {
+            return;
+        }
+        Continuation continuation;
+        continuation.breakLoop = false;
+        acquire(entryIndex, continuation);
+        if (continuation.breakLoop)
+            mutate(entryIndex, continuation);
+    }
+};
+
+
+struct Fn0 {
+    void operator()(void* segment) {
+        MAP_INSERT(perThreadUniqueSegmentsPtr->getLocal(), segment, segment);
+    }
+};
+
+struct Fn00 {
+    unsigned N;
+    unsigned i;
+
+    Fn00(unsigned N, unsigned i): N(N), i(i) { }
+
+    void operator()(unsigned x) {
+        unsigned a = x*(1<<i);
+        unsigned b = x*(1<<i) + (1<<(i-1));
+        if (a < N && b < N)
+          perThreadUniqueSegmentsPtr->getRemote(a)->mergeWith(
+            *perThreadUniqueSegmentsPtr->getRemote(b));
+    }
+};
+
+struct Fn02 {
+    Galois::InsertBag<long>& indices;
+    Fn02(Galois::InsertBag<long>& i): indices(i) { }
+    void operator()(long i) {
+        indices.push(i);
+    }
+};
+
+/* =============================================================================
+ * sequencer_run
+ * =============================================================================
+ */
+void
+sequencer_run (void* argPtr)
+{
+    Galois::reportPageAlloc("MeminfoPre");
+    TM_THREAD_ENTER();
+
+    long threadId = 0; //thread_getId();
+
+    sequencer_t* sequencerPtr = (sequencer_t*)argPtr;
+
+    hashtable_t*      uniqueSegmentsPtr;
+    endInfoEntry_t*   endInfoEntries;
+    table_t**         startHashToConstructEntryTables;
+    constructEntry_t* constructEntries;
+    table_t*          hashToConstructEntryTable;
+
+    uniqueSegmentsPtr               = sequencerPtr->uniqueSegmentsPtr;
+    endInfoEntries                  = sequencerPtr->endInfoEntries;
+    startHashToConstructEntryTables = sequencerPtr->startHashToConstructEntryTables;
+    constructEntries                = sequencerPtr->constructEntries;
+    hashToConstructEntryTable       = sequencerPtr->hashToConstructEntryTable;
+
+    segments_t* segmentsPtr         = sequencerPtr->segmentsPtr;
+    assert(segmentsPtr);
+    vector_t*   segmentsContentsPtr = segmentsPtr->contentsPtr;
+    long        numSegment          = vector_getSize(segmentsContentsPtr);
+    long        segmentLength       = segmentsPtr->length;
+
+    long i;
+    long j;
+    //long i_start;
+    //long i_stop;
+    long numUniqueSegment;
+    //long substringLength;
+    //long entryIndex;
+
+    /*
+     * Step 1: Remove duplicate segments
+     */
+    Galois::do_all(segmentsContentsPtr->begin(), segmentsContentsPtr->end(), Fn0());
+
+    unsigned N = Galois::getActiveThreads();
+    for (unsigned n = (N + 1)/2, i = 1; n; n /= 2, ++i) {
+      Galois::do_all(boost::counting_iterator<unsigned>(0), boost::counting_iterator<unsigned>(n),
+          Fn00(N, i));
+    }
+    uniqueSegmentsPtr = perThreadUniqueSegmentsPtr->getRemote(0);
+
+    /*
+     * Step 2a: Iterate over unique segments and compute hashes.
+     *
+     * For the gene "atcg", the hashes for the end would be:
+     *
+     *     "t", "tc", and "tcg"
+     *
+     * And for the gene "tcgg", the hashes for the start would be:
+     *
+     *    "t", "tc", and "tcg"
+     *
+     * The names are "end" and "start" because if a matching pair is found,
+     * they are the substring of the end part of the pair and the start
+     * part of the pair respectively. In the above example, "tcg" is the
+     * matching substring so:
+     *
+     *     (end)    (start)
+     *     a[tcg] + [tcg]g  = a[tcg]g    (overlap = "tcg")
+     */
+    numUniqueSegment = 0;
+    typedef std::deque<Fn2::ArgType> UniqueEntries;
+    UniqueEntries uniqueEntries;
+    for (auto ii = uniqueSegmentsPtr->begin(), ei = uniqueSegmentsPtr->end(); ii != ei; ++ii) {
+      Fn2::ArgType p = { (char*) ii->second, numUniqueSegment++, 0, 0 };
+      uniqueEntries.push_back(p);
+    }
+
+    Fn2 fn2 = { startHashToConstructEntryTables, constructEntries, hashToConstructEntryTable, segmentLength, *listsPtr };
+    Galois::for_each(uniqueEntries.begin(), uniqueEntries.end(), fn2, Galois::wl<Galois::WorkList::dChunkedLIFO<32> >());
+
+    Galois::InsertBag<long> indices;
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(numUniqueSegment),
+        Fn02(indices));
+
+    Galois::Runtime::Lockable* locks = 0;
+
+#ifndef HTM 
+    locks = (Galois::Runtime::Lockable*) malloc(sizeof(*locks) * numUniqueSegment);
+    Fn3 fn3 = { locks };
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(numUniqueSegment), fn3);
+#endif
+
+    /*
+     * Step 2b: Match ends to starts by using hash-based string comparison.
+     */
+    for (long substringLength = segmentLength-1; substringLength > 0; substringLength--) {
+
+        table_t* startHashToConstructEntryTablePtr =
+            startHashToConstructEntryTables[substringLength];
+
+        Fn4Continuation fn4 = { constructEntries, endInfoEntries, startHashToConstructEntryTablePtr, segmentLength, substringLength, locks };
+        Galois::for_each_local(indices, fn4, Galois::wl<Galois::WorkList::StableIterator<Galois::InsertBag<long>::local_iterator>>());
+
+        /*
+         * Step 2c: Update jump values and hashes
+         *
+         * endHash entries of all remaining ends are updated to the next
+         * substringLength. Additionally jumpToNext entries are updated such
+         * that they allow to skip non-end entries. Currently this is sequential
+         * because parallelization did not perform better.
+         */
+
+        if (threadId == 0) {
+            if (substringLength > 1) {
+                long index = segmentLength - substringLength + 1;
+                /* initialization if j and i: with i being the next end after j=0 */
+                for (i = 1; !endInfoEntries[i].isEnd; i+=endInfoEntries[i].jumpToNext) {
+                    /* find first non-null */
+                }
+                /* entry 0 is handled seperately from the loop below */
+                endInfoEntries[0].jumpToNext = i;
+                if (endInfoEntries[0].isEnd) {
+                    constructEntry_t* constructEntryPtr = &constructEntries[0];
+                    char* segment = constructEntryPtr->segment;
+                    constructEntryPtr->endHash = (ulong_t)hashString(&segment[index]);
+                }
+                /* Continue scanning (do not reset i) */
+                for (j = 0; i < numUniqueSegment; i+=endInfoEntries[i].jumpToNext) {
+                    if (endInfoEntries[i].isEnd) {
+                        constructEntry_t* constructEntryPtr = &constructEntries[i];
+                        char* segment = constructEntryPtr->segment;
+                        constructEntryPtr->endHash = (ulong_t)hashString(&segment[index]);
+                        endInfoEntries[j].jumpToNext = (1 > (i - j)) ? 1 : (i - j); // MAX(1, (i - j));
+                        j = i;
+                    }
+                }
+                endInfoEntries[j].jumpToNext = i - j;
+            }
+            // Populate insert bag with right entries
+            indices.clear();
+            for (i = 0; i < numUniqueSegment; i += endInfoEntries[i].jumpToNext) {
+                if (endInfoEntries[i].isEnd)
+                    continue;
+                indices.push(i);
+            }
+        }
+    } /* for (substringLength > 0) */
+
+    if (locks)
+        free(locks);
+
+    /*
+     * Step 3: Build sequence string
+     */
+    if (threadId == 0) {
+
+        long totalLength = 0;
+
+        for (i = 0; i < numUniqueSegment; i++) {
+            constructEntry_t* constructEntryPtr = &constructEntries[i];
+            if (constructEntryPtr->isStart) {
+              totalLength += constructEntryPtr->length;
+            }
+        }
+
+        sequencerPtr->sequence = (char*)P_MALLOC((totalLength+1) * sizeof(char));
+        char* sequence = sequencerPtr->sequence;
+        assert(sequence);
+
+        char* copyPtr = sequence;
+        long sequenceLength = 0;
+
+        for (i = 0; i < numUniqueSegment; i++) {
+            constructEntry_t* constructEntryPtr = &constructEntries[i];
+            /* If there are several start segments, we append in arbitrary order  */
+            if (constructEntryPtr->isStart) {
+                long newSequenceLength = sequenceLength + constructEntryPtr->length;
+                assert( newSequenceLength <= totalLength );
+                copyPtr = sequence + sequenceLength;
+                sequenceLength = newSequenceLength;
+                do {
+                    long numChar = segmentLength - constructEntryPtr->overlap;
+                    if ((copyPtr + numChar) > (sequence + newSequenceLength)) {
+                        TM_PRINT0("ERROR: sequence length != actual length\n");
+                        break;
+                    }
+                    memcpy(copyPtr,
+                           constructEntryPtr->segment,
+                           (numChar * sizeof(char)));
+                    copyPtr += numChar;
+                } while ((constructEntryPtr = constructEntryPtr->nextPtr) != NULL);
+                assert(copyPtr <= (sequence + sequenceLength));
+            }
+        }
+
+        assert(sequence != NULL);
+        sequence[sequenceLength] = '\0';
+    }
+
+    TM_THREAD_EXIT();
+    Galois::reportPageAlloc("MeminfoPost");
+}
+
+/* =============================================================================
+ * sequencer_free
+ * =============================================================================
+ */
+void
+sequencer_free (sequencer_t* sequencerPtr)
+{
+    long i;
+
+    table_free(sequencerPtr->hashToConstructEntryTable);
+    free(sequencerPtr->constructEntries);
+    for (i = 1; i < sequencerPtr->segmentLength; i++) {
+        table_free(sequencerPtr->startHashToConstructEntryTables[i]);
+    }
+    free(sequencerPtr->startHashToConstructEntryTables);
+    free(sequencerPtr->endInfoEntries);
+#if 0
+    /* TODO: fix mixed sequential/parallel allocation */
+    hashtable_free(sequencerPtr->uniqueSegmentsPtr);
+    if (sequencerPtr->sequence != NULL) {
+        free(sequencerPtr->sequence);
+    }
+#endif
+    free(sequencerPtr);
+    delete listsPtr;
+    delete perThreadUniqueSegmentsPtr;
+}
+
+
+/* =============================================================================
+ * TEST_SEQUENCER
+ * =============================================================================
+ */
+#ifdef TEST_SEQUENCER
+
+
+#include <assert.h>
+#include <stdio.h>
+#include "segments.h"
+
+
+char* gene1 = "gatcggcagc";
+char* segments1[] = {
+    "atcg",
+    "gcag",
+    "tcgg",
+    "cagc",
+    "gatc",
+    NULL
+};
+
+char* gene2 = "aaagc";
+char* segments2[] = {
+    "aaa",
+    "aag",
+    "agc",
+    NULL
+};
+
+char* gene3 = "aaacaaagaaat";
+char* segments3[] = {
+    "aaac",
+    "aaag",
+    "aaat",
+    NULL
+};
+
+char* gene4 = "ttggctacgtatcgcacggt";
+char* segments4[] = {
+    "cgtatcgc",
+    "tcgcacgg",
+    "gtatcgca",
+    "tatcgcac",
+    "atcgcacg",
+    "ttggctac",
+    "ctacgtat",
+    "acgtatcg",
+    "ctacgtat",
+    "cgtatcgc",
+    "atcgcacg",
+    "ggctacgt",
+    "tacgtatc",
+    "tcgcacgg",
+    "ttggctac",
+    "ggctacgt",
+    "atcgcacg",
+    "tatcgcac",
+    "cgtatcgc",
+    "acgtatcg",
+    "gtatcgca",
+    "gtatcgca",
+    "cgcacggt",
+    "tatcgcac",
+    "ttggctac",
+    "atcgcacg",
+    "acgtatcg",
+    "gtatcgca",
+    "ttggctac",
+    "tggctacg",
+    NULL
+};
+
+char* gene5 = "gatcggcagctggtacggcg";
+char* segments5[] = {
+    "atcggcag",
+    "gtacggcg",
+    "gatcggca",
+    "cagctggt",
+    "tggtacgg",
+    "gatcggca",
+    "gatcggca",
+    "tcggcagc",
+    "ggtacggc",
+    "tggtacgg",
+    "tcggcagc",
+    "gcagctgg",
+    "gatcggca",
+    "gctggtac",
+    "gatcggca",
+    "ctggtacg",
+    "ggcagctg",
+    "tcggcagc",
+    "gtacggcg",
+    "gcagctgg",
+    "ggcagctg",
+    "tcggcagc",
+    "cagctggt",
+    "tggtacgg",
+    "cagctggt",
+    "gcagctgg",
+    "gctggtac",
+    "cggcagct",
+    "agctggta",
+    "ctggtacg",
+    NULL
+};
+
+char* gene6 = "ttggtgagccgtaagactcc";
+char* segments6[] = {
+    "cgtaagac",
+    "taagactc",
+    "gtgagccg",
+    "gagccgta",
+    "gccgtaag",
+    "tgagccgt",
+    "gccgtaag",
+    "cgtaagac",
+    "ttggtgag",
+    "agccgtaa",
+    "gccgtaag",
+    "aagactcc",
+    "ggtgagcc",
+    "ttggtgag",
+    "agccgtaa",
+    "gagccgta",
+    "aagactcc",
+    "ttggtgag",
+    "gtaagact",
+    "ccgtaaga",
+    "ttggtgag",
+    "gagccgta",
+    "ggtgagcc",
+    "gagccgta",
+    "gccgtaag",
+    "aagactcc",
+    "gtaagact",
+    "ccgtaaga",
+    "tgagccgt",
+    "ttggtgag",
+    NULL
+};
+
+char* gene7 = "gatcggcagctggtacggcg";
+char* segments7[] = {
+    "atcggcag",
+    "gtacggcg",
+    "gatcggca",
+    "cagctggt",
+    "tggtacgg",
+    "gatcggca",
+    "gatcggca",
+    "tcggcagc",
+    "ggtacggc",
+    "tggtacgg",
+    "tcggcagc",
+    "gcagctgg",
+    "gatcggca",
+    "gctggtac",
+    "gatcggca",
+    "ctggtacg",
+    "ggcagctg",
+    "tcggcagc",
+    "gtacggcg",
+    "gcagctgg",
+    "ggcagctg",
+    "tcggcagc",
+    "cagctggt",
+    "tggtacgg",
+    "cagctggt",
+    "gcagctgg",
+    "gctggtac",
+    "cggcagct",
+    "agctggta",
+    "ctggtacg",
+    NULL
+};
+
+char* gene8 = "ttggtgagccgtaagactcc";
+char* segments8[] = {
+    "cgtaagac",
+    "taagactc",
+    "gtgagccg",
+    "gagccgta",
+    "gccgtaag",
+    "tgagccgt",
+    "gccgtaag",
+    "cgtaagac",
+    "ttggtgag",
+    "agccgtaa",
+    "gccgtaag",
+    "aagactcc",
+    "ggtgagcc",
+    "ttggtgag",
+    "agccgtaa",
+    "gagccgta",
+    "aagactcc",
+    "ttggtgag",
+    "gtaagact",
+    "ccgtaaga",
+    "ttggtgag",
+    "gagccgta",
+    "ggtgagcc",
+    "gagccgta",
+    "gccgtaag",
+    "aagactcc",
+    "gtaagact",
+    "ccgtaaga",
+    "tgagccgt",
+    "ttggtgag",
+    NULL
+};
+
+
+static segments_t*
+createSegments (char* segments[])
+{
+    long i = 0;
+    segments_t* segmentsPtr = (segments_t*)malloc(sizeof(segments));
+
+    segmentsPtr->length = strlen(segments[0]);
+    segmentsPtr->contentsPtr = vector_alloc(1);
+
+    while (segments[i] != NULL) {
+        bool_t status = vector_pushBack(segmentsPtr->contentsPtr,
+                                        (void*)segments[i]);
+        assert(status);
+        i++;
+    }
+
+    {
+      list_iter_t it;
+      list_iter_reset(&it, segmentsPtr->contentsPtr);
+      long numSegments = 0;
+      while (list_iter_hasNext(&it, segmentsPtr->contentsPtr)) {
+        numSegments += 1;
+        list_iter_next(&it, segmentsPtr->contentsPtr);
+      }
+      //segmentsPtr->minNum = vector_getSize(segmentsPtr->contentsPtr);
+      segmentsPtr->minNum = numSegments;
+    }
+
+    return segmentsPtr;
+}
+
+
+static void
+tester (char* gene, char* segments[])
+{
+    segments_t* segmentsPtr;
+    sequencer_t* sequencerPtr;
+
+    segmentsPtr = createSegments(segments);
+    sequencerPtr = sequencer_alloc(strlen(gene), segmentsPtr->length, segmentsPtr);
+
+    sequencer_run((void*)sequencerPtr);
+
+    printf("gene     = %s\n", gene);
+    printf("sequence = %s\n", sequencerPtr->sequence);
+    assert(strcmp(sequencerPtr->sequence, gene) == 0);
+
+    sequencer_free(sequencerPtr);
+}
+
+
+int
+main ()
+{
+    bool_t status = memory_init(1, 4, 2);
+    assert(status);
+    thread_startup(1);
+
+    puts("Starting...");
+
+    /* Simple test */
+    tester(gene1, segments1);
+
+    /* Simple test with aliasing segments */
+    tester(gene2, segments2);
+
+    /* Simple test with non-overlapping segments */
+    tester(gene3, segments3);
+
+    /* Complex tests */
+    tester(gene4, segments4);
+    tester(gene5, segments5);
+    tester(gene6, segments6);
+    tester(gene7, segments7);
+    tester(gene8, segments8);
+
+    puts("Passed all tests.");
+
+    return 0;
+}
+
+
+#endif /* TEST_SEQUENCER */
+
+
+/* =============================================================================
+ *
+ * End of sequencer.c
+ *
+ * =============================================================================
+ */
diff -x .git -x inputs -Naur stamp-0.9.10/genome/sequencer.h stamp-g/genome/sequencer.h
--- stamp-0.9.10/genome/sequencer.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/genome/sequencer.h	2017-03-20 15:19:41.000000000 +0000
@@ -73,11 +73,20 @@
 #define SEQUENCER_H 1
 
 
-#include "hashtable.h"
+//#include "hashtable.h"
+#include "map.h"
 #include "segments.h"
-#include "table.h"
+//#include "table.h"
 #include "tm.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// A table is a map from hashes to lists of segments
+typedef MAP_T table_t;
+#define table_alloc(s, c) hashtable_alloc(s, c, 0)
+#define table_free(p) hashtable_free(p)
 
 typedef struct endInfoEntry endInfoEntry_t;
 typedef struct constructEntry constructEntry_t;
@@ -143,6 +152,9 @@
 void
 sequencer_free (sequencer_t* sequencerPtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* SEQUENCER_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/genome/table.h stamp-g/genome/table.h
--- stamp-0.9.10/genome/table.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/genome/table.h	2017-03-21 18:20:27.000000000 +0000
@@ -77,6 +77,9 @@
 #include "list.h"
 #include "types.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef struct table {
     list_t** buckets;
@@ -130,6 +133,10 @@
 
 #define TMTABLE_INSERT(t, h, d)         TMtable_insert(TM_ARG  t, h, d)
 
+#ifdef __cplusplus
+}
+#endif
+
 
 #endif /* TABLE_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/CMakeLists.txt stamp-g/intruder/CMakeLists.txt
--- stamp-0.9.10/intruder/CMakeLists.txt	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/intruder/CMakeLists.txt	2017-03-20 15:19:41.000000000 +0000
@@ -7,21 +7,23 @@
 add_definitions(-DMAP_USE_RBTREE)
 
 set(sources
-	decoder.c 
-	detector.c 
+	decoder.c
+	detector.c
 	dictionary.c 
-	intruder.c 
+	intruder.cpp 
 	packet.c 
 	preprocessor.c 
 	stream.c 
-	${LIB_DIR}/list.c 
+        #${LIB_DIR}/list.c 
 	${LIB_DIR}/mt19937ar.c 
-	${LIB_DIR}/pair.c 
-	${LIB_DIR}/queue.c 
+        #${LIB_DIR}/pair.c 
+        #${LIB_DIR}/queue.c 
 	${LIB_DIR}/random.c 
-	${LIB_DIR}/rbtree.c 
-	${LIB_DIR}/thread.c 
-	${LIB_DIR}/vector.c)
+        #${LIB_DIR}/rbtree.c 
+        ${LIB_DIR}/map.cpp 
+	${LIB_DIR}/thread.cpp
+        #${LIB_DIR}/vector.c
+        ${LIB_DIR}/deque.cpp)
 
 app(intruder ${sources})
 
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/decoder.c stamp-g/intruder/decoder.c
--- stamp-0.9.10/intruder/decoder.c	2017-03-21 17:39:12.000000000 +0000
+++ stamp-g/intruder/decoder.c	2017-03-20 15:19:41.000000000 +0000
@@ -92,6 +92,11 @@
 } decoded_t;
 
 
+MAP_T*
+decoder_getMap(decoder_t* decoderPtr) {
+  return decoderPtr->fragmentedMapPtr;
+}
+
 /* =============================================================================
  * decoder_alloc
  * =============================================================================
@@ -130,7 +135,7 @@
  * decoder_process
  * =============================================================================
  */
-error_t
+intruder_error_t
 decoder_process (decoder_t* decoderPtr, char* bytes, long numByte)
 {
     bool_t status;
@@ -289,12 +294,12 @@
     return ERROR_NONE;
 }
 
-
+#if 0
 /* =============================================================================
  * TMdecoder_process
  * =============================================================================
  */
-error_t
+intruder_error_t
 TMdecoder_process (TM_ARGDECL  decoder_t* decoderPtr, char* bytes, long numByte)
 {
     bool_t status;
@@ -452,7 +457,7 @@
 
     return ERROR_NONE;
 }
-
+#endif
 
 /* =============================================================================
  * decoder_getComplete
@@ -477,7 +482,7 @@
     return data;
 }
 
-
+#if 0
 /* =============================================================================
  * TMdecoder_getComplete
  * -- If none, returns NULL
@@ -500,7 +505,7 @@
 
     return data;
 }
-
+#endif
 
 /* #############################################################################
  * TEST_DECODER
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/decoder.h stamp-g/intruder/decoder.h
--- stamp-0.9.10/intruder/decoder.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/intruder/decoder.h	2017-03-20 15:19:41.000000000 +0000
@@ -72,9 +72,14 @@
 #define DECODER_H 1
 
 
+#include "map.h"
 #include "error.h"
 #include "tm.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct decoder decoder_t;
 
 
@@ -98,7 +103,7 @@
  * decoder_process
  * =============================================================================
  */
-error_t
+intruder_error_t
 decoder_process (decoder_t* decoderPtr, char* bytes, long numByte);
 
 
@@ -106,7 +111,7 @@
  * TMdecoder_process
  * =============================================================================
  */
-error_t
+intruder_error_t
 TMdecoder_process (TM_ARGDECL  decoder_t* decoderPtr, char* bytes, long numByte);
 
 
@@ -127,10 +132,15 @@
 char*
 TMdecoder_getComplete (TM_ARGDECL  decoder_t* decoderPtr, long* decodedFlowIdPtr);
 
+MAP_T*
+decoder_getMap(decoder_t* decoderPtr);
 
 #define TMDECODER_PROCESS(d, b, n)      TMdecoder_process(TM_ARG  d, b, n)
 #define TMDECODER_GETCOMPLETE(d, f)     TMdecoder_getComplete(TM_ARG  d, f)
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* DECODER_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/detector.c stamp-g/intruder/detector.c
--- stamp-0.9.10/intruder/detector.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/intruder/detector.c	2017-03-20 15:19:41.000000000 +0000
@@ -110,6 +110,7 @@
  * Pdetector_alloc
  * =============================================================================
  */
+#if 0
 detector_t*
 Pdetector_alloc ()
 {
@@ -125,7 +126,7 @@
 
     return detectorPtr;
 }
-
+#endif
 
 /* =============================================================================
  * detector_free
@@ -144,6 +145,7 @@
  * Pdetector_free
  * =============================================================================
  */
+#if 0
 void
 Pdetector_free (detector_t* detectorPtr)
 {
@@ -151,7 +153,7 @@
     PVECTOR_FREE(detectorPtr->preprocessorVectorPtr);
     P_FREE(detectorPtr);
 }
-
+#endif
 
 /* =============================================================================
  * detector_addPreprocessor
@@ -170,7 +172,7 @@
  * detector_process
  * =============================================================================
  */
-error_t
+intruder_error_t
 detector_process (detector_t* detectorPtr, char* str)
 {
     /*
@@ -179,10 +181,15 @@
 
     vector_t* preprocessorVectorPtr = detectorPtr->preprocessorVectorPtr;
     long p;
-    long numPreprocessor = vector_getSize(preprocessorVectorPtr);
-    for (p = 0; p < numPreprocessor; p++) {
+    list_iter_t it;
+    list_iter_reset(&it, preprocessorVectorPtr);
+    //long numPreprocessor = vector_getSize(preprocessorVectorPtr);
+    for (p = 0; 1 /*p < numPreprocessor*/; p++) {
+        if (!list_iter_hasNext(&it, preprocessorVectorPtr))
+          break;
+
         preprocessor_t preprocessor =
-            (preprocessor_t)vector_at(preprocessorVectorPtr, p);
+            (preprocessor_t)list_iter_next(&it, preprocessorVectorPtr); //vector_at(preprocessorVectorPtr, p);
         preprocessor(str);
     }
 
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/detector.h stamp-g/intruder/detector.h
--- stamp-0.9.10/intruder/detector.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/intruder/detector.h	2017-03-20 15:19:41.000000000 +0000
@@ -76,6 +76,10 @@
 #include "error.h"
 #include "preprocessor.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct detector detector_t;
 
 
@@ -123,7 +127,7 @@
  * detector_process
  * =============================================================================
  */
-error_t
+intruder_error_t
 detector_process (detector_t* detectorPtr, char* str);
 
 
@@ -132,6 +136,9 @@
 #define PDETECTOR_PROCESS(d, s)         detector_process(d, s)
 #define PDETECTOR_ADDPREPROCESSOR(d, s) detector_addPreprocessor(d, s)
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* DETECTOR_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/dictionary.c stamp-g/intruder/dictionary.c
--- stamp-0.9.10/intruder/dictionary.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/intruder/dictionary.c	2017-03-20 15:19:41.000000000 +0000
@@ -183,6 +183,7 @@
  * Pdictionary_alloc
  * =============================================================================
  */
+#if 0
 dictionary_t*
 Pdictionary_alloc ()
 {
@@ -200,7 +201,7 @@
 
     return dictionaryPtr;
 }
-
+#endif
 
 /* =============================================================================
  * dictionary_free
@@ -217,12 +218,13 @@
  * Pdictionary_free
  * =============================================================================
  */
+#if 0
 void
 Pdictionary_free (dictionary_t* dictionaryPtr)
 {
     PVECTOR_FREE(dictionaryPtr);
 }
-
+#endif
 
 /* =============================================================================
  * dictionary_add
@@ -242,10 +244,18 @@
 char*
 dictionary_get (dictionary_t* dictionaryPtr, long i)
 {
-    return (char*)vector_at(dictionaryPtr, i);
+    list_iter_t it;
+    list_iter_reset(&it, dictionaryPtr);
+    char* retval = 0;
+    for (long ii = 0; 1; ++ii) {
+        if (!list_iter_hasNext(&it, dictionaryPtr))
+            abort();
+        if (ii == i)
+            return (char*) list_iter_next(&it, dictionaryPtr);
+        list_iter_next(&it, dictionaryPtr);
+    }
 }
 
-
 /* =============================================================================
  * dictionary_match
  * =============================================================================
@@ -254,10 +264,16 @@
 dictionary_match (dictionary_t* dictionaryPtr, char* str)
 {
     long s;
-    long numSignature = vector_getSize(dictionaryPtr);
+    list_iter_t it;
+    list_iter_reset(&it, dictionaryPtr);
+
+    //long numSignature = vector_getSize(dictionaryPtr);
+
+    for (s = 0; 1 /*s < numSignature*/; s++) {
+        if (!list_iter_hasNext(&it, dictionaryPtr))
+          break;
 
-    for (s = 0; s < numSignature; s++) {
-        char* sig = (char*)vector_at(dictionaryPtr, s);
+        char* sig = (char*) list_iter_next(&it, dictionaryPtr); //vector_at(dictionaryPtr, s);
         if (strstr(str, sig) != NULL) {
             return sig;
         }
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/dictionary.h stamp-g/intruder/dictionary.h
--- stamp-0.9.10/intruder/dictionary.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/intruder/dictionary.h	2017-03-20 15:19:41.000000000 +0000
@@ -76,6 +76,10 @@
 #include "vector.h"
 #include "types.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 
 typedef vector_t dictionary_t;
 
@@ -143,6 +147,9 @@
 #define PDICTIONARY_ALLOC()             Pdictionary_alloc()
 #define PDICTIONARY_FREE(d)             Pdictionary_free(d)
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* DICTIONARY_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/error.h stamp-g/intruder/error.h
--- stamp-0.9.10/intruder/error.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/intruder/error.h	2017-03-20 15:19:41.000000000 +0000
@@ -72,8 +72,11 @@
 #ifndef ERROR_H
 #define ERROR_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
-typedef enum error {
+typedef enum intruder_error {
     ERROR_NONE        = 0,
     ERROR_SHORT       = 1,
     ERROR_FLOWID      = 2,
@@ -83,8 +86,11 @@
     ERROR_INCOMPLETE  = 6,
     ERROR_SIGNATURE   = 7,
     NUM_ERROR
-} error_t;
+} intruder_error_t;
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* ERROR_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/intruder.c stamp-g/intruder/intruder.c
--- stamp-0.9.10/intruder/intruder.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/intruder/intruder.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,375 +0,0 @@
-/* =============================================================================
- *
- * intruder.c
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <getopt.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include "decoder.h"
-#include "detector.h"
-#include "dictionary.h"
-#include "packet.h"
-#include "stream.h"
-#include "thread.h"
-#include "timer.h"
-#include "tm.h"
-
-enum param_types {
-    PARAM_ATTACK = (unsigned char)'a',
-    PARAM_LENGTH = (unsigned char)'l',
-    PARAM_NUM    = (unsigned char)'n',
-    PARAM_SEED   = (unsigned char)'s',
-    PARAM_THREAD = (unsigned char)'t',
-};
-
-enum param_defaults {
-    PARAM_DEFAULT_ATTACK = 10,
-    PARAM_DEFAULT_LENGTH = 16,
-    PARAM_DEFAULT_NUM    = 1 << 20,
-    PARAM_DEFAULT_SEED   = 1,
-    PARAM_DEFAULT_THREAD = 1,
-};
-
-long global_params[256] = { /* 256 = ascii limit */
-    [PARAM_ATTACK] = PARAM_DEFAULT_ATTACK,
-    [PARAM_LENGTH] = PARAM_DEFAULT_LENGTH,
-    [PARAM_NUM]    = PARAM_DEFAULT_NUM,
-    [PARAM_SEED]   = PARAM_DEFAULT_SEED,
-    [PARAM_THREAD] = PARAM_DEFAULT_THREAD,
-};
-
-typedef struct arg {
-  /* input: */
-    stream_t* streamPtr;
-    decoder_t* decoderPtr;
-  /* output: */
-    vector_t** errorVectors;
-} arg_t;
-
-
-/* =============================================================================
- * displayUsage
- * =============================================================================
- */
-static void
-displayUsage (const char* appName)
-{
-    printf("Usage: %s [options]\n", appName);
-    puts("\nOptions:                            (defaults)\n");
-    printf("    a <UINT>   Percent [a]ttack     (%i)\n", PARAM_DEFAULT_ATTACK);
-    printf("    l <UINT>   Max data [l]ength    (%i)\n", PARAM_DEFAULT_LENGTH);
-    printf("    n <UINT>   [n]umber of flows    (%i)\n", PARAM_DEFAULT_NUM);
-    printf("    s <UINT>   Random [s]eed        (%i)\n", PARAM_DEFAULT_SEED);
-    printf("    t <UINT>   Number of [t]hreads  (%i)\n", PARAM_DEFAULT_THREAD);
-    exit(1);
-}
-
-
-/* =============================================================================
- * parseArgs
- * =============================================================================
- */
-static void
-parseArgs (long argc, char* const argv[])
-{
-    long i;
-    long opt;
-
-    opterr = 0;
-
-    while ((opt = getopt(argc, argv, "a:l:n:s:t:")) != -1) {
-        switch (opt) {
-            case 'a':
-            case 'l':
-            case 'n':
-            case 's':
-            case 't':
-                global_params[(unsigned char)opt] = atol(optarg);
-                break;
-            case '?':
-            default:
-                opterr++;
-                break;
-        }
-    }
-
-    for (i = optind; i < argc; i++) {
-        fprintf(stderr, "Non-option argument: %s\n", argv[i]);
-        opterr++;
-    }
-
-    if (opterr) {
-        displayUsage(argv[0]);
-    }
-}
-
-
-/* =============================================================================
- * processPackets
- * =============================================================================
- */
-void
-processPackets (void* argPtr)
-{
-    TM_THREAD_ENTER();
-
-    long threadId = thread_getId();
-
-    stream_t*   streamPtr    = ((arg_t*)argPtr)->streamPtr;
-    decoder_t*  decoderPtr   = ((arg_t*)argPtr)->decoderPtr;
-    vector_t**  errorVectors = ((arg_t*)argPtr)->errorVectors;
-
-    detector_t* detectorPtr = PDETECTOR_ALLOC();
-    assert(detectorPtr);
-    PDETECTOR_ADDPREPROCESSOR(detectorPtr, &preprocessor_toLower);
-
-    vector_t* errorVectorPtr = errorVectors[threadId];
-
-    while (1) {
-
-        char* bytes;
-        TM_BEGIN();
-        bytes = TMSTREAM_GETPACKET(streamPtr);
-        TM_END();
-        if (!bytes) {
-            break;
-        }
-
-        packet_t* packetPtr = (packet_t*)bytes;
-        long flowId = packetPtr->flowId;
-
-        error_t error;
-        TM_BEGIN();
-        error = TMDECODER_PROCESS(decoderPtr,
-                                  bytes,
-                                  (PACKET_HEADER_LENGTH + packetPtr->length));
-        TM_END();
-        if (error) {
-            /*
-             * Currently, stream_generate() does not create these errors.
-             */
-            assert(0);
-            bool_t status = PVECTOR_PUSHBACK(errorVectorPtr, (void*)flowId);
-            assert(status);
-        }
-
-        char* data;
-        long decodedFlowId;
-        TM_BEGIN();
-        data = TMDECODER_GETCOMPLETE(decoderPtr, &decodedFlowId);
-        TM_END();
-        if (data) {
-            error_t error = PDETECTOR_PROCESS(detectorPtr, data);
-            //P_FREE(data);
-            //TM_FREE(data);
-            if (error) {
-                bool_t status = PVECTOR_PUSHBACK(errorVectorPtr,
-                                                 (void*)decodedFlowId);
-                assert(status);
-            }
-        }
-
-    }
-
-    PDETECTOR_FREE(detectorPtr);
-
-    TM_THREAD_EXIT();
-}
-
-
-/* =============================================================================
- * main
- * =============================================================================
- */
-MAIN(argc, argv)
-{
-    GOTO_REAL();
-
-    /*
-     * Initialization
-     */
-
-    parseArgs(argc, (char** const)argv);
-    long numThread = global_params[PARAM_THREAD];
-    SIM_GET_NUM_CPU(numThread);
-    TM_STARTUP(numThread);
-    P_MEMORY_STARTUP(numThread);
-    thread_startup(numThread);
-
-    long percentAttack = global_params[PARAM_ATTACK];
-    long maxDataLength = global_params[PARAM_LENGTH];
-    long numFlow       = global_params[PARAM_NUM];
-    long randomSeed    = global_params[PARAM_SEED];
-    printf("Percent attack  = %li\n", percentAttack);
-    printf("Max data length = %li\n", maxDataLength);
-    printf("Num flow        = %li\n", numFlow);
-    printf("Random seed     = %li\n", randomSeed);
-
-    dictionary_t* dictionaryPtr = dictionary_alloc();
-    assert(dictionaryPtr);
-    stream_t* streamPtr = stream_alloc(percentAttack);
-    assert(streamPtr);
-    long numAttack = stream_generate(streamPtr,
-                                     dictionaryPtr,
-                                     numFlow,
-                                     randomSeed,
-                                     maxDataLength);
-    printf("Num attack      = %li\n", numAttack);
-
-    decoder_t* decoderPtr = decoder_alloc();
-    assert(decoderPtr);
-
-    vector_t** errorVectors = (vector_t**)malloc(numThread * sizeof(vector_t*));
-    assert(errorVectors);
-    long i;
-    for (i = 0; i < numThread; i++) {
-        vector_t* errorVectorPtr = vector_alloc(numFlow);
-        assert(errorVectorPtr);
-        errorVectors[i] = errorVectorPtr;
-    }
-
-    arg_t arg;
-    arg.streamPtr    = streamPtr;
-    arg.decoderPtr   = decoderPtr;
-    arg.errorVectors = errorVectors;
-
-    /*
-     * Run transactions
-     */
-
-    TIMER_T startTime;
-    TIMER_READ(startTime);
-    GOTO_SIM();
-    thread_begin_timing();
-#ifdef OTM
-#pragma omp parallel
-    {
-        processPackets((void*)&arg);
-    }
-    
-#else
-    thread_start(processPackets, (void*)&arg);
-#endif
-    thread_end_timing();
-    GOTO_REAL();
-    TIMER_T stopTime;
-    TIMER_READ(stopTime);
-    printf("Elapsed time    = %f seconds\n", TIMER_DIFF_SECONDS(startTime, stopTime));
-    printf("STAMP time = %f\n", TIMER_DIFF_SECONDS(startTime, stopTime));
-
-    /*
-     * Check solution
-     */
-
-    long numFound = 0;
-    for (i = 0; i < numThread; i++) {
-        vector_t* errorVectorPtr = errorVectors[i];
-        long e;
-        long numError = vector_getSize(errorVectorPtr);
-        numFound += numError;
-        for (e = 0; e < numError; e++) {
-            long flowId = (long)vector_at(errorVectorPtr, e);
-            bool_t status = stream_isAttack(streamPtr, flowId);
-            assert(status);
-        }
-    }
-    printf("Num found       = %li\n", numFound);
-    assert(numFound == numAttack);
-
-    /*
-     * Clean up
-     */
-
-    for (i = 0; i < numThread; i++) {
-        vector_free(errorVectors[i]);
-    }
-    free(errorVectors);
-    decoder_free(decoderPtr);
-    stream_free(streamPtr);
-    dictionary_free(dictionaryPtr);
-
-    TM_SHUTDOWN();
-    P_MEMORY_SHUTDOWN();
-
-    GOTO_SIM();
-
-    thread_shutdown();
-
-    MAIN_RETURN(0);
-}
-
-
-/* =============================================================================
- *
- * End of intruder.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/intruder.cpp stamp-g/intruder/intruder.cpp
--- stamp-0.9.10/intruder/intruder.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-g/intruder/intruder.cpp	2017-03-21 18:23:14.000000000 +0000
@@ -0,0 +1,513 @@
+/* =============================================================================
+ *
+ * intruder.c
+ *
+ * =============================================================================
+ *
+ * Copyright (C) Stanford University, 2006.  All Rights Reserved.
+ * Author: Chi Cao Minh
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+#include "Galois/Galois.h"
+#include "Galois/Bag.h"
+
+#include <assert.h>
+#include <getopt.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "decoder.h"
+#include "detector.h"
+#include "dictionary.h"
+#include "packet.h"
+#include "stream.h"
+#include "thread.h"
+#include "timer.h"
+#include "tm.h"
+
+enum param_types {
+    PARAM_ATTACK = (unsigned char)'a',
+    PARAM_LENGTH = (unsigned char)'l',
+    PARAM_NUM    = (unsigned char)'n',
+    PARAM_SEED   = (unsigned char)'s',
+    PARAM_THREAD = (unsigned char)'t',
+};
+
+enum param_defaults {
+    PARAM_DEFAULT_ATTACK = 10,
+    PARAM_DEFAULT_LENGTH = 16,
+    PARAM_DEFAULT_NUM    = 1 << 20,
+    PARAM_DEFAULT_SEED   = 1,
+    PARAM_DEFAULT_THREAD = 1,
+};
+
+long global_params[256] = { /* 256 = ascii limit */
+//    [PARAM_ATTACK] = PARAM_DEFAULT_ATTACK,
+//    [PARAM_LENGTH] = PARAM_DEFAULT_LENGTH,
+//    [PARAM_NUM]    = PARAM_DEFAULT_NUM,
+//    [PARAM_SEED]   = PARAM_DEFAULT_SEED,
+//    [PARAM_THREAD] = PARAM_DEFAULT_THREAD,
+};
+
+typedef struct arg {
+  /* input: */
+    stream_t* streamPtr;
+    decoder_t* decoderPtr;
+  /* output: */
+    vector_t** errorVectors;
+} arg_t;
+
+
+/* =============================================================================
+ * displayUsage
+ * =============================================================================
+ */
+static void
+displayUsage (const char* appName)
+{
+    printf("Usage: %s [options]\n", appName);
+    puts("\nOptions:                            (defaults)\n");
+    printf("    a <UINT>   Percent [a]ttack     (%i)\n", PARAM_DEFAULT_ATTACK);
+    printf("    l <UINT>   Max data [l]ength    (%i)\n", PARAM_DEFAULT_LENGTH);
+    printf("    n <UINT>   [n]umber of flows    (%i)\n", PARAM_DEFAULT_NUM);
+    printf("    s <UINT>   Random [s]eed        (%i)\n", PARAM_DEFAULT_SEED);
+    printf("    t <UINT>   Number of [t]hreads  (%i)\n", PARAM_DEFAULT_THREAD);
+    exit(1);
+}
+
+
+/* =============================================================================
+ * parseArgs
+ * =============================================================================
+ */
+static void
+parseArgs (long argc, char* const argv[])
+{
+    long i;
+    long opt;
+
+    opterr = 0;
+    global_params[PARAM_ATTACK] = PARAM_DEFAULT_ATTACK;
+    global_params[PARAM_LENGTH] = PARAM_DEFAULT_LENGTH;
+    global_params[PARAM_NUM]    = PARAM_DEFAULT_NUM;
+    global_params[PARAM_SEED]   = PARAM_DEFAULT_SEED;
+    global_params[PARAM_THREAD] = PARAM_DEFAULT_THREAD;
+
+    while ((opt = getopt(argc, argv, "a:l:n:s:t:")) != -1) {
+        switch (opt) {
+            case 'a':
+            case 'l':
+            case 'n':
+            case 's':
+            case 't':
+                global_params[(unsigned char)opt] = atol(optarg);
+                break;
+            case '?':
+            default:
+                opterr++;
+                break;
+        }
+    }
+
+    for (i = optind; i < argc; i++) {
+        fprintf(stderr, "Non-option argument: %s\n", argv[i]);
+        opterr++;
+    }
+
+    if (opterr) {
+        displayUsage(argv[0]);
+    }
+}
+
+struct ProcessStream {
+    typedef int tt_needs_per_iter_alloc;
+
+    Galois::InsertBag<list_t>& lists;
+    MAP_T*  fragmentedMapPtr;
+    detector_t* detectorPtr;
+    vector_t**  errorVectors;
+
+    void operator()(void* stuff, Galois::UserContext<void*>& ctx) {
+        char* bytes = (char*) stuff;
+        packet_t* packetPtr = (packet_t*)bytes;
+        long flowId = packetPtr->flowId;
+
+        intruder_error_t error;
+        error = decode_process(bytes, (PACKET_HEADER_LENGTH + packetPtr->length), ctx.getPerIterAlloc());
+        if (error) {
+            /*
+             * Currently, stream_generate() does not create these errors.
+             */
+            assert(0);
+            bool_t status = PVECTOR_PUSHBACK(errorVectors[Galois::Runtime::LL::getTID()], (void*)flowId);
+            assert(status);
+        }
+    }
+
+    intruder_error_t decode_process(char* bytes, long numByte, Galois::PerIterAllocTy& alloc);
+    void detect_process(char* data, long decodedFlowId);
+};
+
+void ProcessStream::detect_process(char* data, long decodedFlowId) {
+    intruder_error_t error = PDETECTOR_PROCESS(detectorPtr, data);
+    if (error) {
+        bool_t status = PVECTOR_PUSHBACK(errorVectors[Galois::Runtime::LL::getTID()],
+                                         (void*)decodedFlowId);
+        assert(status);
+    }
+
+    //P_FREE(data);
+}
+
+intruder_error_t
+ProcessStream::decode_process(char* bytes, long numByte, Galois::PerIterAllocTy& alloc)
+{
+    bool_t status;
+    Galois::PerIterAllocTy::rebind<char>::other charAlloc(alloc);
+
+    /*
+     * Basic error checking
+     */
+
+    if (numByte < PACKET_HEADER_LENGTH) {
+        return ERROR_SHORT;
+    }
+
+    packet_t* packetPtr = (packet_t*)bytes;
+    long flowId      = packetPtr->flowId;
+    long fragmentId  = packetPtr->fragmentId;
+    long numFragment = packetPtr->numFragment;
+    long length      = packetPtr->length;
+
+    if (flowId < 0) {
+        return ERROR_FLOWID;
+    }
+
+    if ((fragmentId < 0) || (fragmentId >= numFragment)) {
+        return ERROR_FRAGMENTID;
+    }
+
+    if (length < 0) {
+        return ERROR_LENGTH;
+    }
+
+    /*
+     * Add to fragmented map for reassembling
+     */
+
+    if (numFragment > 1) {
+        //MAP_T* fragmentedMapPtr = decoderPtr->fragmentedMapPtr;
+        list_t* fragmentListPtr =
+            (list_t*)TMMAP_FIND(fragmentedMapPtr, (void*)flowId);
+
+        if (fragmentListPtr == NULL) {
+
+            //fragmentListPtr = TMLIST_ALLOC(&packet_compareFragmentId);
+            fragmentListPtr = &lists.emplace();
+            assert(fragmentListPtr);
+            status = TMLIST_INSERT(fragmentListPtr, (void*)packetPtr);
+            assert(status);
+            status = TMMAP_INSERT(fragmentedMapPtr,
+                                  (void*)flowId,
+                                  (void*)fragmentListPtr);
+            assert(status);
+
+        } else {
+
+            list_iter_t it;
+            TMLIST_ITER_RESET(&it, fragmentListPtr);
+            assert(TMLIST_ITER_HASNEXT(&it, fragmentListPtr));
+            packet_t* firstFragmentPtr =
+                (packet_t*)TMLIST_ITER_NEXT(&it, fragmentListPtr);
+            long expectedNumFragment = firstFragmentPtr->numFragment;
+
+            if (numFragment != expectedNumFragment) {
+                status = TMMAP_REMOVE(fragmentedMapPtr, (void*)flowId);
+                assert(status);
+                return ERROR_NUMFRAGMENT;
+            }
+
+            status = TMLIST_INSERT(fragmentListPtr, (void*)packetPtr);
+            assert(status);
+
+            /*
+             * If we have all the fragments we can reassemble them
+             */
+
+            if (TMLIST_GETSIZE(fragmentListPtr) == numFragment) {
+                packet_t** fragments = (packet_t**) charAlloc.allocate(sizeof(*fragments) * numFragment);
+                memset(fragments, 0, sizeof(*fragments) * numFragment);
+
+                long numByte = 0;
+                TMLIST_ITER_RESET(&it, fragmentListPtr);
+                while (TMLIST_ITER_HASNEXT(&it, fragmentListPtr)) {
+                    packet_t* fragmentPtr = (packet_t*)TMLIST_ITER_NEXT(&it, fragmentListPtr);
+                    assert(fragmentPtr->flowId == flowId);
+                    assert(fragmentPtr->fragmentId >= 0);
+                    assert(fragmentPtr->fragmentId < numFragment);
+
+                    fragments[fragmentPtr->fragmentId] = fragmentPtr;
+                    numByte += fragmentPtr->length;
+                }
+
+                char* data = (char*)charAlloc.allocate(numByte + 1);
+                assert(data);
+                data[numByte] = '\0';
+                char* dst = data;
+                for (int i = 0; i < numFragment; ++i) {
+                    packet_t* fragmentPtr = fragments[i];
+                    memcpy(dst, fragmentPtr->data, fragmentPtr->length);
+                    dst += fragmentPtr->length;
+                }
+                assert(dst == data + numByte);
+
+                //TMLIST_FREE(fragmentListPtr);
+                status = TMMAP_REMOVE(fragmentedMapPtr, (void*)flowId);
+                assert(status);
+
+                detect_process(data, flowId);
+            }
+
+        }
+
+    } else {
+
+        /*
+         * This is the only fragment, so it is ready
+         */
+
+        if (fragmentId != 0) {
+            return ERROR_FRAGMENTID;
+        }
+
+        char* data = (char*)charAlloc.allocate(length + 1);
+        assert(data);
+        data[length] = '\0';
+        memcpy(data, packetPtr->data, length);
+
+#if 0
+        decoded_t* decodedPtr = (decoded_t*)TM_MALLOC(sizeof(decoded_t));
+        assert(decodedPtr);
+        decodedPtr->flowId = flowId;
+        decodedPtr->data = data;
+
+        queue_t* decodedQueuePtr = decoderPtr->decodedQueuePtr;
+        status = TMQUEUE_PUSH(decodedQueuePtr, (void*)decodedPtr);
+        assert(status);
+#endif
+        detect_process(data, flowId);
+    }
+
+    return ERROR_NONE;
+}
+
+/* =============================================================================
+ * processPackets
+ * =============================================================================
+ */
+void
+processPackets (void* argPtr)
+{
+    TM_THREAD_ENTER();
+
+    stream_t*   streamPtr    = ((arg_t*)argPtr)->streamPtr;
+    decoder_t*  decoderPtr   = ((arg_t*)argPtr)->decoderPtr;
+    vector_t**  errorVectors = ((arg_t*)argPtr)->errorVectors;
+    
+    detector_t* detectorPtr = detector_alloc();
+    assert(detectorPtr);
+    detector_addPreprocessor(detectorPtr, &preprocessor_toLower);
+
+    Galois::InsertBag<list_t> lists;
+    ProcessStream ps = { lists, decoder_getMap(decoderPtr), detectorPtr, errorVectors };
+    Galois::for_each(stream_getList(streamPtr)->begin(), stream_getList(streamPtr)->end(), ps, Galois::wl<Galois::WorkList::dChunkedFIFO<512> >());
+
+    detector_free(detectorPtr);
+
+    TM_THREAD_EXIT();
+}
+
+
+/* =============================================================================
+ * main
+ * =============================================================================
+ */
+MAIN(argc, argv)
+{
+    GOTO_REAL();
+
+    /*
+     * Initialization
+     */
+
+    parseArgs(argc, (char** const)argv);
+    long numThread = global_params[PARAM_THREAD];
+    SIM_GET_NUM_CPU(numThread);
+    TM_STARTUP(numThread);
+    P_MEMORY_STARTUP(numThread);
+    thread_startup(numThread);
+
+    long percentAttack = global_params[PARAM_ATTACK];
+    long maxDataLength = global_params[PARAM_LENGTH];
+    long numFlow       = global_params[PARAM_NUM];
+    long randomSeed    = global_params[PARAM_SEED];
+    printf("Percent attack  = %li\n", percentAttack);
+    printf("Max data length = %li\n", maxDataLength);
+    printf("Num flow        = %li\n", numFlow);
+    printf("Random seed     = %li\n", randomSeed);
+
+    dictionary_t* dictionaryPtr = dictionary_alloc();
+    assert(dictionaryPtr);
+    stream_t* streamPtr = stream_alloc(percentAttack);
+    assert(streamPtr);
+    long numAttack = stream_generate(streamPtr,
+                                     dictionaryPtr,
+                                     numFlow,
+                                     randomSeed,
+                                     maxDataLength);
+    printf("Num attack      = %li\n", numAttack);
+
+    decoder_t* decoderPtr = decoder_alloc();
+    assert(decoderPtr);
+
+    vector_t** errorVectors = (vector_t**)malloc(numThread * sizeof(vector_t*));
+    assert(errorVectors);
+    long i;
+    for (i = 0; i < numThread; i++) {
+        vector_t* errorVectorPtr = vector_alloc(numFlow);
+        assert(errorVectorPtr);
+        errorVectors[i] = errorVectorPtr;
+    }
+
+    arg_t arg;
+    arg.streamPtr    = streamPtr;
+    arg.decoderPtr   = decoderPtr;
+    arg.errorVectors = errorVectors;
+
+    /*
+     * Run transactions
+     */
+
+    TIMER_T startTime;
+    TIMER_READ(startTime);
+    GOTO_SIM();
+    thread_begin_timing();
+    processPackets((void*)&arg);
+    thread_end_timing();
+    GOTO_REAL();
+    TIMER_T stopTime;
+    TIMER_READ(stopTime);
+    printf("Elapsed time    = %f seconds\n", TIMER_DIFF_SECONDS(startTime, stopTime));
+
+    /*
+     * Check solution
+     */
+
+    long numFound = 0;
+    for (i = 0; i < numThread; i++) {
+        vector_t* errorVectorPtr = errorVectors[i];
+        long e;
+        list_iter_t it;
+        list_iter_reset(&it, errorVectorPtr);
+        //long numError = vector_getSize(errorVectorPtr);
+        //numFound += numError;
+        for (e = 0; 1 /*e < numError*/; e++) {
+            if (!list_iter_hasNext(&it, errorVectorPtr))
+              break;
+
+            long flowId = (long) list_iter_next(&it, errorVectorPtr); //vector_at(errorVectorPtr, e);
+            bool_t status = stream_isAttack(streamPtr, flowId);
+            numFound += 1;
+            assert(status);
+        }
+    }
+    printf("Num found       = %li\n", numFound);
+    assert(numFound == numAttack);
+
+    /*
+     * Clean up
+     */
+
+    for (i = 0; i < numThread; i++) {
+        vector_free(errorVectors[i]);
+    }
+    free(errorVectors);
+    decoder_free(decoderPtr);
+    stream_free(streamPtr);
+    dictionary_free(dictionaryPtr);
+
+    TM_SHUTDOWN();
+    P_MEMORY_SHUTDOWN();
+
+    GOTO_SIM();
+
+    thread_shutdown();
+
+    MAIN_RETURN(0);
+}
+
+
+/* =============================================================================
+ *
+ * End of intruder.c
+ *
+ * =============================================================================
+ */
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/packet.h stamp-g/intruder/packet.h
--- stamp-0.9.10/intruder/packet.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/intruder/packet.h	2017-03-20 15:19:41.000000000 +0000
@@ -72,6 +72,9 @@
 #ifndef PACKET_H
 #define PACKET_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef struct packet {
     long flowId;
@@ -100,6 +103,9 @@
 long
 packet_compareFragmentId (const void* aPtr, const void* bPtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* PACKET_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/preprocessor.h stamp-g/intruder/preprocessor.h
--- stamp-0.9.10/intruder/preprocessor.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/intruder/preprocessor.h	2017-03-20 15:19:41.000000000 +0000
@@ -72,6 +72,10 @@
 #ifndef PREPROCESSOR_H
 #define PREPROCESSOR_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 /*
  * All preprocessors should update in place
  */
@@ -95,6 +99,9 @@
 void
 preprocessor_toLower (char* str);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* PREPROCESSOR_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/stream.c stamp-g/intruder/stream.c
--- stamp-0.9.10/intruder/stream.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/intruder/stream.c	2017-03-21 18:23:38.000000000 +0000
@@ -129,10 +129,15 @@
 {
     vector_t* allocVectorPtr = streamPtr->allocVectorPtr;
     long a;
-    long numAlloc = vector_getSize(allocVectorPtr);
+    list_iter_t it;
+    list_iter_reset(&it, allocVectorPtr);
+    //long numAlloc = vector_getSize(allocVectorPtr);
+
+    for (a = 0; 1 /*a < numAlloc*/; a++) {
+        if (!list_iter_hasNext(&it, allocVectorPtr))
+          break;
 
-    for (a = 0; a < numAlloc; a++) {
-        char* str = (char*)vector_at(allocVectorPtr, a);
+        char* str = (char*) list_iter_next(&it, allocVectorPtr); //vector_at(allocVectorPtr, a);
         free(str);
     }
 
@@ -252,7 +257,7 @@
             char* str2 = (char*)malloc((length + 1) * sizeof(char));
             assert(str2);
             strcpy(str2, str);
-            error_t error = detector_process(detectorPtr, str2); /* updates in-place */
+            intruder_error_t error = detector_process(detectorPtr, str2); /* updates in-place */
             if (error == ERROR_SIGNATURE) {
                 bool_t status = MAP_INSERT(attackMapPtr,
                                            (void*)f,
@@ -293,9 +298,16 @@
 char*
 TMstream_getPacket (TM_ARGDECL stream_t* streamPtr)
 {
-    return (char*)TMQUEUE_POP(streamPtr->packetQueuePtr);
+    //return (char*)TMQUEUE_POP(streamPtr->packetQueuePtr);
+    abort();
+    return 0;
 }
 
+list_t*
+stream_getList(stream_t* streamPtr)
+{
+    return streamPtr->packetQueuePtr;
+}
 
 /* =============================================================================
  * stream_isAttack
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/stream.h stamp-g/intruder/stream.h
--- stamp-0.9.10/intruder/stream.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/intruder/stream.h	2017-03-20 15:19:41.000000000 +0000
@@ -72,9 +72,14 @@
 #ifndef STREAM_H
 #define STREAM_H 1
 
+#include "list.h"
 #include "dictionary.h"
 #include "tm.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct stream stream_t;
 
 
@@ -116,6 +121,9 @@
 stream_getPacket (stream_t* streamPtr);
 
 
+list_t*
+stream_getList (stream_t* streamPtr);
+
 /* =============================================================================
  * TMstream_getPacket
  * -- If none, returns NULL
@@ -135,6 +143,10 @@
 
 #define TMSTREAM_GETPACKET(s)           TMstream_getPacket(TM_ARG  s)
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* STREAM_H */
 
 
diff -x .git -x inputs -Naur stamp-0.9.10/kmeans/CMakeLists.txt stamp-g/kmeans/CMakeLists.txt
--- stamp-0.9.10/kmeans/CMakeLists.txt	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/kmeans/CMakeLists.txt	2017-03-20 15:19:41.000000000 +0000
@@ -10,10 +10,10 @@
 	cluster.c
 	common.c
 	kmeans.c
-	normal.c 
+	normal.cpp
 	${LIB_DIR}/mt19937ar.c 
 	${LIB_DIR}/random.c 
-	${LIB_DIR}/thread.c)
+	${LIB_DIR}/thread.cpp)
 
 app(kmeans ${sources})
 
diff -x .git -x inputs -Naur stamp-0.9.10/kmeans/cluster.h stamp-g/kmeans/cluster.h
--- stamp-0.9.10/kmeans/cluster.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/kmeans/cluster.h	2017-03-20 15:19:41.000000000 +0000
@@ -67,6 +67,9 @@
 #ifndef CLUSTER_H
 #define CLUSTER_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 /* =============================================================================
  * cluster_exec
@@ -87,6 +90,9 @@
     int*     cluster_assign       /* out: [numObjects] */
 );
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* CLUSTER_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/kmeans/common.h stamp-g/kmeans/common.h
--- stamp-0.9.10/kmeans/common.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/kmeans/common.h	2017-03-20 15:19:41.000000000 +0000
@@ -67,6 +67,9 @@
 #ifndef COMMON_H
 #define COMMON_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 #ifndef FLT_MAX
 #  define FLT_MAX 3.40282347e+38
@@ -93,6 +96,10 @@
                          int     npts);
 
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* COMMON_H */
 
 
diff -x .git -x inputs -Naur stamp-0.9.10/kmeans/kmeans.c stamp-g/kmeans/kmeans.c
--- stamp-0.9.10/kmeans/kmeans.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/kmeans/kmeans.c	2017-03-21 18:24:24.000000000 +0000
@@ -383,7 +383,7 @@
     }
 #endif
 
-#if 1
+#if 0
     {
       float sum = 0.0;
       for (i = 0; i < numObjects; i++) {
diff -x .git -x inputs -Naur stamp-0.9.10/kmeans/normal.c stamp-g/kmeans/normal.c
--- stamp-0.9.10/kmeans/normal.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/kmeans/normal.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,339 +0,0 @@
-/* =============================================================================
- *
- * normal.c
- * -- Implementation of normal k-means clustering algorithm
- *
- * =============================================================================
- *
- * Author:
- *
- * Wei-keng Liao
- * ECE Department, Northwestern University
- * email: wkliao@ece.northwestern.edu
- *
- *
- * Edited by:
- *
- * Jay Pisharath
- * Northwestern University.
- *
- * Chi Cao Minh
- * Stanford University
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <float.h>
-#include <math.h>
-#include "common.h"
-#include "normal.h"
-#include "random.h"
-#include "thread.h"
-#include "timer.h"
-#include "tm.h"
-#include "util.h"
-
-double global_time = 0.0;
-
-typedef struct NewCentersLen {
-  XTM_DECL_LOCKABLE(long, value);
-} NewCentersLen;
-
-typedef struct NewCenters {
-  XTM_DECL_LOCKABLE(float, value1);
-} NewCenters;
-
-typedef struct args {
-    float** feature;
-    int     nfeatures;
-    int     npoints;
-    int     nclusters;
-    int*    membership;
-    float** clusters;
-    NewCentersLen**   new_centers_len;
-    NewCenters** new_centers;
-} args_t;
-
-XTM_DECL_LOCKABLE(float, global_delta);
-XTM_DECL_LOCKABLE(long, global_i); /* index into task queue */
-
-#define CHUNK 3
-
-
-/* =============================================================================
- * work
- * =============================================================================
- */
-static void
-work (void* argPtr)
-{
-    TM_THREAD_ENTER();
-
-    args_t* args = (args_t*)argPtr;
-    float** feature         = args->feature;
-    int     nfeatures       = args->nfeatures;
-    int     npoints         = args->npoints;
-    int     nclusters       = args->nclusters;
-    int*    membership      = args->membership;
-    float** clusters        = args->clusters;
-    NewCentersLen**   new_centers_len = args->new_centers_len;
-    NewCenters** new_centers     = args->new_centers;
-    float delta = 0.0;
-    int index;
-    int i;
-    int j;
-    long start;
-    int stop;
-    int myId;
-
-    myId = thread_getId();
-
-    start = myId * CHUNK;
-
-    while (start < npoints) {
-        stop = (((start + CHUNK) < npoints) ? (start + CHUNK) : npoints);
-        for (i = start; i < stop; i++) {
-
-            index = common_findNearestPoint(feature[i],
-                                            nfeatures,
-                                            clusters,
-                                            nclusters);
-            /*
-             * If membership changes, increase delta by 1.
-             * membership[i] cannot be changed by other threads
-             */
-            if (membership[i] != index) {
-                delta += 1.0;
-            }
-
-            /* Assign the membership to object i */
-            /* membership[i] can't be changed by other thread */
-            membership[i] = index;
-
-            /* Update new cluster centers : sum of objects located within */
-            TM_BEGIN();
-            TM_SHARED_WRITE(new_centers_len[index]->value,
-                            TM_SHARED_READ(new_centers_len[index]->value) + 1);
-            for (j = 0; j < nfeatures; j++) {
-                TM_SHARED_WRITE_F(
-                    new_centers[index][j].value1,
-                    (TM_SHARED_READ_F(new_centers[index][j].value1) + feature[i][j])
-                );
-            }
-            TM_END();
-        }
-
-        /* Update task queue */
-        if (start + CHUNK < npoints) {
-            TM_BEGIN();
-            start = TM_SHARED_READ(global_i);
-            TM_SHARED_WRITE(global_i, (start + CHUNK));
-            TM_END();
-        } else {
-            break;
-        }
-    }
-
-    TM_BEGIN();
-    TM_SHARED_WRITE_F(global_delta, TM_SHARED_READ_F(global_delta) + delta);
-    TM_END();
-
-    TM_THREAD_EXIT();
-}
-
-
-/* =============================================================================
- * normal_exec
- * =============================================================================
- */
-float**
-normal_exec (int       nthreads,
-             float**   feature,    /* in: [npoints][nfeatures] */
-             int       nfeatures,
-             int       npoints,
-             int       nclusters,
-             float     threshold,
-             int*      membership,
-             random_t* randomPtr) /* out: [npoints] */
-{
-    int i;
-    int j;
-    int loop = 0;
-    NewCentersLen** new_centers_len; /* [nclusters]: no. of points in each cluster */
-    float delta;
-    float** clusters;      /* out: [nclusters][nfeatures] */
-    NewCenters** new_centers;   /* [nclusters][nfeatures] */
-    void* alloc_memory = NULL;
-    args_t args;
-    TIMER_T start;
-    TIMER_T stop;
-
-    /* Allocate space for returning variable clusters[] */
-    clusters = (float**)malloc(nclusters * sizeof(*clusters));
-    assert(clusters);
-    clusters[0] = (float*)malloc(nclusters * nfeatures * sizeof(**clusters));
-    assert(clusters[0]);
-    for (i = 1; i < nclusters; i++) {
-        clusters[i] = clusters[i-1] + nfeatures;
-    }
-
-    /* Randomly pick cluster centers */
-    for (i = 0; i < nclusters; i++) {
-        int n = (int)(random_generate(randomPtr) % npoints);
-        for (j = 0; j < nfeatures; j++) {
-            clusters[i][j] = feature[n][j];
-        }
-    }
-
-    for (i = 0; i < npoints; i++) {
-        membership[i] = -1;
-    }
-
-    /*
-     * Need to initialize new_centers_len and new_centers[0] to all 0.
-     * Allocate clusters on different cache lines to reduce false sharing.
-     */
-    {
-        int cluster_size = sizeof(NewCentersLen) + sizeof(NewCenters) * nfeatures;
-        const int cacheLineSize = 32;
-        cluster_size += (cacheLineSize-1) - ((cluster_size-1) % cacheLineSize);
-        alloc_memory = calloc(nclusters, cluster_size);
-        new_centers_len = (NewCentersLen**) malloc(nclusters * sizeof(long*));
-        new_centers = (NewCenters**) malloc(nclusters * sizeof(float*));
-        assert(alloc_memory && new_centers && new_centers_len);
-        for (i = 0; i < nclusters; i++) {
-            new_centers_len[i] = (NewCentersLen*)((char*)alloc_memory + cluster_size * i);
-            new_centers[i] = (NewCenters*)((char*)alloc_memory + cluster_size * i + sizeof(NewCentersLen));
-        }
-    }
-
-    TIMER_READ(start);
-
-    GOTO_SIM();
-    thread_begin_timing();
-
-    do {
-        delta = 0.0;
-
-        args.feature         = feature;
-        args.nfeatures       = nfeatures;
-        args.npoints         = npoints;
-        args.nclusters       = nclusters;
-        args.membership      = membership;
-        args.clusters        = clusters;
-        args.new_centers_len = new_centers_len;
-        args.new_centers     = new_centers;
-
-        XTM_LOCKABLE_VALUE(global_i) = nthreads * CHUNK;
-        XTM_LOCKABLE_INIT(global_i);
-        XTM_LOCKABLE_VALUE(global_delta) = delta;
-        XTM_LOCKABLE_INIT(global_delta);
-
-#ifdef OTM
-#pragma omp parallel
-        {
-            work(&args);
-        }
-#else
-        thread_start(work, &args);
-#endif
-
-        delta = XTM_LOCKABLE_VALUE(global_delta);
-
-        /* Replace old cluster centers with new_centers */
-        for (i = 0; i < nclusters; i++) {
-            for (j = 0; j < nfeatures; j++) {
-                if (new_centers_len[i] > 0) {
-                    clusters[i][j] = XTM_LOCKABLE_VALUE(new_centers[i][j].value1) / XTM_LOCKABLE_VALUE(new_centers_len[i]->value);
-                }
-                XTM_LOCKABLE_VALUE(new_centers[i][j].value1) = 0.0;   /* set back to 0 */
-            }
-            XTM_LOCKABLE_VALUE(new_centers_len[i]->value) = 0;   /* set back to 0 */
-        }
-
-        delta /= npoints;
-
-    } while ((delta > threshold) && (loop++ < 500));
-
-    thread_end_timing();
-    GOTO_REAL();
-
-    TIMER_READ(stop);
-    global_time += TIMER_DIFF_SECONDS(start, stop);
-
-    free(alloc_memory);
-    free(new_centers);
-    free(new_centers_len);
-
-    return clusters;
-}
-
-
-/* =============================================================================
- *
- * End of normal.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/kmeans/normal.cpp stamp-g/kmeans/normal.cpp
--- stamp-0.9.10/kmeans/normal.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-g/kmeans/normal.cpp	2017-03-21 18:25:28.000000000 +0000
@@ -0,0 +1,360 @@
+/* =============================================================================
+ *
+ * normal.c
+ * -- Implementation of normal k-means clustering algorithm
+ *
+ * =============================================================================
+ *
+ * Author:
+ *
+ * Wei-keng Liao
+ * ECE Department, Northwestern University
+ * email: wkliao@ece.northwestern.edu
+ *
+ *
+ * Edited by:
+ *
+ * Jay Pisharath
+ * Northwestern University.
+ *
+ * Chi Cao Minh
+ * Stanford University
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+
+#include "Galois/Galois.h"
+#include "Galois/Accumulator.h"
+#include <boost/iterator/counting_iterator.hpp>
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <float.h>
+#include <math.h>
+#include "common.h"
+#include "normal.h"
+#include "random.h"
+#include "thread.h"
+#include "timer.h"
+#include "tm.h"
+#include "util.h"
+
+double global_time = 0.0;
+
+typedef struct args {
+    float** feature;
+    int     nfeatures;
+    int     npoints;
+    int     nclusters;
+    int*    membership;
+    float** clusters;
+    int**   new_centers_len;
+    float** new_centers;
+    Galois::Runtime::Lockable* locks;
+} args_t;
+
+float global_delta;
+long global_i; /* index into task queue */
+
+#define CHUNK 3
+
+
+/* =============================================================================
+ * work
+ * =============================================================================
+ */
+struct Fn1 {
+    args_t* args;
+    Galois::GAccumulator<float>& accum;
+
+
+    void operator()(long i, Galois::UserContext<long>& ctx) {
+        TM_THREAD_ENTER();
+        int     npoints         = args->npoints;
+        int phase = i < npoints ? 0 : 1;
+        switch (phase) {
+            case 0: findIndex(i, ctx); break;
+            case 1: updateCenters(i - npoints); break;
+            default: abort();
+        }
+    }
+
+    void findIndex(long i, Galois::UserContext<long>& ctx) {
+        float** feature         = args->feature;
+        int     nfeatures       = args->nfeatures;
+        int     npoints         = args->npoints;
+        int     nclusters       = args->nclusters;
+        int*    membership      = args->membership;
+        float** clusters        = args->clusters;
+        int**   new_centers_len = args->new_centers_len;
+        float** new_centers     = args->new_centers;
+        float delta = 0.0;
+        int index;
+        int j;
+
+        index = common_findNearestPoint(feature[i],
+                                        nfeatures,
+                                        clusters,
+                                        nclusters);
+
+        /*
+         * If membership changes, increase delta by 1.
+         * membership[i] cannot be changed by other threads
+         */
+        if (membership[i] != index) {
+            delta += 1.0;
+        }
+
+        accum.update(delta);
+
+        /* Assign the membership to object i */
+        /* membership[i] can't be changed by other thread */
+        membership[i] = index;
+        ctx.push(i + npoints);
+    }
+
+    void updateCenters(long i) {
+        float** feature         = args->feature;
+        int     nfeatures       = args->nfeatures;
+        int     npoints         = args->npoints;
+        int     nclusters       = args->nclusters;
+        int*    membership      = args->membership;
+        float** clusters        = args->clusters;
+        int**   new_centers_len = args->new_centers_len;
+        float** new_centers     = args->new_centers;
+        Galois::Runtime::Lockable *locks = args->locks;
+        float delta = 0.0;
+        int index;
+        int j;
+
+        index = membership[i];
+#ifndef HTM 
+        Galois::Runtime::acquire(&locks[index], Galois::MethodFlag::ALL);
+#endif
+
+        /* Update new cluster centers : sum of objects located within */
+        TM_BEGIN();
+        TM_SHARED_WRITE(*new_centers_len[index],
+                        TM_SHARED_READ(*new_centers_len[index]) + 1);
+        for (j = 0; j < nfeatures; j++) {
+            TM_SHARED_WRITE_F(
+                new_centers[index][j],
+                (TM_SHARED_READ_F(new_centers[index][j]) + feature[i][j])
+            );
+        }
+        TM_END();
+    }
+};
+
+static void
+work (void* argPtr)
+{
+  args_t* args = (args_t*)argPtr;
+  Galois::GAccumulator<float> accum;
+
+  Fn1 fn1 = { args, accum };
+
+  int     npoints         = args->npoints;
+
+  Galois::for_each(
+      boost::counting_iterator<long>(0),
+      boost::counting_iterator<long>(npoints),
+      fn1, Galois::wl<Galois::WorkList::LocalQueue<>::with_local<Galois::WorkList::GFIFO<> >::type >());
+  global_delta += accum.reduce();
+}
+
+
+/* =============================================================================
+ * normal_exec
+ * =============================================================================
+ */
+float**
+normal_exec (int       nthreads,
+             float**   feature,    /* in: [npoints][nfeatures] */
+             int       nfeatures,
+             int       npoints,
+             int       nclusters,
+             float     threshold,
+             int*      membership,
+             random_t* randomPtr) /* out: [npoints] */
+{
+    int i;
+    int j;
+    int loop = 0;
+    int** new_centers_len; /* [nclusters]: no. of points in each cluster */
+    float delta;
+    float** clusters;      /* out: [nclusters][nfeatures] */
+    float** new_centers;   /* [nclusters][nfeatures] */
+    void* alloc_memory = NULL;
+    Galois::Runtime::Lockable* locks = NULL;
+
+    args_t args;
+    TIMER_T start;
+    TIMER_T stop;
+
+    /* Allocate space for returning variable clusters[] */
+    clusters = (float**)malloc(nclusters * sizeof(float*));
+    assert(clusters);
+    clusters[0] = (float*)malloc(nclusters * nfeatures * sizeof(float));
+    assert(clusters[0]);
+    for (i = 1; i < nclusters; i++) {
+        clusters[i] = clusters[i-1] + nfeatures;
+    }
+
+    /* Randomly pick cluster centers */
+    for (i = 0; i < nclusters; i++) {
+        int n = (int)(random_generate(randomPtr) % npoints);
+        for (j = 0; j < nfeatures; j++) {
+            clusters[i][j] = feature[n][j];
+        }
+    }
+
+    for (i = 0; i < npoints; i++) {
+        membership[i] = -1;
+    }
+
+    /*
+     * Need to initialize new_centers_len and new_centers[0] to all 0.
+     * Allocate clusters on different cache lines to reduce false sharing.
+     */
+    {
+        int cluster_size = sizeof(int) + sizeof(float) * nfeatures;
+        const int cacheLineSize = 32;
+        cluster_size += (cacheLineSize-1) - ((cluster_size-1) % cacheLineSize);
+        alloc_memory = calloc(nclusters, cluster_size);
+        new_centers_len = (int**) malloc(nclusters * sizeof(int*));
+        new_centers = (float**) malloc(nclusters * sizeof(float*));
+#ifndef HTM
+        locks = (Galois::Runtime::Lockable*) malloc(nclusters * sizeof(*locks));
+#endif
+        assert(alloc_memory && new_centers && new_centers_len);
+        for (i = 0; i < nclusters; i++) {
+            new_centers_len[i] = (int*)((char*)alloc_memory + cluster_size * i);
+            new_centers[i] = (float*)((char*)alloc_memory + cluster_size * i + sizeof(int));
+#ifndef HTM
+            new (&locks[i]) Galois::Runtime::Lockable;
+#endif
+        }
+    }
+
+
+    GOTO_SIM();
+    thread_begin_timing();
+    TIMER_READ(start);
+
+    do {
+        delta = 0.0;
+
+        args.feature         = feature;
+        args.nfeatures       = nfeatures;
+        args.npoints         = npoints;
+        args.nclusters       = nclusters;
+        args.membership      = membership;
+        args.clusters        = clusters;
+        args.new_centers_len = new_centers_len;
+        args.new_centers     = new_centers;
+        args.locks           = locks;
+
+        global_i = nthreads * CHUNK;
+        global_delta = delta;
+
+        work(&args);
+
+        delta = global_delta;
+
+        /* Replace old cluster centers with new_centers */
+        for (i = 0; i < nclusters; i++) {
+            for (j = 0; j < nfeatures; j++) {
+                if (new_centers_len[i] > 0) {
+                    clusters[i][j] = new_centers[i][j] / *new_centers_len[i];
+                }
+                new_centers[i][j] = 0.0;   /* set back to 0 */
+            }
+            *new_centers_len[i] = 0;   /* set back to 0 */
+        }
+
+        delta /= npoints;
+
+    } while ((delta > threshold) && (loop++ < 500));
+
+    TIMER_READ(stop);
+    thread_end_timing();
+    GOTO_REAL();
+
+    global_time += TIMER_DIFF_SECONDS(start, stop);
+
+    free(alloc_memory);
+    free(new_centers);
+    free(new_centers_len);
+    if (locks)
+        free(locks);
+
+    return clusters;
+}
+
+
+/* =============================================================================
+ *
+ * End of normal.c
+ *
+ * =============================================================================
+ */
diff -x .git -x inputs -Naur stamp-0.9.10/kmeans/normal.h stamp-g/kmeans/normal.h
--- stamp-0.9.10/kmeans/normal.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/kmeans/normal.h	2017-03-20 15:19:41.000000000 +0000
@@ -71,6 +71,9 @@
 
 #include "random.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 extern double global_parallelTime;
 
@@ -89,6 +92,9 @@
              int*      membership,
              random_t* randomPtr); /* out: [npoints] */
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* NORMAL_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/kmeans/util.h stamp-g/kmeans/util.h
--- stamp-0.9.10/kmeans/util.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/kmeans/util.h	2017-03-20 15:19:41.000000000 +0000
@@ -66,9 +66,15 @@
 #ifndef UTIL_H
 #define UTIL_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 #define SQR(x) ((x)*(x))
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* UTIL_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/labyrinth/CMakeLists.txt stamp-g/labyrinth/CMakeLists.txt
--- stamp-0.9.10/labyrinth/CMakeLists.txt	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/labyrinth/CMakeLists.txt	2017-03-21 18:25:43.000000000 +0000
@@ -4,24 +4,26 @@
 #
 # ==============================================================================
 
-add_definitions(-DUSE_EARLY_RELEASE)
+#add_definitions(-DUSE_EARLY_RELEASE)
 
 set(sources
 	coordinate.c 
-	grid.c 
+	grid.cpp 
 	labyrinth.c 
 	maze.c 
-	router.c 
-	${LIB_DIR}/list.c 
+	router.cpp 
+        #${LIB_DIR}/list.c
+        ${LIB_DIR}/deque.cpp 
 	${LIB_DIR}/mt19937ar.c 
-	${LIB_DIR}/pair.c 
-	${LIB_DIR}/queue.c 
+        ${LIB_DIR}/pair.c 
+        #${LIB_DIR}/queue.c 
 	${LIB_DIR}/random.c 
-	${LIB_DIR}/thread.c
-	${LIB_DIR}/vector.c)
+	${LIB_DIR}/thread.cpp
+        #${LIB_DIR}/vector.c
+        )
 
 app(labyrinth ${sources})
-target_link_libraries(labyrinth m)
+target_link_libraries(labyrinthg m)
 
 # ==============================================================================
 #
diff -x .git -x inputs -Naur stamp-0.9.10/labyrinth/coordinate.h stamp-g/labyrinth/coordinate.h
--- stamp-0.9.10/labyrinth/coordinate.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/labyrinth/coordinate.h	2017-03-20 15:19:41.000000000 +0000
@@ -76,6 +76,10 @@
 #include "tm.h"
 #include "types.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct coordinate {
     long x;
     long y;
@@ -123,6 +127,9 @@
 bool_t
 coordinate_areAdjacent (coordinate_t* aPtr, coordinate_t* bPtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* COORDINATE_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/labyrinth/grid.c stamp-g/labyrinth/grid.c
--- stamp-0.9.10/labyrinth/grid.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/labyrinth/grid.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,370 +0,0 @@
-/* =============================================================================
- *
- * grid.c
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <stdint.h>
-#include "coordinate.h"
-#include "grid.h"
-#include "tm.h"
-#include "types.h"
-#include "vector.h"
-
-
-const unsigned long CACHE_LINE_SIZE = 32UL;
-
-
-/* =============================================================================
- * grid_alloc
- * =============================================================================
- */
-grid_t*
-grid_alloc (long width, long height, long depth)
-{
-    grid_t* gridPtr;
-
-    gridPtr = (grid_t*)malloc(sizeof(grid_t));
-    if (gridPtr) {
-        gridPtr->width  = width;
-        gridPtr->height = height;
-        gridPtr->depth  = depth;
-        long n = width * height * depth;
-        grid_point* points_unaligned = (grid_point*)malloc(n * sizeof(grid_point) + CACHE_LINE_SIZE);
-        assert(points_unaligned);
-        gridPtr->points_unaligned = points_unaligned;
-        gridPtr->points = (grid_point*)((char*)(((uintptr_t)points_unaligned
-                                          & ~(CACHE_LINE_SIZE-1)))
-                                  + CACHE_LINE_SIZE);
-        //memset(gridPtr->points, GRID_POINT_EMPTY, (n * sizeof(long)));
-        for (long i = 0; i < n; ++i) {
-          XTM_LOCKABLE_VALUE(gridPtr->points[i].value) = GRID_POINT_EMPTY;
-          XTM_LOCKABLE_INIT(gridPtr->points[i].value);
-        }
-    }
-
-    return gridPtr;
-}
-
-
-/* =============================================================================
- * Pgrid_alloc
- * =============================================================================
- */
-grid_t*
-Pgrid_alloc (long width, long height, long depth)
-{
-    grid_t* gridPtr;
-
-    gridPtr = (grid_t*)P_MALLOC(sizeof(grid_t));
-    if (gridPtr) {
-        gridPtr->width  = width;
-        gridPtr->height = height;
-        gridPtr->depth  = depth;
-        long n = width * height * depth;
-        grid_point* points_unaligned = (grid_point*)P_MALLOC(n * sizeof(grid_point) + CACHE_LINE_SIZE);
-        assert(points_unaligned);
-        gridPtr->points_unaligned = points_unaligned;
-        gridPtr->points = (grid_point*)((char*)(((uintptr_t)points_unaligned
-                                          & ~(CACHE_LINE_SIZE-1)))
-                                  + CACHE_LINE_SIZE);
-        //memset(gridPtr->points, GRID_POINT_EMPTY, (n * sizeof(long)));
-        for (long i = 0; i < n; ++i) {
-          XTM_LOCKABLE_VALUE(gridPtr->points[i].value) = GRID_POINT_EMPTY;
-          XTM_LOCKABLE_INIT(gridPtr->points[i].value);
-        }
-    }
-
-    return gridPtr;
-}
-
-
-/* =============================================================================
- * grid_free
- * =============================================================================
- */
-void
-grid_free (grid_t* gridPtr)
-{
-    free(gridPtr->points_unaligned);
-    free(gridPtr);
-}
-
-
-/* =============================================================================
- * TMgrid_free
- * =============================================================================
- */
-void
-Pgrid_free (grid_t* gridPtr)
-{
-    P_FREE(gridPtr->points_unaligned);
-    P_FREE(gridPtr);
-}
-
-
-/* =============================================================================
- * grid_copy
- * =============================================================================
- */
-void
-grid_copy (grid_t* dstGridPtr, grid_t* srcGridPtr)
-{
-    assert(srcGridPtr->width  == dstGridPtr->width);
-    assert(srcGridPtr->height == dstGridPtr->height);
-    assert(srcGridPtr->depth  == dstGridPtr->depth);
-
-    long n = srcGridPtr->width * srcGridPtr->height * srcGridPtr->depth;
-    //memcpy(dstGridPtr->points, srcGridPtr->points, (n * sizeof(*dstGridPtr->points)));
-    for (long i = 0; i < n; ++i) {
-      XTM_LOCKABLE_VALUE(dstGridPtr->points[i].value) = XTM_LOCKABLE_VALUE(srcGridPtr->points[i].value);
-    }
-
-#ifdef USE_EARLY_RELEASE
-    grid_point* srcPoints = srcGridPtr->points;
-    long i;
-    long i_step = (CACHE_LINE_SIZE / sizeof(srcPoints[0]));
-    for (i = 0; i < n; i+=i_step) {
-        TM_EARLY_RELEASE(srcPoints[i]); /* releases entire line */
-    }
-#endif
-}
-
-
-/* =============================================================================
- * grid_isPointValid
- * =============================================================================
- */
-bool_t
-grid_isPointValid (grid_t* gridPtr, long x, long y, long z)
-{
-    if (x < 0 || x >= gridPtr->width  ||
-        y < 0 || y >= gridPtr->height ||
-        z < 0 || z >= gridPtr->depth)
-    {
-        return FALSE;
-    }
-
-    return TRUE;
-}
-
-
-/* =============================================================================
- * grid_getPointRef
- * =============================================================================
- */
-long*
-grid_getPointRef (grid_t* gridPtr, long x, long y, long z)
-{
-    return &XTM_LOCKABLE_VALUE(gridPtr->points[(z * gridPtr->height + y) * gridPtr->width + x].value);
-}
-
-
-/* =============================================================================
- * grid_getPointIndices
- * =============================================================================
- */
-void
-grid_getPointIndices (grid_t* gridPtr,
-                      long* gridPointPtr, long* xPtr, long* yPtr, long* zPtr)
-{
-    long height = gridPtr->height;
-    long width  = gridPtr->width;
-    long area = height * width;
-    long index3d = (((grid_point*)gridPointPtr) - gridPtr->points);
-    (*zPtr) = index3d / area;
-    long index2d = index3d % area;
-    (*yPtr) = index2d / width;
-    (*xPtr) = index2d % width;
-}
-
-
-/* =============================================================================
- * grid_getPoint
- * =============================================================================
- */
-long
-grid_getPoint (grid_t* gridPtr, long x, long y, long z)
-{
-    return *grid_getPointRef(gridPtr, x, y, z);
-}
-
-
-/* =============================================================================
- * grid_isPointEmpty
- * =============================================================================
- */
-bool_t
-grid_isPointEmpty (grid_t* gridPtr, long x, long y, long z)
-{
-    long value = grid_getPoint(gridPtr, x, y, z);
-    return ((value == GRID_POINT_EMPTY) ? TRUE : FALSE);
-}
-
-
-/* =============================================================================
- * grid_isPointFull
- * =============================================================================
- */
-bool_t
-grid_isPointFull (grid_t* gridPtr, long x, long y, long z)
-{
-    long value = grid_getPoint(gridPtr, x, y, z);
-    return ((value == GRID_POINT_FULL) ? TRUE : FALSE);
-}
-
-
-/* =============================================================================
- * grid_setPoint
- * =============================================================================
- */
-void
-grid_setPoint (grid_t* gridPtr, long x, long y, long z, long value)
-{
-    (*grid_getPointRef(gridPtr, x, y, z)) = value;
-}
-
-
-/* =============================================================================
- * grid_addPath
- * =============================================================================
- */
-void
-grid_addPath (grid_t* gridPtr, vector_t* pointVectorPtr)
-{
-    long i;
-    long n = vector_getSize(pointVectorPtr);
-
-    for (i = 0; i < n; i++) {
-        coordinate_t* coordinatePtr = (coordinate_t*)vector_at(pointVectorPtr, i);
-        long x = coordinatePtr->x;
-        long y = coordinatePtr->y;
-        long z = coordinatePtr->z;
-        grid_setPoint(gridPtr, x, y, z, GRID_POINT_FULL);
-    }
-}
-
-
-/* =============================================================================
- * TMgrid_addPath
- * =============================================================================
- */
-void
-TMgrid_addPath (TM_ARGDECL  grid_t* gridPtr, vector_t* pointVectorPtr)
-{
-    long i;
-    long n = vector_getSize(pointVectorPtr);
-
-    for (i = 1; i < (n-1); i++) {
-        grid_point* gridPointPtr = (grid_point*)vector_at(pointVectorPtr, i);
-        long value = (long)TM_SHARED_READ(gridPointPtr->value);
-        if (value != GRID_POINT_EMPTY) {
-            TM_RESTART();
-        }
-        TM_SHARED_WRITE(gridPointPtr->value, GRID_POINT_FULL);
-    }
-}
-
-
-/* =============================================================================
- * grid_print
- * =============================================================================
- */
-void
-grid_print (grid_t* gridPtr)
-{
-    long width  = gridPtr->width;
-    long height = gridPtr->height;
-    long depth  = gridPtr->depth;
-    long z;
-
-    for (z = 0; z < depth; z++) {
-        printf("[z = %li]\n", z);
-        long x;
-        for (x = 0; x < width; x++) {
-            long y;
-            for (y = 0; y < height; y++) {
-                printf("%4li", *grid_getPointRef(gridPtr, x, y, z));
-            }
-            puts("");
-        }
-        puts("");
-    }
-}
-
-
-/* =============================================================================
- *
- * End of grid.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/labyrinth/grid.cpp stamp-g/labyrinth/grid.cpp
--- stamp-0.9.10/labyrinth/grid.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-g/labyrinth/grid.cpp	2017-03-20 15:19:41.000000000 +0000
@@ -0,0 +1,408 @@
+/* =============================================================================
+ *
+ * grid.c
+ *
+ * =============================================================================
+ *
+ * Copyright (C) Stanford University, 2006.  All Rights Reserved.
+ * Author: Chi Cao Minh
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+
+
+#include <assert.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include "coordinate.h"
+#include "grid.h"
+#include "tm.h"
+#include "types.h"
+#include "vector.h"
+
+#include "Galois/Runtime/Context.h"
+
+const unsigned long CACHE_LINE_SIZE = 32UL;
+
+
+/* =============================================================================
+ * grid_alloc
+ * =============================================================================
+ */
+grid_t*
+grid_alloc (long width, long height, long depth)
+{
+    grid_t* gridPtr;
+
+    gridPtr = (grid_t*)malloc(sizeof(grid_t));
+    if (gridPtr) {
+        gridPtr->width  = width;
+        gridPtr->height = height;
+        gridPtr->depth  = depth;
+        long n = width * height * depth;
+        long* points_unaligned = (long*)malloc(n * sizeof(long) + CACHE_LINE_SIZE);
+        assert(points_unaligned);
+        gridPtr->points_unaligned = points_unaligned;
+        gridPtr->points = (long*)((char*)(((unsigned long)points_unaligned
+                                          & ~(CACHE_LINE_SIZE-1)))
+                                  + CACHE_LINE_SIZE);
+        Galois::Runtime::Lockable* locks = NULL;
+#ifndef HTM
+        locks = (Galois::Runtime::Lockable*)malloc(n*sizeof(*locks));
+        for (long i = 0; i < n; ++i)
+          new (&locks[i]) Galois::Runtime::Lockable;
+#endif
+        gridPtr->locks = locks;
+        memset(gridPtr->points, GRID_POINT_EMPTY, (n * sizeof(long)));
+    }
+
+    return gridPtr;
+}
+
+
+/* =============================================================================
+ * Pgrid_alloc
+ * =============================================================================
+ */
+grid_t*
+Pgrid_alloc (long width, long height, long depth)
+{
+    grid_t* gridPtr;
+
+    gridPtr = (grid_t*)P_MALLOC(sizeof(grid_t));
+    if (gridPtr) {
+        gridPtr->width  = width;
+        gridPtr->height = height;
+        gridPtr->depth  = depth;
+        long n = width * height * depth;
+        long* points_unaligned = (long*)P_MALLOC(n * sizeof(long) + CACHE_LINE_SIZE);
+        assert(points_unaligned);
+        gridPtr->points_unaligned = points_unaligned;
+        gridPtr->points = (long*)((char*)(((unsigned long)points_unaligned
+                                          & ~(CACHE_LINE_SIZE-1)))
+                                  + CACHE_LINE_SIZE);
+        memset(gridPtr->points, GRID_POINT_EMPTY, (n * sizeof(long)));
+    }
+
+    return gridPtr;
+}
+
+
+/* =============================================================================
+ * grid_free
+ * =============================================================================
+ */
+void
+grid_free (grid_t* gridPtr)
+{
+    free(gridPtr->points_unaligned);
+    if (gridPtr->locks)
+        free(gridPtr->locks);
+    free(gridPtr);
+}
+
+
+/* =============================================================================
+ * TMgrid_free
+ * =============================================================================
+ */
+void
+Pgrid_free (grid_t* gridPtr)
+{
+    P_FREE(gridPtr->points_unaligned);
+    if (gridPtr->locks)
+        P_FREE(gridPtr->locks);
+    P_FREE(gridPtr);
+}
+
+
+/* =============================================================================
+ * grid_copy
+ * =============================================================================
+ */
+void
+grid_copy (grid_t* dstGridPtr, grid_t* srcGridPtr)
+{
+    assert(srcGridPtr->width  == dstGridPtr->width);
+    assert(srcGridPtr->height == dstGridPtr->height);
+    assert(srcGridPtr->depth  == dstGridPtr->depth);
+
+    long n = srcGridPtr->width * srcGridPtr->height * srcGridPtr->depth;
+    memcpy(dstGridPtr->points, srcGridPtr->points, (n * sizeof(long)));
+
+#ifdef USE_EARLY_RELEASE
+    long* srcPoints = srcGridPtr->points;
+    long i;
+    long i_step = (CACHE_LINE_SIZE / sizeof(srcPoints[0]));
+    for (i = 0; i < n; i+=i_step) {
+        TM_EARLY_RELEASE(srcPoints[i]); /* releases entire line */
+    }
+#endif
+}
+
+
+/* =============================================================================
+ * grid_isPointValid
+ * =============================================================================
+ */
+bool_t
+grid_isPointValid (grid_t* gridPtr, long x, long y, long z)
+{
+    if (x < 0 || x >= gridPtr->width  ||
+        y < 0 || y >= gridPtr->height ||
+        z < 0 || z >= gridPtr->depth)
+    {
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+
+/* =============================================================================
+ * grid_getPointRef
+ * =============================================================================
+ */
+long*
+grid_getPointRef (grid_t* gridPtr, long x, long y, long z)
+{
+    return &(gridPtr->points[(z * gridPtr->height + y) * gridPtr->width + x]);
+}
+
+
+/* =============================================================================
+ * grid_getPointIndices
+ * =============================================================================
+ */
+void
+grid_getPointIndices (grid_t* gridPtr,
+                      long* gridPointPtr, long* xPtr, long* yPtr, long* zPtr)
+{
+    long height = gridPtr->height;
+    long width  = gridPtr->width;
+    long area = height * width;
+    long index3d = (gridPointPtr - gridPtr->points);
+    (*zPtr) = index3d / area;
+    long index2d = index3d % area;
+    (*yPtr) = index2d / width;
+    (*xPtr) = index2d % width;
+}
+
+
+/* =============================================================================
+ * grid_getPoint
+ * =============================================================================
+ */
+long
+grid_getPoint (grid_t* gridPtr, long x, long y, long z)
+{
+    return *grid_getPointRef(gridPtr, x, y, z);
+}
+
+
+/* =============================================================================
+ * grid_isPointEmpty
+ * =============================================================================
+ */
+bool_t
+grid_isPointEmpty (grid_t* gridPtr, long x, long y, long z)
+{
+    long value = grid_getPoint(gridPtr, x, y, z);
+    return ((value == GRID_POINT_EMPTY) ? TRUE : FALSE);
+}
+
+
+/* =============================================================================
+ * grid_isPointFull
+ * =============================================================================
+ */
+bool_t
+grid_isPointFull (grid_t* gridPtr, long x, long y, long z)
+{
+    long value = grid_getPoint(gridPtr, x, y, z);
+    return ((value == GRID_POINT_FULL) ? TRUE : FALSE);
+}
+
+
+/* =============================================================================
+ * grid_setPoint
+ * =============================================================================
+ */
+void
+grid_setPoint (grid_t* gridPtr, long x, long y, long z, long value)
+{
+    (*grid_getPointRef(gridPtr, x, y, z)) = value;
+}
+
+
+/* =============================================================================
+ * grid_addPath
+ * =============================================================================
+ */
+void
+grid_addPath (grid_t* gridPtr, vector_t* pointVectorPtr)
+{
+    long i;
+    //long n = vector_getSize(pointVectorPtr);
+    list_iter_t it;
+    list_iter_reset(&it, pointVectorPtr);
+
+    for (i = 0; list_iter_hasNext(&it, pointVectorPtr)/*i < n*/; i++) {
+        coordinate_t* coordinatePtr = (coordinate_t*)list_iter_next(&it, pointVectorPtr);//vector_at(pointVectorPtr, i);
+        long x = coordinatePtr->x;
+        long y = coordinatePtr->y;
+        long z = coordinatePtr->z;
+        grid_setPoint(gridPtr, x, y, z, GRID_POINT_FULL);
+    }
+}
+
+
+/* =============================================================================
+ * TMgrid_addPath
+ * =============================================================================
+ */
+void
+TMgrid_addPath (TM_ARGDECL  grid_t* gridPtr, vector_t* pointVectorPtr)
+{
+    long i;
+    //long n = vector_getSize(pointVectorPtr);
+    list_iter_t it;
+    list_iter_reset(&it, pointVectorPtr);
+    
+    assert(list_iter_hasNext(&it, pointVectorPtr));
+    list_iter_next(&it, pointVectorPtr);
+
+    for (i = 1; list_iter_hasNext(&it, pointVectorPtr)/*i < (n-1)*/; i++) {
+        long* gridPointPtr = (long*)list_iter_next(&it, pointVectorPtr); //vector_at(pointVectorPtr, i);
+        if (!list_iter_hasNext(&it, pointVectorPtr))
+          break;
+        long value = (long)TM_SHARED_READ(*gridPointPtr);
+        if (value != GRID_POINT_EMPTY) {
+            TM_RESTART();
+        }
+        TM_SHARED_WRITE(*gridPointPtr, GRID_POINT_FULL);
+    }
+}
+
+int
+TMgrid_acquirePath (TM_ARGDECL  grid_t* gridPtr, vector_t* pointVectorPtr)
+{
+    long i;
+    //long n = vector_getSize(pointVectorPtr);
+    list_iter_t it;
+    list_iter_reset(&it, pointVectorPtr);
+    
+    assert(list_iter_hasNext(&it, pointVectorPtr));
+    list_iter_next(&it, pointVectorPtr);
+
+    for (i = 1; list_iter_hasNext(&it, pointVectorPtr)/*i < (n-1)*/; i++) {
+        long* gridPointPtr = (long*)list_iter_next(&it, pointVectorPtr); //vector_at(pointVectorPtr, i);
+        if (!list_iter_hasNext(&it, pointVectorPtr))
+          break;
+        ptrdiff_t index = std::distance(gridPtr->points, gridPointPtr);
+#ifndef HTM
+        Galois::Runtime::Lockable* l = (Galois::Runtime::Lockable*) gridPtr->locks;
+        Galois::Runtime::acquire(&l[index], Galois::MethodFlag::ALL);
+#endif
+        long value = (long)TM_SHARED_READ(*gridPointPtr);
+
+        if (value != GRID_POINT_EMPTY) {
+          return 0;
+        }
+    }
+    return 1;
+}
+
+
+/* =============================================================================
+ * grid_print
+ * =============================================================================
+ */
+void
+grid_print (grid_t* gridPtr)
+{
+    long width  = gridPtr->width;
+    long height = gridPtr->height;
+    long depth  = gridPtr->depth;
+    long z;
+
+    for (z = 0; z < depth; z++) {
+        printf("[z = %li]\n", z);
+        long x;
+        for (x = 0; x < width; x++) {
+            long y;
+            for (y = 0; y < height; y++) {
+                printf("%4li", *grid_getPointRef(gridPtr, x, y, z));
+            }
+            puts("");
+        }
+        puts("");
+    }
+}
+
+
+/* =============================================================================
+ *
+ * End of grid.c
+ *
+ * =============================================================================
+ */
diff -x .git -x inputs -Naur stamp-0.9.10/labyrinth/grid.h stamp-g/labyrinth/grid.h
--- stamp-0.9.10/labyrinth/grid.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/labyrinth/grid.h	2017-03-20 15:19:41.000000000 +0000
@@ -76,16 +76,17 @@
 #include "types.h"
 #include "vector.h"
 
-typedef struct grid_point {
-    XTM_DECL_LOCKABLE(long, value);
-} grid_point;
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef struct grid {
     long width;
     long height;
     long depth;
-    grid_point* points;
-    grid_point* points_unaligned;
+    long* points;
+    long* points_unaligned;
+    void* locks;
 } grid_t;
 
 enum {
@@ -207,6 +208,8 @@
 void
 TMgrid_addPath (TM_ARGDECL  grid_t* gridPtr, vector_t* pointVectorPtr);
 
+int
+TMgrid_acquirePath (TM_ARGDECL  grid_t* gridPtr, vector_t* pointVectorPtr);
 
 /* =============================================================================
  * grid_print
@@ -220,7 +223,11 @@
 #define PGRID_FREE(g)                   Pgrid_free(g)
 
 #define TMGRID_ADDPATH(g, p)            TMgrid_addPath(TM_ARG  g, p)
+#define TMGRID_ACQUIREPATH(g, p)            TMgrid_acquirePath(TM_ARG  g, p)
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* GRID_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/labyrinth/labyrinth.c stamp-g/labyrinth/labyrinth.c
--- stamp-0.9.10/labyrinth/labyrinth.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/labyrinth/labyrinth.c	2017-03-21 18:26:15.000000000 +0000
@@ -216,28 +216,29 @@
      */
     router_solve_arg_t routerArg = {routerPtr, mazePtr, pathVectorListPtr};
     TIMER_T startTime;
-    TIMER_READ(startTime);
     GOTO_SIM();
     thread_begin_timing();
-#ifdef OTM
-#pragma omp parallel
-    {
-        router_solve((void *)&routerArg);
-    }
-#else
-    thread_start(router_solve, (void*)&routerArg);
-#endif
-    thread_end_timing();
-    GOTO_REAL();
+    TIMER_READ(startTime);
+
+    router_solve((void *)&routerArg);
+    
     TIMER_T stopTime;
     TIMER_READ(stopTime);
+    thread_end_timing();
+    GOTO_REAL();
 
     long numPathRouted = 0;
     list_iter_t it;
     list_iter_reset(&it, pathVectorListPtr);
     while (list_iter_hasNext(&it, pathVectorListPtr)) {
         vector_t* pathVectorPtr = (vector_t*)list_iter_next(&it, pathVectorListPtr);
-        numPathRouted += vector_getSize(pathVectorPtr);
+        list_iter_t vit;
+        list_iter_reset(&vit, pathVectorPtr);
+        while (list_iter_hasNext(&vit, pathVectorPtr)) {
+          list_iter_next(&vit, pathVectorPtr);
+          numPathRouted += 1;
+        }
+        //numPathRouted += vector_getSize(pathVectorPtr);
     }
     printf("Paths routed    = %li\n", numPathRouted);
     printf("Elapsed time    = %f seconds\n", TIMER_DIFF_SECONDS(startTime, stopTime));
diff -x .git -x inputs -Naur stamp-0.9.10/labyrinth/maze.c stamp-g/labyrinth/maze.c
--- stamp-0.9.10/labyrinth/maze.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/labyrinth/maze.c	2017-03-20 15:19:41.000000000 +0000
@@ -132,9 +132,11 @@
 addToGrid (grid_t* gridPtr, vector_t* vectorPtr, char* type)
 {
     long i;
-    long n = vector_getSize(vectorPtr);
-    for (i = 0; i < n; i++) {
-        coordinate_t* coordinatePtr = (coordinate_t*)vector_at(vectorPtr, i);
+    //long n = vector_getSize(vectorPtr);
+    list_iter_t it;
+    list_iter_reset(&it, vectorPtr);
+    for (i = 0; list_iter_hasNext(&it, vectorPtr)/*i < n*/; i++) {
+        coordinate_t* coordinatePtr = (coordinate_t*)list_iter_next(&it, vectorPtr);//vector_at(vectorPtr, i);
         if (!grid_isPointValid(gridPtr,
                                coordinatePtr->x,
                                coordinatePtr->y,
@@ -265,6 +267,7 @@
      * Initialize work queue
      */
     queue_t* workQueuePtr = mazePtr->workQueuePtr;
+    vector_sort(workListPtr, &coordinate_comparePair);
     list_iter_t it;
     list_iter_reset(&it, workListPtr);
     while (list_iter_hasNext(&it, workListPtr)) {
@@ -296,17 +299,21 @@
 
     /* Mark sources */
     vector_t* srcVectorPtr = mazePtr->srcVectorPtr;
-    long numSrc = vector_getSize(srcVectorPtr);
-    for (i = 0; i < numSrc; i++) {
-        coordinate_t* srcPtr = (coordinate_t*)vector_at(srcVectorPtr, i);
+    //long numSrc = vector_getSize(srcVectorPtr);
+    list_iter_t sit;
+    list_iter_reset(&sit, srcVectorPtr);
+    for (i = 0; list_iter_hasNext(&sit, srcVectorPtr)/*i < numSrc*/; i++) {
+        coordinate_t* srcPtr = (coordinate_t*)list_iter_next(&sit, srcVectorPtr);//vector_at(srcVectorPtr, i);
         grid_setPoint(testGridPtr, srcPtr->x, srcPtr->y, srcPtr->z, 0);
     }
 
     /* Mark destinations */
     vector_t* dstVectorPtr = mazePtr->dstVectorPtr;
-    long numDst = vector_getSize(dstVectorPtr);
-    for (i = 0; i < numDst; i++) {
-        coordinate_t* dstPtr = (coordinate_t*)vector_at(dstVectorPtr, i);
+    //long numDst = vector_getSize(dstVectorPtr);
+    list_iter_t dit;
+    list_iter_reset(&dit, dstVectorPtr);
+    for (i = 0; list_iter_hasNext(&dit, dstVectorPtr)/*i < numDst*/; i++) {
+        coordinate_t* dstPtr = (coordinate_t*)list_iter_next(&dit, dstVectorPtr);//vector_at(dstVectorPtr, i);
         grid_setPoint(testGridPtr, dstPtr->x, dstPtr->y, dstPtr->z, 0);
     }
 
@@ -316,13 +323,17 @@
     list_iter_reset(&it, pathVectorListPtr);
     while (list_iter_hasNext(&it, pathVectorListPtr)) {
         vector_t* pathVectorPtr = (vector_t*)list_iter_next(&it, pathVectorListPtr);
-        long numPath = vector_getSize(pathVectorPtr);
+        //long numPath = vector_getSize(pathVectorPtr);
+        list_iter_t pathIt;
+        list_iter_reset(&pathIt, pathVectorPtr);
         long i;
-        for (i = 0; i < numPath; i++) {
+        for (i = 0; list_iter_hasNext(&pathIt, pathVectorPtr)/*i < numPath*/; i++) {
             id++;
-            vector_t* pointVectorPtr = (vector_t*)vector_at(pathVectorPtr, i);
+            vector_t* pointVectorPtr = (vector_t*)list_iter_next(&pathIt, pathVectorPtr);//vector_at(pathVectorPtr, i);
             /* Check start */
-            long* prevGridPointPtr = (long*)vector_at(pointVectorPtr, 0);
+            list_iter_t pointIt;
+            list_iter_reset(&pointIt, pointVectorPtr);
+            long* prevGridPointPtr = (long*)list_iter_next(&pointIt, pointVectorPtr);//vector_at(pointVectorPtr, 0);
             long x;
             long y;
             long z;
@@ -340,7 +351,7 @@
             long numPoint = vector_getSize(pointVectorPtr);
             long j;
             for (j = 1; j < (numPoint-1); j++) { /* no need to check endpoints */
-                long* currGridPointPtr = (long*)vector_at(pointVectorPtr, j);
+                long* currGridPointPtr = (long*)list_iter_next(&pointIt, pointVectorPtr);//vector_at(pointVectorPtr, j);
                 coordinate_t currCoordinate;
                 grid_getPointIndices(gridPtr,
                                      currGridPointPtr,
@@ -363,7 +374,7 @@
                 }
             }
             /* Check end */
-            long* lastGridPointPtr = (long*)vector_at(pointVectorPtr, j);
+            long* lastGridPointPtr = (long*)list_iter_next(&pointIt, pointVectorPtr);//vector_at(pointVectorPtr, j);
             grid_getPointIndices(gridPtr, lastGridPointPtr, &x, &y, &z);
             if (grid_getPoint(testGridPtr, x, y, z) != 0) {
                 grid_free(testGridPtr);
diff -x .git -x inputs -Naur stamp-0.9.10/labyrinth/maze.h stamp-g/labyrinth/maze.h
--- stamp-0.9.10/labyrinth/maze.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/labyrinth/maze.h	2017-03-20 15:19:41.000000000 +0000
@@ -81,6 +81,10 @@
 #include "types.h"
 #include "vector.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct maze {
     grid_t* gridPtr;
     queue_t* workQueuePtr;   /* contains source/destination pairs to route */
@@ -122,6 +126,9 @@
 bool_t
 maze_checkPaths (maze_t* mazePtr, list_t* pathListPtr, bool_t doPrintPaths);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* MAZE_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/labyrinth/router.c stamp-g/labyrinth/router.c
--- stamp-0.9.10/labyrinth/router.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/labyrinth/router.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,446 +0,0 @@
-/* =============================================================================
- *
- * router.c
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <stdlib.h>
-#include "coordinate.h"
-#include "grid.h"
-#include "queue.h"
-#include "router.h"
-#include "tm.h"
-#include "vector.h"
-
-
-typedef enum momentum {
-    MOMENTUM_ZERO = 0,
-    MOMENTUM_POSX = 1,
-    MOMENTUM_POSY = 2,
-    MOMENTUM_POSZ = 3,
-    MOMENTUM_NEGX = 4,
-    MOMENTUM_NEGY = 5,
-    MOMENTUM_NEGZ = 6
-} momentum_t;
-
-typedef struct point {
-    long x;
-    long y;
-    long z;
-    long value;
-    momentum_t momentum;
-} point_t;
-
-point_t MOVE_POSX = { 1,  0,  0,  0, MOMENTUM_POSX};
-point_t MOVE_POSY = { 0,  1,  0,  0, MOMENTUM_POSY};
-point_t MOVE_POSZ = { 0,  0,  1,  0, MOMENTUM_POSZ};
-point_t MOVE_NEGX = {-1,  0,  0,  0, MOMENTUM_NEGX};
-point_t MOVE_NEGY = { 0, -1,  0,  0, MOMENTUM_NEGY};
-point_t MOVE_NEGZ = { 0,  0, -1,  0, MOMENTUM_NEGZ};
-
-
-/* =============================================================================
- * router_alloc
- * =============================================================================
- */
-router_t*
-router_alloc (long xCost, long yCost, long zCost, long bendCost)
-{
-    router_t* routerPtr;
-
-    routerPtr = (router_t*)malloc(sizeof(router_t));
-    if (routerPtr) {
-        routerPtr->xCost = xCost;
-        routerPtr->yCost = yCost;
-        routerPtr->zCost = zCost;
-        routerPtr->bendCost = bendCost;
-    }
-
-    return routerPtr;
-}
-
-
-/* =============================================================================
- * router_free
- * =============================================================================
- */
-void
-router_free (router_t* routerPtr)
-{
-    free(routerPtr);
-}
-
-
-/* =============================================================================
- * PexpandToNeighbor
- * =============================================================================
- */
-static void
-PexpandToNeighbor (grid_t* myGridPtr,
-                   long x, long y, long z, long value, queue_t* queuePtr)
-{
-    if (grid_isPointValid(myGridPtr, x, y, z)) {
-        long* neighborGridPointPtr = grid_getPointRef(myGridPtr, x, y, z);
-        long neighborValue = *neighborGridPointPtr;
-        if (neighborValue == GRID_POINT_EMPTY) {
-            (*neighborGridPointPtr) = value;
-            PQUEUE_PUSH(queuePtr, (void*)neighborGridPointPtr);
-        } else if (neighborValue != GRID_POINT_FULL) {
-            /* We have expanded here before... is this new path better? */
-            if (value < neighborValue) {
-                (*neighborGridPointPtr) = value;
-                PQUEUE_PUSH(queuePtr, (void*)neighborGridPointPtr);
-            }
-        }
-    }
-}
-
-
-/* =============================================================================
- * PdoExpansion
- * =============================================================================
- */
-static bool_t
-PdoExpansion (router_t* routerPtr, grid_t* myGridPtr, queue_t* queuePtr,
-              coordinate_t* srcPtr, coordinate_t* dstPtr)
-{
-    long xCost = routerPtr->xCost;
-    long yCost = routerPtr->yCost;
-    long zCost = routerPtr->zCost;
-
-    /*
-     * Potential Optimization: Make 'src' the one closest to edge.
-     * This will likely decrease the area of the emitted wave.
-     */
-
-    PQUEUE_CLEAR(queuePtr);
-    long* srcGridPointPtr =
-        grid_getPointRef(myGridPtr, srcPtr->x, srcPtr->y, srcPtr->z);
-    PQUEUE_PUSH(queuePtr, (void*)srcGridPointPtr);
-    grid_setPoint(myGridPtr, srcPtr->x, srcPtr->y, srcPtr->z, 0);
-    grid_setPoint(myGridPtr, dstPtr->x, dstPtr->y, dstPtr->z, GRID_POINT_EMPTY);
-    long* dstGridPointPtr =
-        grid_getPointRef(myGridPtr, dstPtr->x, dstPtr->y, dstPtr->z);
-    bool_t isPathFound = FALSE;
-
-    while (!PQUEUE_ISEMPTY(queuePtr)) {
-
-        long* gridPointPtr = (long*)PQUEUE_POP(queuePtr);
-        if (gridPointPtr == dstGridPointPtr) {
-            isPathFound = TRUE;
-            break;
-        }
-
-        long x;
-        long y;
-        long z;
-        grid_getPointIndices(myGridPtr, gridPointPtr, &x, &y, &z);
-        long value = (*gridPointPtr);
-
-        /*
-         * Check 6 neighbors
-         *
-         * Potential Optimization: Only need to check 5 of these
-         */
-        PexpandToNeighbor(myGridPtr, x+1, y,   z,   (value + xCost), queuePtr);
-        PexpandToNeighbor(myGridPtr, x-1, y,   z,   (value + xCost), queuePtr);
-        PexpandToNeighbor(myGridPtr, x,   y+1, z,   (value + yCost), queuePtr);
-        PexpandToNeighbor(myGridPtr, x,   y-1, z,   (value + yCost), queuePtr);
-        PexpandToNeighbor(myGridPtr, x,   y,   z+1, (value + zCost), queuePtr);
-        PexpandToNeighbor(myGridPtr, x,   y,   z-1, (value + zCost), queuePtr);
-
-    } /* iterate over work queue */
-
-#if DEBUG
-    printf("Expansion (%li, %li, %li) -> (%li, %li, %li):\n",
-           srcPtr->x, srcPtr->y, srcPtr->z,
-           dstPtr->x, dstPtr->y, dstPtr->z);
-    grid_print(myGridPtr);
-#endif /*  DEBUG */
-
-    return isPathFound;
-}
-
-
-/* =============================================================================
- * traceToNeighbor
- * =============================================================================
- */
-static void
-traceToNeighbor (grid_t* myGridPtr,
-                 point_t* currPtr,
-                 point_t* movePtr,
-                 bool_t useMomentum,
-                 long bendCost,
-                 point_t* nextPtr)
-{
-    long x = currPtr->x + movePtr->x;
-    long y = currPtr->y + movePtr->y;
-    long z = currPtr->z + movePtr->z;
-
-    if (grid_isPointValid(myGridPtr, x, y, z) &&
-        !grid_isPointEmpty(myGridPtr, x, y, z) &&
-        !grid_isPointFull(myGridPtr, x, y, z))
-    {
-        long value = grid_getPoint(myGridPtr, x, y, z);
-        long b = 0;
-        if (useMomentum && (currPtr->momentum != movePtr->momentum)) {
-            b = bendCost;
-        }
-        if ((value + b) <= nextPtr->value) { /* '=' favors neighbors over current */
-            nextPtr->x = x;
-            nextPtr->y = y;
-            nextPtr->z = z;
-            nextPtr->value = value;
-            nextPtr->momentum = movePtr->momentum;
-        }
-    }
-}
-
-
-/* =============================================================================
- * PdoTraceback
- * =============================================================================
- */
-static vector_t*
-PdoTraceback (grid_t* gridPtr, grid_t* myGridPtr,
-              coordinate_t* dstPtr, long bendCost)
-{
-    vector_t* pointVectorPtr = PVECTOR_ALLOC(1);
-    assert(pointVectorPtr);
-
-    point_t next;
-    next.x = dstPtr->x;
-    next.y = dstPtr->y;
-    next.z = dstPtr->z;
-    next.value = grid_getPoint(myGridPtr, next.x, next.y, next.z);
-    next.momentum = MOMENTUM_ZERO;
-
-    while (1) {
-
-        long* gridPointPtr = grid_getPointRef(gridPtr, next.x, next.y, next.z);
-        PVECTOR_PUSHBACK(pointVectorPtr, (void*)gridPointPtr);
-        grid_setPoint(myGridPtr, next.x, next.y, next.z, GRID_POINT_FULL);
-
-        /* Check if we are done */
-        if (next.value == 0) {
-            break;
-        }
-        point_t curr = next;
-
-        /*
-         * Check 6 neighbors
-         *
-         * Potential Optimization: Only need to check 5 of these
-         */
-        traceToNeighbor(myGridPtr, &curr, &MOVE_POSX, TRUE, bendCost, &next);
-        traceToNeighbor(myGridPtr, &curr, &MOVE_POSY, TRUE, bendCost, &next);
-        traceToNeighbor(myGridPtr, &curr, &MOVE_POSZ, TRUE, bendCost, &next);
-        traceToNeighbor(myGridPtr, &curr, &MOVE_NEGX, TRUE, bendCost, &next);
-        traceToNeighbor(myGridPtr, &curr, &MOVE_NEGY, TRUE, bendCost, &next);
-        traceToNeighbor(myGridPtr, &curr, &MOVE_NEGZ, TRUE, bendCost, &next);
-
-#if DEBUG
-        printf("(%li, %li, %li)\n", next.x, next.y, next.z);
-#endif /* DEBUG */
-        /*
-         * Because of bend costs, none of the neighbors may appear to be closer.
-         * In this case, pick a neighbor while ignoring momentum.
-         */
-        if ((curr.x == next.x) &&
-            (curr.y == next.y) &&
-            (curr.z == next.z))
-        {
-            next.value = curr.value;
-            traceToNeighbor(myGridPtr, &curr, &MOVE_POSX, FALSE, bendCost, &next);
-            traceToNeighbor(myGridPtr, &curr, &MOVE_POSY, FALSE, bendCost, &next);
-            traceToNeighbor(myGridPtr, &curr, &MOVE_POSZ, FALSE, bendCost, &next);
-            traceToNeighbor(myGridPtr, &curr, &MOVE_NEGX, FALSE, bendCost, &next);
-            traceToNeighbor(myGridPtr, &curr, &MOVE_NEGY, FALSE, bendCost, &next);
-            traceToNeighbor(myGridPtr, &curr, &MOVE_NEGZ, FALSE, bendCost, &next);
-
-            if ((curr.x == next.x) &&
-                (curr.y == next.y) &&
-                (curr.z == next.z))
-            {
-                PVECTOR_FREE(pointVectorPtr);
-#if DEBUG
-                puts("[dead]");
-#endif
-                return NULL; /* cannot find path */
-            }
-        }
-    }
-
-#if DEBUG
-    puts("");
-#endif /* DEBUG */
-
-    return pointVectorPtr;
-}
-
-
-/* =============================================================================
- * router_solve
- * =============================================================================
- */
-void
-router_solve (void* argPtr)
-{
-    TM_THREAD_ENTER();
-
-    router_solve_arg_t* routerArgPtr = (router_solve_arg_t*)argPtr;
-    router_t* routerPtr = routerArgPtr->routerPtr;
-    maze_t* mazePtr = routerArgPtr->mazePtr;
-    vector_t* myPathVectorPtr = PVECTOR_ALLOC(1);
-    assert(myPathVectorPtr);
-
-    queue_t* workQueuePtr = mazePtr->workQueuePtr;
-    grid_t* gridPtr = mazePtr->gridPtr;
-    grid_t* myGridPtr =
-        PGRID_ALLOC(gridPtr->width, gridPtr->height, gridPtr->depth);
-    assert(myGridPtr);
-    long bendCost = routerPtr->bendCost;
-    queue_t* myExpansionQueuePtr = PQUEUE_ALLOC(-1);
-
-    /*
-     * Iterate over work list to route each path. This involves an
-     * 'expansion' and 'traceback' phase for each source/destination pair.
-     */
-    while (1) {
-
-        pair_t* coordinatePairPtr;
-        TM_BEGIN();
-        if (TMQUEUE_ISEMPTY(workQueuePtr)) {
-            coordinatePairPtr = NULL;
-        } else {
-            coordinatePairPtr = (pair_t*)TMQUEUE_POP(workQueuePtr);
-        }
-        TM_END();
-        if (coordinatePairPtr == NULL) {
-            break;
-        }
-
-        coordinate_t* srcPtr = coordinatePairPtr->firstPtr;
-        coordinate_t* dstPtr = coordinatePairPtr->secondPtr;
-
-        bool_t success = FALSE;
-        vector_t* pointVectorPtr = NULL;
-
-        TM_BEGIN();
-        grid_copy(myGridPtr, gridPtr); /* ok if not most up-to-date */
-        if (PdoExpansion(routerPtr, myGridPtr, myExpansionQueuePtr,
-                         srcPtr, dstPtr)) {
-            pointVectorPtr = PdoTraceback(gridPtr, myGridPtr, dstPtr, bendCost);
-            /*
-             * TODO: fix memory leak
-             *
-             * pointVectorPtr will be a memory leak if we abort this transaction
-             */
-            if (pointVectorPtr) {
-                TMGRID_ADDPATH(gridPtr, pointVectorPtr);
-                TM_LOCAL_WRITE(success, TRUE);
-            }
-        }
-        TM_END();
-
-        if (success) {
-            bool_t status = PVECTOR_PUSHBACK(myPathVectorPtr,
-                                             (void*)pointVectorPtr);
-            assert(status);
-        }
-
-    }
-
-    /*
-     * Add my paths to global list
-     */
-    list_t* pathVectorListPtr = routerArgPtr->pathVectorListPtr;
-    TM_BEGIN();
-    TMLIST_INSERT(pathVectorListPtr, (void*)myPathVectorPtr);
-    TM_END();
-
-    PGRID_FREE(myGridPtr);
-    PQUEUE_FREE(myExpansionQueuePtr);
-
-#if DEBUG
-    puts("\nFinal Grid:");
-    grid_print(gridPtr);
-#endif /* DEBUG */
-
-    TM_THREAD_EXIT();
-}
-
-
-/* =============================================================================
- *
- * End of router.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/labyrinth/router.cpp stamp-g/labyrinth/router.cpp
--- stamp-0.9.10/labyrinth/router.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-g/labyrinth/router.cpp	2017-03-21 18:27:08.000000000 +0000
@@ -0,0 +1,464 @@
+/* =============================================================================
+ *
+ * router.c
+ *
+ * =============================================================================
+ *
+ * Copyright (C) Stanford University, 2006.  All Rights Reserved.
+ * Author: Chi Cao Minh
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+#include "Galois/Galois.h"
+#include "Galois/Bag.h"
+#include "Galois/Statistic.h"
+
+#include <assert.h>
+#include <stdlib.h>
+#include "coordinate.h"
+#include "grid.h"
+#include "queue.h"
+#include "router.h"
+#include "tm.h"
+#include "vector.h"
+
+
+typedef enum momentum {
+    MOMENTUM_ZERO = 0,
+    MOMENTUM_POSX = 1,
+    MOMENTUM_POSY = 2,
+    MOMENTUM_POSZ = 3,
+    MOMENTUM_NEGX = 4,
+    MOMENTUM_NEGY = 5,
+    MOMENTUM_NEGZ = 6
+} momentum_t;
+
+typedef struct point {
+    long x;
+    long y;
+    long z;
+    long value;
+    momentum_t momentum;
+} point_t;
+
+point_t MOVE_POSX = { 1,  0,  0,  0, MOMENTUM_POSX};
+point_t MOVE_POSY = { 0,  1,  0,  0, MOMENTUM_POSY};
+point_t MOVE_POSZ = { 0,  0,  1,  0, MOMENTUM_POSZ};
+point_t MOVE_NEGX = {-1,  0,  0,  0, MOMENTUM_NEGX};
+point_t MOVE_NEGY = { 0, -1,  0,  0, MOMENTUM_NEGY};
+point_t MOVE_NEGZ = { 0,  0, -1,  0, MOMENTUM_NEGZ};
+
+
+/* =============================================================================
+ * router_alloc
+ * =============================================================================
+ */
+router_t*
+router_alloc (long xCost, long yCost, long zCost, long bendCost)
+{
+    router_t* routerPtr;
+
+    routerPtr = (router_t*)malloc(sizeof(router_t));
+    if (routerPtr) {
+        routerPtr->xCost = xCost;
+        routerPtr->yCost = yCost;
+        routerPtr->zCost = zCost;
+        routerPtr->bendCost = bendCost;
+    }
+    Galois::preAlloc(15 * Galois::getActiveThreads());
+
+    return routerPtr;
+}
+
+
+/* =============================================================================
+ * router_free
+ * =============================================================================
+ */
+void
+router_free (router_t* routerPtr)
+{
+    free(routerPtr);
+}
+
+
+/* =============================================================================
+ * PexpandToNeighbor
+ * =============================================================================
+ */
+static void
+PexpandToNeighbor (grid_t* myGridPtr,
+                   long x, long y, long z, long value, queue_t* queuePtr)
+{
+    if (grid_isPointValid(myGridPtr, x, y, z)) {
+        long* neighborGridPointPtr = grid_getPointRef(myGridPtr, x, y, z);
+        long neighborValue = *neighborGridPointPtr;
+        if (neighborValue == GRID_POINT_EMPTY) {
+            (*neighborGridPointPtr) = value;
+            PQUEUE_PUSH(queuePtr, (void*)neighborGridPointPtr);
+        } else if (neighborValue != GRID_POINT_FULL) {
+            /* We have expanded here before... is this new path better? */
+            if (value < neighborValue) {
+                (*neighborGridPointPtr) = value;
+                PQUEUE_PUSH(queuePtr, (void*)neighborGridPointPtr);
+            }
+        }
+    }
+}
+
+
+/* =============================================================================
+ * PdoExpansion
+ * =============================================================================
+ */
+static bool_t
+PdoExpansion (router_t* routerPtr, grid_t* myGridPtr, queue_t* queuePtr,
+              coordinate_t* srcPtr, coordinate_t* dstPtr)
+{
+    long xCost = routerPtr->xCost;
+    long yCost = routerPtr->yCost;
+    long zCost = routerPtr->zCost;
+
+    /*
+     * Potential Optimization: Make 'src' the one closest to edge.
+     * This will likely decrease the area of the emitted wave.
+     */
+
+    PQUEUE_CLEAR(queuePtr);
+    long* srcGridPointPtr =
+        grid_getPointRef(myGridPtr, srcPtr->x, srcPtr->y, srcPtr->z);
+    PQUEUE_PUSH(queuePtr, (void*)srcGridPointPtr);
+    grid_setPoint(myGridPtr, srcPtr->x, srcPtr->y, srcPtr->z, 0);
+    grid_setPoint(myGridPtr, dstPtr->x, dstPtr->y, dstPtr->z, GRID_POINT_EMPTY);
+    long* dstGridPointPtr =
+        grid_getPointRef(myGridPtr, dstPtr->x, dstPtr->y, dstPtr->z);
+    bool_t isPathFound = FALSE;
+
+    while (!PQUEUE_ISEMPTY(queuePtr)) {
+
+        long* gridPointPtr = (long*)PQUEUE_POP(queuePtr);
+        if (gridPointPtr == dstGridPointPtr) {
+            isPathFound = TRUE;
+            break;
+        }
+
+        long x;
+        long y;
+        long z;
+        grid_getPointIndices(myGridPtr, gridPointPtr, &x, &y, &z);
+        long value = (*gridPointPtr);
+
+        /*
+         * Check 6 neighbors
+         *
+         * Potential Optimization: Only need to check 5 of these
+         */
+        PexpandToNeighbor(myGridPtr, x+1, y,   z,   (value + xCost), queuePtr);
+        PexpandToNeighbor(myGridPtr, x-1, y,   z,   (value + xCost), queuePtr);
+        PexpandToNeighbor(myGridPtr, x,   y+1, z,   (value + yCost), queuePtr);
+        PexpandToNeighbor(myGridPtr, x,   y-1, z,   (value + yCost), queuePtr);
+        PexpandToNeighbor(myGridPtr, x,   y,   z+1, (value + zCost), queuePtr);
+        PexpandToNeighbor(myGridPtr, x,   y,   z-1, (value + zCost), queuePtr);
+
+    } /* iterate over work queue */
+
+#if DEBUG
+    printf("Expansion (%li, %li, %li) -> (%li, %li, %li):\n",
+           srcPtr->x, srcPtr->y, srcPtr->z,
+           dstPtr->x, dstPtr->y, dstPtr->z);
+    grid_print(myGridPtr);
+#endif /*  DEBUG */
+
+    return isPathFound;
+}
+
+
+/* =============================================================================
+ * traceToNeighbor
+ * =============================================================================
+ */
+static void
+traceToNeighbor (grid_t* myGridPtr,
+                 point_t* currPtr,
+                 point_t* movePtr,
+                 bool_t useMomentum,
+                 long bendCost,
+                 point_t* nextPtr)
+{
+    long x = currPtr->x + movePtr->x;
+    long y = currPtr->y + movePtr->y;
+    long z = currPtr->z + movePtr->z;
+
+    if (grid_isPointValid(myGridPtr, x, y, z) &&
+        !grid_isPointEmpty(myGridPtr, x, y, z) &&
+        !grid_isPointFull(myGridPtr, x, y, z))
+    {
+        long value = grid_getPoint(myGridPtr, x, y, z);
+        long b = 0;
+        if (useMomentum && (currPtr->momentum != movePtr->momentum)) {
+            b = bendCost;
+        }
+        if ((value + b) <= nextPtr->value) { /* '=' favors neighbors over current */
+            nextPtr->x = x;
+            nextPtr->y = y;
+            nextPtr->z = z;
+            nextPtr->value = value;
+            nextPtr->momentum = movePtr->momentum;
+        }
+    }
+}
+
+
+/* =============================================================================
+ * PdoTraceback
+ * =============================================================================
+ */
+static bool
+PdoTraceback (grid_t* gridPtr, grid_t* myGridPtr,
+              coordinate_t* dstPtr, long bendCost, vector_t* pointVectorPtr)
+{
+    //vector_t* pointVectorPtr = PVECTOR_ALLOC(1);
+    assert(pointVectorPtr);
+
+    point_t next;
+    next.x = dstPtr->x;
+    next.y = dstPtr->y;
+    next.z = dstPtr->z;
+    next.value = grid_getPoint(myGridPtr, next.x, next.y, next.z);
+    next.momentum = MOMENTUM_ZERO;
+
+    while (1) {
+
+        long* gridPointPtr = grid_getPointRef(gridPtr, next.x, next.y, next.z);
+        vector_pushBack(pointVectorPtr, (void*)gridPointPtr);
+        grid_setPoint(myGridPtr, next.x, next.y, next.z, GRID_POINT_FULL);
+
+        /* Check if we are done */
+        if (next.value == 0) {
+            break;
+        }
+        point_t curr = next;
+
+        /*
+         * Check 6 neighbors
+         *
+         * Potential Optimization: Only need to check 5 of these
+         */
+        traceToNeighbor(myGridPtr, &curr, &MOVE_POSX, TRUE, bendCost, &next);
+        traceToNeighbor(myGridPtr, &curr, &MOVE_POSY, TRUE, bendCost, &next);
+        traceToNeighbor(myGridPtr, &curr, &MOVE_POSZ, TRUE, bendCost, &next);
+        traceToNeighbor(myGridPtr, &curr, &MOVE_NEGX, TRUE, bendCost, &next);
+        traceToNeighbor(myGridPtr, &curr, &MOVE_NEGY, TRUE, bendCost, &next);
+        traceToNeighbor(myGridPtr, &curr, &MOVE_NEGZ, TRUE, bendCost, &next);
+
+#if DEBUG
+        printf("(%li, %li, %li)\n", next.x, next.y, next.z);
+#endif /* DEBUG */
+        /*
+         * Because of bend costs, none of the neighbors may appear to be closer.
+         * In this case, pick a neighbor while ignoring momentum.
+         */
+        if ((curr.x == next.x) &&
+            (curr.y == next.y) &&
+            (curr.z == next.z))
+        {
+            next.value = curr.value;
+            traceToNeighbor(myGridPtr, &curr, &MOVE_POSX, FALSE, bendCost, &next);
+            traceToNeighbor(myGridPtr, &curr, &MOVE_POSY, FALSE, bendCost, &next);
+            traceToNeighbor(myGridPtr, &curr, &MOVE_POSZ, FALSE, bendCost, &next);
+            traceToNeighbor(myGridPtr, &curr, &MOVE_NEGX, FALSE, bendCost, &next);
+            traceToNeighbor(myGridPtr, &curr, &MOVE_NEGY, FALSE, bendCost, &next);
+            traceToNeighbor(myGridPtr, &curr, &MOVE_NEGZ, FALSE, bendCost, &next);
+
+            if ((curr.x == next.x) &&
+                (curr.y == next.y) &&
+                (curr.z == next.z))
+            {
+                //PVECTOR_FREE(pointVectorPtr);
+#if DEBUG
+                puts("[dead]");
+#endif
+                //return NULL; /* cannot find path */
+                return false;
+            }
+        }
+    }
+
+#if DEBUG
+    puts("");
+#endif /* DEBUG */
+
+    return true;
+}
+
+struct Fn1 {
+    router_solve_arg_t* routerArgPtr;
+    Galois::InsertBag<vector_t>& pointVectorAlloc;
+    Galois::InsertBag<vector_t*>& foundPointVectors;
+    Galois::Runtime::PerThreadStorage<grid_t*>& localGrids;
+
+    void operator()(void* voidPtr, Galois::UserContext<void*>& ctx) {
+        pair_t* coordinatePairPtr = (pair_t*) voidPtr;
+
+        router_t* routerPtr = routerArgPtr->routerPtr;
+        maze_t* mazePtr = routerArgPtr->mazePtr;
+
+        queue_t* workQueuePtr = mazePtr->workQueuePtr;
+        grid_t* gridPtr = mazePtr->gridPtr;
+        grid_t*& myGrid = *localGrids.getLocal();
+        // TODO potential source of contention.
+        if (!myGrid)
+          myGrid = PGRID_ALLOC(gridPtr->width, gridPtr->height, gridPtr->depth);
+        grid_t* myGridPtr = myGrid;
+
+        assert(myGridPtr);
+        long bendCost = routerPtr->bendCost;
+        list_t myExpansionQueue;
+
+        /*
+         * Iterate over work list to route each path. This involves an
+         * 'expansion' and 'traceback' phase for each source/destination pair.
+         */
+        coordinate_t* srcPtr = (coordinate_t*)coordinatePairPtr->firstPtr;
+        coordinate_t* dstPtr = (coordinate_t*)coordinatePairPtr->secondPtr;
+
+        bool_t success = FALSE;
+        vector_t* pointVectorPtr = NULL;
+
+        TM_BEGIN();
+
+		  grid_copy(myGridPtr, gridPtr); /* ok if not most up-to-date */
+		  if (PdoExpansion(routerPtr, myGridPtr, &myExpansionQueue,
+		                   srcPtr, dstPtr)) {
+		      pointVectorPtr = &pointVectorAlloc.emplace();
+		      bool r = PdoTraceback(gridPtr, myGridPtr, dstPtr, bendCost, pointVectorPtr);
+		      // grid locks;
+		      if (r) {
+		          if (!TMGRID_ACQUIREPATH(gridPtr, pointVectorPtr)) {
+		              ctx.push(voidPtr);
+		              return;
+		          }
+		          TMGRID_ADDPATH(gridPtr, pointVectorPtr);
+		          TM_LOCAL_WRITE(success, TRUE);
+		      }
+		  }
+       
+        TM_END();
+
+        if (success == TRUE) {
+            foundPointVectors.push(pointVectorPtr);
+#if 0
+            bool_t status = PVECTOR_PUSHBACK(myPathVectorPtr,
+                                             (void*)pointVectorPtr);
+            assert(status);
+#endif
+        }
+    }
+};
+
+/* =============================================================================
+ * router_solve
+ * =============================================================================
+ */
+Galois::InsertBag<vector_t> pointVectorAlloc;
+void
+router_solve (void* argPtr)
+{
+    Galois::reportPageAlloc("MeminfoPre");
+    router_solve_arg_t* routerArgPtr = (router_solve_arg_t*)argPtr;
+    maze_t* mazePtr = routerArgPtr->mazePtr;
+    grid_t* gridPtr = mazePtr->gridPtr;
+    Galois::InsertBag<vector_t*> foundPointVectors;
+    Galois::Runtime::PerThreadStorage<grid_t*> localGrids;
+
+    Fn1 fn1 = { routerArgPtr, pointVectorAlloc, foundPointVectors, localGrids };
+    Galois::for_each(mazePtr->workQueuePtr->begin(), mazePtr->workQueuePtr->end(), fn1, Galois::wl<Galois::WorkList::FIFO<> >());
+
+    /*
+     * Add my paths to global list
+     */
+    list_t* pathVectorListPtr = routerArgPtr->pathVectorListPtr;
+    vector_t* vectorPtr = vector_alloc(1);
+    for (auto ii = foundPointVectors.begin(), ei = foundPointVectors.end(); ii != ei; ++ii) {
+      vector_pushBack(vectorPtr, *ii);
+    }
+    list_insert(pathVectorListPtr, vectorPtr);
+    for (unsigned ii = 0; ii < localGrids.size(); ++ii) {
+        if (*localGrids.getRemote(ii)) {
+            //PGRID_FREE(*localGrids.getRemote(ii));
+        }
+    }
+#if DEBUG
+    puts("\nFinal Grid:");
+    grid_print(gridPtr);
+#endif /* DEBUG */
+
+    TM_THREAD_EXIT();
+    Galois::reportPageAlloc("MeminfoPost");
+}
+
+
+/* =============================================================================
+ *
+ * End of router.c
+ *
+ * =============================================================================
+ */
diff -x .git -x inputs -Naur stamp-0.9.10/labyrinth/router.h stamp-g/labyrinth/router.h
--- stamp-0.9.10/labyrinth/router.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/labyrinth/router.h	2017-03-20 15:19:41.000000000 +0000
@@ -78,6 +78,10 @@
 #include "tm.h"
 #include "vector.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct router {
     long xCost;
     long yCost;
@@ -115,6 +119,9 @@
 void
 router_solve (void* argPtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* ROUTER_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/lib/deque.cpp stamp-g/lib/deque.cpp
--- stamp-0.9.10/lib/deque.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-g/lib/deque.cpp	2017-03-20 15:19:41.000000000 +0000
@@ -0,0 +1,260 @@
+#include "list.h"
+#include "vector.h"
+#include "queue.h"
+
+#include <deque>
+
+void
+list_iter_reset (list_iter_t* itPtr, list_t* listPtr) {
+  listPtr->listIterReset(itPtr, Galois::MethodFlag::NONE);
+}
+
+TM_CALLABLE
+void
+TMlist_iter_reset (TM_ARGDECL  list_iter_t* itPtr, list_t* listPtr) {
+  listPtr->listIterReset(itPtr, Galois::MethodFlag::ALL);
+}
+
+bool_t
+list_iter_hasNext (list_iter_t* itPtr, list_t* listPtr) {
+  return listPtr->listIterHasNext(itPtr);
+}
+
+TM_CALLABLE
+bool_t
+TMlist_iter_hasNext (TM_ARGDECL  list_iter_t* itPtr, list_t* listPtr) {
+  return listPtr->listIterHasNext(itPtr);
+}
+
+void*
+list_iter_next (list_iter_t* itPtr, list_t* listPtr) {
+  return listPtr->listIterNext(itPtr);
+}
+
+TM_CALLABLE
+void*
+TMlist_iter_next (TM_ARGDECL  list_iter_t* itPtr, list_t* listPtr) {
+  return listPtr->listIterNext(itPtr);
+}
+
+list_t*
+list_alloc (long (*compare)(const void*, const void*)) {
+#ifdef LIST_NO_DUPLICATES
+  return new list(compare);
+#else
+  return new list;
+#endif
+
+}
+
+void
+list_free (list_t* listPtr) {
+  delete listPtr;
+}
+
+bool_t
+list_isEmpty (list_t* listPtr) {
+  return listPtr->empty();
+}
+
+TM_CALLABLE
+bool_t
+TMlist_isEmpty (TM_ARGDECL  list_t* listPtr) {
+  listPtr->acquire();
+  return listPtr->empty();
+}
+
+long
+list_getSize (list_t* listPtr) {
+  return listPtr->size();
+}
+
+TM_CALLABLE
+long
+TMlist_getSize (TM_ARGDECL  list_t* listPtr) {
+  listPtr->acquire();
+  return listPtr->size();
+}
+
+bool_t
+list_insert (list_t* listPtr, void* dataPtr) {
+#ifdef LIST_NO_DUPLICATES
+  auto ii = listPtr->begin();
+  auto ei = listPtr->end();
+  while (ii != ei) {
+    if (listPtr->compare(*ii, dataPtr) == 0)
+      break;
+    ++ii;
+  }
+  if (ii != ei)
+    return FALSE;
+  listPtr->push_back(dataPtr);  
+  return TRUE;
+#else
+  listPtr->push_back(dataPtr);  
+  return TRUE;
+#endif
+}
+
+TM_CALLABLE
+bool_t
+TMlist_insert (TM_ARGDECL  list_t* listPtr, void* dataPtr) {
+  listPtr->acquire();
+  list_insert(listPtr, dataPtr);
+  return TRUE;
+}
+
+void
+list_clear (list_t* listPtr) {
+  listPtr->clear();
+}
+
+vector_t*
+vector_alloc (long initCapacity) {
+  return new list();
+}
+
+long
+vector_getSize (vector_t* vectorPtr) {
+  return vectorPtr->size();
+}
+
+void
+vector_free (vector_t* vectorPtr) {
+  delete vectorPtr;
+}
+
+bool_t
+vector_pushBack (vector_t* vectorPtr, void* dataPtr) {
+  vectorPtr->push_back(dataPtr);
+  return TRUE;
+}
+
+void*
+vector_popBack (vector_t* vectorPtr) {
+  if (vectorPtr->empty())
+    return NULL;
+  void* ptr = vectorPtr->back();
+  vectorPtr->pop_back();
+  return ptr;
+}
+
+void*
+vector_back (vector_t* vectorPtr) {
+  if (vectorPtr->empty())
+    return NULL;
+  return vectorPtr->back();
+}
+
+struct Compare {
+  long (*compare)(const void*, const void*);
+
+  bool operator()(const void* a, const void* b) const {
+    return compare(a, b) < 0;
+  }
+};
+
+
+void
+vector_sort (vector_t* vectorPtr, long (*compare)(const void*, const void*)) {
+  std::deque<void*> elements;
+  std::copy(vectorPtr->begin(), vectorPtr->end(), std::back_inserter(elements));
+  Compare c = { compare };
+  std::sort(elements.begin(), elements.end(), c);
+  vectorPtr->clear();
+  std::copy(elements.begin(), elements.end(), std::back_inserter(*vectorPtr));
+}
+
+bool_t
+vector_copy (vector_t* dstVectorPtr, vector_t* srcVectorPtr) {
+  dstVectorPtr->clear();
+  std::copy(srcVectorPtr->begin(), srcVectorPtr->end(), std::back_inserter(*dstVectorPtr));
+  return TRUE;
+}
+
+void
+vector_clear (vector_t* vectorPtr) {
+  vectorPtr->clear();
+}
+
+queue_t*
+queue_alloc (long initCapacity) {
+  return new list();
+}
+
+void
+queue_free (queue_t* queuePtr) {
+  delete queuePtr;
+}
+
+bool_t
+queue_isEmpty (queue_t* queuePtr) {
+  if (queuePtr->empty())
+    return TRUE;
+  return FALSE;
+}
+
+TM_CALLABLE
+bool_t
+TMqueue_isEmpty (TM_ARGDECL  queue_t* queuePtr);
+
+void
+queue_clear (queue_t* queuePtr) {
+  queuePtr->clear();
+}
+
+void
+queue_shuffle (queue_t* queuePtr, random_t* randomPtr) {
+  std::deque<void*> elements;
+  std::copy(queuePtr->begin(), queuePtr->end(), std::back_inserter(elements));
+
+  long numElement = elements.size();
+  long capacity = elements.size();
+  //long pop    = queuePtr->pop;
+  //long push   = queuePtr->push;
+  //long capacity = queuePtr->capacity;
+
+  //long numElement;
+  //if (pop < push) {
+  //  numElement = push - (pop + 1);
+  //} else {
+  //  numElement = capacity - (pop - push + 1);
+  //}
+
+  //void** elements = queuePtr->elements;
+  long i;
+  //long base = pop + 1;
+  long base = 0;
+  for (i = 0; i < numElement; i++) {
+    long r1 = random_generate(randomPtr) % numElement;
+    long r2 = random_generate(randomPtr) % numElement;
+    long i1 = (base + r1) % capacity;
+    long i2 = (base + r2) % capacity;
+    void* tmp = elements[i1];
+    elements[i1] = elements[i2];
+    elements[i2] = tmp;
+  }
+}
+
+bool_t
+queue_push (queue_t* queuePtr, void* dataPtr) {
+  queuePtr->push_back(dataPtr);
+  return TRUE;
+}
+
+TM_CALLABLE
+bool_t
+TMqueue_push (TM_ARGDECL  queue_t* queuePtr, void* dataPtr);
+
+void*
+queue_pop (queue_t* queuePtr) {
+  if (queuePtr->empty())
+    return NULL;
+  void* retval = queuePtr->front();
+  queuePtr->pop_front();
+  return retval;
+}
+
+TM_CALLABLE
+void*
+TMqueue_pop (TM_ARGDECL  queue_t* queuePtr);
diff -x .git -x inputs -Naur stamp-0.9.10/lib/force_cxx_linker.cpp stamp-g/lib/force_cxx_linker.cpp
--- stamp-0.9.10/lib/force_cxx_linker.cpp	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/lib/force_cxx_linker.cpp	2017-03-20 15:19:41.000000000 +0000
@@ -1 +0,0 @@
-static int empty_file;
diff -x .git -x inputs -Naur stamp-0.9.10/lib/list.h stamp-g/lib/list.h
--- stamp-0.9.10/lib/list.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/lib/list.h	2017-03-21 18:28:53.000000000 +0000
@@ -82,20 +82,13 @@
 extern "C" {
 #endif
 
+typedef struct list_iter {
+  void* block;
+  unsigned offset;
+} list_iter_t;
 
-typedef struct list_node {
-    void* dataPtr;
-    XTM_DECL_LOCKABLE(struct list_node*, nextPtr);
-} list_node_t;
-
-typedef list_node_t* list_iter_t;
-
-typedef struct list {
-    list_node_t head;
-    long (*compare)(const void*, const void*);   /* returns {-1,0,1}, 0 -> equal */
-    XTM_DECL_LOCKABLE(long, size);
-} list_t;
-
+struct list;
+typedef struct list list_t;
 
 /* =============================================================================
  * list_iter_reset
@@ -338,13 +331,22 @@
 Plist_clear (list_t* listPtr);
 
 
-#define PLIST_ALLOC(cmp)                Plist_alloc(cmp)
-#define PLIST_FREE(list)                Plist_free(list)
+#define PLIST_ALLOC(cmp)                list_alloc(cmp)
+#define PLIST_FREE(list)                list_free(list)
 #define PLIST_GETSIZE(list)             list_getSize(list)
-#define PLIST_INSERT(list, data)        Plist_insert(list, data)
-#define PLIST_REMOVE(list, data)        Plist_remove(list, data)
-#define PLIST_CLEAR(list)               Plist_clear(list)
-
+#define PLIST_INSERT(list, data)        list_insert(list, data)
+#define PLIST_REMOVE(list, data)        list_remove(list, data)
+#define PLIST_CLEAR(list)               list_clear(list)
+#define LIST_ITER_RESET(it, list)     list_iter_reset(it, list)
+#define LIST_ITER_HASNEXT(it, list)   list_iter_hasNext(it, list)
+#define LIST_ITER_NEXT(it, list)      list_iter_next(it, list)
+#define LIST_ALLOC(cmp)               list_alloc(cmp)
+#define LIST_FREE(list)               list_free(list)
+#define LIST_GETSIZE(list)            list_getSize(list)
+#define LIST_ISEMPTY(list)            list_isEmpty(list)
+#define LIST_FIND(list, data)         list_find(list, data)
+#define LIST_INSERT(list, data)       list_insert(list, data)
+#define LIST_REMOVE(list, data)       list_remove(list, data)
 
 #define TMLIST_ITER_RESET(it, list)     TMlist_iter_reset(TM_ARG  it, list)
 #define TMLIST_ITER_HASNEXT(it, list)   TMlist_iter_hasNext(TM_ARG  it, list)
@@ -362,6 +364,58 @@
 }
 #endif
 
+// Provide definition of list when in C++
+#ifdef __cplusplus
+#include "Galois/MethodFlags.h"
+#include "Galois/gdeque.h"
+#include "Galois/Runtime/Context.h"
+
+struct list : public Galois::gdeque<void*>
+#ifndef HTM
+              , public Galois::Runtime::Lockable 
+#endif
+{ 
+#ifdef LIST_NO_DUPLICATES
+  typedef long (*Compare)(const void*, const void*);
+  Compare compare;
+
+  list(Compare c): compare(c) { }
+  list(): compare(0) { }
+#endif
+
+  void listIterReset(list_iter_t* itPtr, Galois::MethodFlag mflag) {
+#ifndef HTM
+    Galois::Runtime::acquire(this, mflag);
+#endif
+    itPtr->block = first;
+    itPtr->offset = 0;
+  }
+
+  bool_t listIterHasNext(list_iter_t* itPtr) {
+    iterator cur((Block*) itPtr->block, itPtr->offset);
+    if (cur == end())
+      return FALSE;
+    else
+      return TRUE;
+  }
+
+  void* listIterNext(list_iter_t* itPtr) {
+    iterator cur((Block*) itPtr->block, itPtr->offset);
+    void* retval = *cur;
+    ++cur;
+    itPtr->block = cur.b;
+    itPtr->offset = cur.offset;
+    return retval;
+  }
+
+  void acquire() {
+#ifndef HTM
+    Galois::Runtime::acquire(this, Galois::MethodFlag::ALL);
+#endif
+  }
+};
+#endif
+
 
 #endif /* LIST_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/lib/map.cpp stamp-g/lib/map.cpp
--- stamp-0.9.10/lib/map.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-g/lib/map.cpp	2017-03-20 15:19:41.000000000 +0000
@@ -0,0 +1,66 @@
+#include "Galois/config.h"
+#include "map.h"
+
+hashtable_t*
+hashtable_alloc (long initNumBucket,
+                 ulong_t (*hash)(void*),
+                 long (*comparePairs)(void*, void*)) {
+  return new hashtable(initNumBucket, hash, comparePairs);
+}
+
+void
+hashtable_free (hashtable_t* hashtablePtr) {
+  delete hashtablePtr;
+}
+
+bool_t
+hashtable_containsKey (hashtable_t* hashtablePtr, void* keyPtr) {
+  if (hashtablePtr->containsKey(keyPtr))
+    return TRUE;
+  else
+    return FALSE;
+}
+
+void*
+hashtable_find (hashtable_t* hashtablePtr, void* keyPtr) {
+  return hashtablePtr->find(keyPtr, Galois::MethodFlag::NONE);
+}
+
+bool_t
+hashtable_insert (hashtable_t* hashtablePtr, void* keyPtr, void* dataPtr) {
+  if (hashtablePtr->insert(keyPtr, dataPtr, Galois::MethodFlag::NONE))
+    return TRUE;
+  return FALSE;
+}
+
+bool_t
+hashtable_remove (TM_ARGDECL  hashtable_t* hashtablePtr, void* keyPtr) {
+  if (hashtablePtr->remove(keyPtr, Galois::MethodFlag::NONE))
+    return TRUE;
+  return FALSE;
+}
+
+void*
+TMhashtable_find (TM_ARGDECL  hashtable_t* hashtablePtr, void* keyPtr) {
+  return hashtablePtr->find(keyPtr, Galois::MethodFlag::ALL);
+}
+
+bool_t
+TMhashtable_insert (TM_ARGDECL
+                    hashtable_t* hashtablePtr, void* keyPtr, void* dataPtr) {
+  if (hashtablePtr->insert(keyPtr, dataPtr, Galois::MethodFlag::ALL))
+    return TRUE;
+  return FALSE;
+}
+
+bool_t
+TMhashtable_remove (TM_ARGDECL  hashtable_t* hashtablePtr, void* keyPtr) {
+  if (hashtablePtr->remove(keyPtr, Galois::MethodFlag::ALL))
+    return TRUE;
+  return FALSE;
+}
+
+void
+TMhashtable_acquire (TM_ARGDECL  hashtable_t* hashtablePtr, void* keyPtr) {
+  hashtablePtr->acquire(keyPtr);
+}
diff -x .git -x inputs -Naur stamp-0.9.10/lib/map.h stamp-g/lib/map.h
--- stamp-0.9.10/lib/map.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/lib/map.h	2017-03-20 15:19:41.000000000 +0000
@@ -73,237 +73,443 @@
 #ifndef MAP_H
 #define MAP_H 1
 
-
 #include <stdlib.h>
-#include "pair.h"
 #include "types.h"
+#include "tm.h"
 
+// Provide definition of list when in C++
+#ifdef __cplusplus
+#include "Galois/Galois.h"
+#include "Galois/TwoLevelIteratorA.h"
+#include "Galois/Runtime/Context.h"
+#include "Galois/Runtime/mm/Mem.h"
+
+#include <map>
+#include <deque>
+#include GALOIS_CXX11_STD_HEADER(utility)
+
+template<typename Key, typename Value, typename Allocator>
+class hash_rbtree_map {
+public:
+  typedef Key key_type;
+  typedef Value value_type;
+  typedef std::pair<Key const, Value> MapPair;
+  typedef ulong_t (*HashFunction)(Key);
+  typedef long (*CompareFunction)(Key, Key);
+
+private:
+  typedef Galois::Runtime::MM::FSBGaloisAllocator<MapPair> MapAllocator;
+
+  struct Comparator {
+    CompareFunction fn;
+
+    Comparator(const CompareFunction& _fn): fn(_fn) { }
+
+    bool operator()(const Key& a1, const Key& a2) const {
+      if (fn) 
+        return fn(a1, a2) < 0;
+      return std::less<Key>()(a1, a2);
+    }
+  };
+
+  typedef std::map<Key, Value, Comparator, MapAllocator> Map;
+
+  MapAllocator heap;
+
+  struct Bucket
+#ifndef HTM
+    : public Galois::Runtime::Lockable
+#endif
+  {
+    Map entries;
+    Bucket(CompareFunction fn, const MapAllocator& a): entries(Comparator(fn), a) { }
+  };
+
+public:
+  typedef typename Allocator::template rebind<Bucket>::other bucket_allocator_type;
+
+private:
+  typedef std::deque<Bucket,bucket_allocator_type> Buckets;
+
+  Buckets buckets;
+  HashFunction hashFn;
+
+  static size_t defaultHash(Key k) {
+    union { Key as_key; size_t as_uint; } caster = { k };
+    return caster.as_uint;
+  }
+
+  size_t hash(Key k) {
+    if (hashFn)
+      return hashFn(k);
+    return defaultHash(k);
+  }
+
+  struct InnerBeginFn {
+    typename Map::iterator operator()(Bucket& b) const { return b.entries.begin(); }
+  };
+
+  struct InnerEndFn {
+    typename Map::iterator operator()(Bucket& b) const { return b.entries.end(); }
+  };
+
+  Bucket& acquireKey(Key k, Galois::MethodFlag mflag) {
+    Bucket& b = buckets[hash(k) % buckets.size()];
+#ifndef HTM
+    Galois::Runtime::acquire(&b, mflag);
+#endif
+    return b;
+  }
 
-#if defined(MAP_USE_HASHTABLE)
-
-#  include "hashtable.h"
-
-#  define MAP_T                       hashtable_t
-#  define MAP_ALLOC(hash, cmp)        hashtable_alloc(1, hash, cmp, 2, 2)
-#  define MAP_FREE(map)               hashtable_free(map)
-#  define MAP_CONTAINS(map, key)      hashtable_containsKey(map, (void*)(key))
-#  define MAP_FIND(map, key)          hashtable_find(map, (void*)(key))
-#  define MAP_INSERT(map, key, data)  hashtable_insert(map, (void*)(key), (void*)(data))
-#  define MAP_REMOVE(map, key)        hashtable_remove(map, (void*)(key))
-
-#elif defined(MAP_USE_ATREE)
-
-#  include "atree.h"
-
-#  define MAP_T                       jsw_atree_t
-#  define MAP_ALLOC(hash, cmp)        jsw_anew((cmp_f)cmp)
-#  define MAP_FREE(map)               jsw_adelete(map)
-#  define MAP_CONTAINS(map, key) \
-    ({ \
-        bool_t success = FALSE; \
-        pair_t searchPair; \
-        searchPair.firstPtr = (void*)key; \
-        if (jsw_afind(map, (void*)&searchPair) != NULL) { \
-            success = TRUE; \
-        } \
-        success; \
-     })
-#  define MAP_FIND(map, key) \
-    ({ \
-        void* dataPtr = NULL; \
-        pair_t searchPair; \
-        searchPair.firstPtr = (void*)(key); \
-        pair_t* pairPtr = (pair_t*)jsw_afind(map, (void*)&searchPair); \
-        if (pairPtr != NULL) { \
-            dataPtr = pairPtr->secondPtr; \
-        } \
-        dataPtr; \
-     })
-#  define MAP_INSERT(map, key, data) \
-    ({ \
-        bool_t success = FALSE; \
-        pair_t* insertPtr = pair_alloc((void*)(key), (void*)data); \
-        if (insertPtr != NULL) { \
-            if (jsw_ainsert(map, (void*)insertPtr)) { \
-                success = TRUE; \
-            } \
-        } \
-        success; \
-     })
-#  define MAP_REMOVE(map, key) \
-    ({ \
-        bool_t success = FALSE; \
-        pair_t searchPair; \
-        searchPair.firstPtr = (void*)(key); \
-        pair_t* pairPtr = (pair_t*)jsw_afind(map, (void*)&searchPair); \
-        if (jsw_aerase(map, (void*)&searchPair)) { \
-            pair_free(pairPtr); \
-            success = TRUE; \
-        } \
-        success; \
-     })
-
-#elif defined(MAP_USE_AVLTREE)
-
-#  include "avltree.h"
-
-#  define MAP_T                       jsw_avltree_t
-#  define MAP_ALLOC(hash, cmp)        jsw_avlnew((cmp_f)cmp)
-#  define MAP_FREE(map)               jsw_avldelete(map)
-#  define MAP_CONTAINS(map, key) \
-    ({ \
-        bool_t success = FALSE; \
-        pair_t searchPair; \
-        searchPair.firstPtr = (void*)key; \
-        if (jsw_avlfind(map, (void*)&searchPair) != NULL) { \
-            success = TRUE; \
-        } \
-        success; \
-     })
-#  define MAP_FIND(map, key) \
-    ({ \
-        void* dataPtr = NULL; \
-        pair_t searchPair; \
-        searchPair.firstPtr = (void*)(key); \
-        pair_t* pairPtr = (pair_t*)jsw_avlfind(map, (void*)&searchPair); \
-        if (pairPtr != NULL) { \
-            dataPtr = pairPtr->secondPtr; \
-        } \
-        dataPtr; \
-     })
-#  define MAP_INSERT(map, key, data) \
-    ({ \
-        bool_t success = FALSE; \
-        pair_t* insertPtr = pair_alloc((void*)(key), (void*)data); \
-        if (insertPtr != NULL) { \
-            if (jsw_avlinsert(map, (void*)insertPtr)) { \
-                success = TRUE; \
-            } \
-        } \
-        success; \
-     })
-#  define MAP_REMOVE(map, key) \
-    ({ \
-        bool_t success = FALSE; \
-        pair_t searchPair; \
-        searchPair.firstPtr = (void*)(key); \
-        pair_t* pairPtr = (pair_t*)jsw_avlfind(map, (void*)&searchPair); \
-        if (jsw_avlerase(map, (void*)&searchPair)) { \
-            pair_free(pairPtr); \
-            success = TRUE; \
-        } \
-        success; \
-     })
-
-#  define PMAP_ALLOC(hash, cmp)        Pjsw_avlnew((cmp_f)cmp)
-#  define PMAP_FREE(map)               Pjsw_avldelete(map)
-#  define PMAP_INSERT(map, key, data) \
-    ({ \
-        bool_t success = FALSE; \
-        pair_t* insertPtr = PPAIR_ALLOC((void*)(key), (void*)data); \
-        if (insertPtr != NULL) { \
-            if (Pjsw_avlinsert(map, (void*)insertPtr)) { \
-                success = TRUE; \
-            } \
-        } \
-        success; \
-     })
-#  define PMAP_REMOVE(map, key) \
-    ({ \
-        bool_t success = FALSE; \
-        pair_t searchPair; \
-        searchPair.firstPtr = (void*)(key); \
-        pair_t* pairPtr = (pair_t*)jsw_avlfind(map, (void*)&searchPair); \
-        if (Pjsw_avlerase(map, (void*)&searchPair)) { \
-            PPAIR_FREE(pairPtr); \
-            success = TRUE; \
-        } \
-        success; \
-     })
-
-
-#elif defined(MAP_USE_RBTREE)
-
-#  include "rbtree.h"
-
-#  define MAP_T                       rbtree_t
-#  define MAP_ALLOC(hash, cmp)        rbtree_alloc(cmp)
-#  define MAP_FREE(map)               rbtree_free(map)
-
-#  define MAP_CONTAINS(map, key)      rbtree_contains(map, (void*)(key))
-#  define MAP_FIND(map, key)          rbtree_get(map, (void*)(key))
-#  define MAP_INSERT(map, key, data) \
-    rbtree_insert(map, (void*)(key), (void*)(data))
-#  define MAP_REMOVE(map, key)        rbtree_delete(map, (void*)(key))
-
-#  define TMMAP_CONTAINS(map, key)    TMRBTREE_CONTAINS(map, (void*)(key))
-#  define TMMAP_FIND(map, key)        TMRBTREE_GET(map, (void*)(key))
-#  define TMMAP_INSERT(map, key, data) \
-    TMRBTREE_INSERT(map, (void*)(key), (void*)(data))
-#  define TMMAP_REMOVE(map, key)      TMRBTREE_DELETE(map, (void*)(key))
-
-
-#elif defined(MAP_USE_SKIPLIST)
-
-#  include "skiplist.h"
-
-#  define SKIPLIST_MAX_HEIGHT (64)
-
-#  define MAP_T                       jsw_skip_t
-#  define MAP_ALLOC(hash, cmp)        jsw_snew(SKIPLIST_MAX_HEIGHT, (cmp_f)cmp)
-#  define MAP_FREE(map)               jsw_sdelete(map)
-#  define MAP_CONTAINS(map, key) \
-    ({ \
-        bool_t success = FALSE; \
-        pair_t searchPair; \
-        searchPair.firstPtr = (void*)key; \
-        if (jsw_sfind(map, (void*)&searchPair) != NULL) { \
-            success = TRUE; \
-        } \
-        success; \
-     })
-#  define MAP_FIND(map, key) \
-    ({ \
-        void* dataPtr = NULL; \
-        pair_t* pairPtr; \
-        pair_t searchPair; \
-        searchPair.firstPtr = (void*)(key); \
-        pairPtr = (pair_t*)jsw_sfind(map, (void*)&searchPair); \
-        if (pairPtr != NULL) { \
-            dataPtr = pairPtr->secondPtr; \
-        } \
-        dataPtr; \
-     })
-#  define MAP_INSERT(map, key, data) \
-    ({ \
-        bool_t success = FALSE; \
-        pair_t* insertPtr = pair_alloc((void*)(key), (void*)data); \
-        if (insertPtr != NULL) { \
-            if (jsw_sinsert(map, (void*)insertPtr)) { \
-                success = TRUE; \
-            } \
-        } \
-        success; \
-     })
-#  define MAP_REMOVE(map, key) \
-    ({ \
-        bool_t success = FALSE; \
-        pair_t searchPair; \
-        searchPair.firstPtr = (void*)(key); \
-        pairPtr = (pair_t*)jsw_sfind(map, (void*)&searchPair); \
-        if (jsw_serase(map, (void*)&searchPair)) { \
-            pair_free(pairPtr); \
-            success = TRUE; \
-        } \
-        success; \
-     })
+public:
+  typedef Galois::TwoLevelIteratorA<
+    typename Buckets::iterator,
+    typename Map::iterator,
+    std::forward_iterator_tag,
+    InnerBeginFn,
+    InnerEndFn> iterator;
+
+  hash_rbtree_map(size_t initialSize, HashFunction _hashFn, CompareFunction compareFn, const bucket_allocator_type& bucketAlloc = bucket_allocator_type()): buckets(bucketAlloc), hashFn(_hashFn)  {
+    unsigned n = std::max((size_t) Galois::getActiveThreads() * 1023 + 1, initialSize);
+    if (n & 1)
+      ; // odd
+    else
+      n += 1;
+
+    for (unsigned i = 0; i < n; ++i)
+      buckets.push_back(Bucket(compareFn, heap));
+  }
+
+  iterator begin() {
+    return iterator(buckets.begin(), buckets.end(), buckets.begin(), InnerBeginFn(), InnerEndFn());
+  }
+
+  iterator end() {
+    return iterator(buckets.begin(), buckets.end(), buckets.end(), InnerBeginFn(), InnerEndFn());
+  }
+
+  Value find(Key k, Galois::MethodFlag mflag) {
+    Bucket& b = acquireKey(k, mflag);
+    typename Map::iterator ii = b.entries.find(k);
+    if (ii != b.entries.end())
+      return ii->second;
+    return Value();
+  }
+
+  bool containsKey(Key k) {
+    Bucket& b = buckets[hash(k) % buckets.size()];
+    typename Map::iterator ii = b.entries.find(k);
+    return ii != b.entries.end();
+  }
+
+  bool insert(Key k, Value v, Galois::MethodFlag mflag) {
+    Bucket& b = acquireKey(k, mflag);
+    std::pair<typename Map::iterator,bool> p = b.entries.insert(typename Map::value_type(k, v));
+    return p.second;
+  }
+
+  bool remove(Key k, Galois::MethodFlag mflag) {
+    Bucket& b = acquireKey(k, mflag);
+    size_t v = b.entries.erase(k);
+    return v > 0;
+  }
+
+  void acquire(Key k) {
+    acquireKey(k, Galois::MethodFlag::ALL);
+  }
+};
+
+template<typename Key, typename Value, typename Allocator>
+class hash_list_map {
+public:
+  typedef Key key_type;
+  typedef Value value_type;
+  typedef std::pair<Key const, Value> MapPair;
+  typedef ulong_t (*HashFunction)(Key);
+  typedef long (*CompareFunction)(Key, Key);
+
+private:
+  struct Entry
+    : public MapPair
+#ifndef HTM
+      , public Galois::Runtime::Lockable
+#endif
+  {
+    Entry* next;
+    Entry(const Key& k, const Value& v): MapPair(k, v), next(0) { }
+  };
+
+  struct EntryIterator: public boost::iterator_facade<EntryIterator, Entry, boost::forward_traversal_tag> {
+    Entry * value;
+    EntryIterator(Entry* e = 0): value(e) { }
+    void increment() { value = value->next; }
+    bool equal(const EntryIterator& o) const { return value == o.value; }
+    Entry& dereference() const { return *value; }
+  };
+
+  struct Bucket
+#ifndef HTM
+    : public Galois::Runtime::Lockable
+#endif
+  {
+    Entry* next;
+    Bucket(): next(0) { }
+  };
+
+  typedef Galois::Runtime::MM::FSBGaloisAllocator<Entry> EntryAllocator;
+
+  struct Comparator {
+    CompareFunction fn;
+
+    Comparator(const CompareFunction& _fn): fn(_fn) { }
+
+    bool operator()(const Key& a1, const Key& a2) const {
+      if (fn) 
+        return fn(a1, a2) < 0;
+      return std::less<Key>()(a1, a2);
+    }
+  };
+
+  EntryAllocator heap;
+  Comparator compareFn;
+
+public:
+  typedef typename Allocator::template rebind<Bucket>::other bucket_allocator_type;
+
+private:
+  typedef std::deque<Bucket,bucket_allocator_type> Buckets;
+
+  Buckets buckets;
+  HashFunction hashFn;
+
+  static size_t defaultHash(Key k) {
+    union { Key as_key; size_t as_uint; } caster = { k };
+    return caster.as_uint;
+  }
+
+  size_t hash(Key k) {
+    if (hashFn)
+      return hashFn(k);
+    return defaultHash(k);
+  }
+
+  struct InnerBeginFn {
+    EntryIterator operator()(Bucket& b) const { return EntryIterator(b.next); }
+  };
+
+  struct InnerEndFn {
+    EntryIterator operator()(Bucket& b) const { return EntryIterator(NULL); }
+  };
+
+  Bucket& acquireKey(Key k, Galois::MethodFlag mflag) {
+    Bucket& b = buckets[hash(k) % buckets.size()];
+#ifndef HTM
+    Galois::Runtime::acquire(&b, mflag);
+#endif
+    return b;
+  }
 
+  bool equalKey(const Key& k1, const Key& k2) {
+    return !compareFn(k1, k2) && !compareFn(k2, k1);
+  }
+
+  bool insertAt(Bucket& b, const Key& k, const Value& v) {
+    Entry** eptr = &b.next;
+    while (true) {
+      if (*eptr == NULL) {
+        *eptr = heap.allocate(1);
+        heap.construct(*eptr, k, v);
+        return true;
+      }
+      if (equalKey((*eptr)->first, k)) {
+        return false;
+      }
+      eptr = &(*eptr)->next;
+    }
+  }
+
+public:
+  typedef Galois::TwoLevelIteratorA<
+    typename Buckets::iterator,
+    EntryIterator,
+    std::forward_iterator_tag,
+    InnerBeginFn,
+    InnerEndFn> iterator;
+
+  hash_list_map(size_t initialSize, HashFunction h, CompareFunction c, const bucket_allocator_type& bucketAlloc = bucket_allocator_type()): compareFn(c), buckets(bucketAlloc), hashFn(h)  {
+    unsigned n = std::max((size_t) Galois::getActiveThreads() * 1023 + 1, initialSize);
+    if (n & 1)
+      ; // odd
+    else
+      n += 1;
+
+    for (unsigned i = 0; i < n; ++i)
+      buckets.push_back(Bucket());
+  }
+
+  iterator begin() {
+    return iterator(buckets.begin(), buckets.end(), buckets.begin(), InnerBeginFn(), InnerEndFn());
+  }
+
+  iterator end() {
+    return iterator(buckets.begin(), buckets.end(), buckets.end(), InnerBeginFn(), InnerEndFn());
+  }
+
+  Value find(Key k, Galois::MethodFlag mflag) {
+    Bucket& b = acquireKey(k, mflag);
+    for (Entry* e = b.next; e; e = e->next) {
+      if (equalKey(e->first, k))
+        return e->second;
+    }
+    return Value();
+  }
+
+  bool containsKey(Key k) {
+    Bucket& b = buckets[hash(k) % buckets.size()];
+    for (Entry* e = b.next; e; e = e->next) {
+      if (equalKey(e->first, k))
+        return true;
+    }
+    return false;
+  }
+
+  bool insert(Key k, Value v, Galois::MethodFlag mflag) {
+    Bucket& b = acquireKey(k, mflag); // XXX
+    return insertAt(b, k, v);
+  }
+
+  bool remove(Key k, Galois::MethodFlag mflag) {
+    abort();
+    return false;
+  }
+
+  void acquire(Key k) {
+    acquireKey(k, Galois::MethodFlag::ALL);
+  }
+
+  //! Modifies argument leaving it in unspecified state
+  void mergeWith(hash_list_map& o) {
+    assert(buckets.size() == o.buckets.size());
+    for (size_t i = 0, n = buckets.size(); i < n; ++i) {
+      for (Entry* e = o.buckets[i].next; e; e = e->next)
+        insertAt(buckets[i], e->first, e->second);
+    }
+  }
+};
+
+
+#ifdef USE_HASH_LIST_MAP
+struct hashtable : public hash_list_map<void*,void*,std::allocator<void*> > {
+  typedef hash_list_map<void*,void*,std::allocator<void*> > Super;
+
+  hashtable(size_t initialSize, hashtable::HashFunction _hashFn, hashtable::CompareFunction compareFn):
+    Super(initialSize, _hashFn, compareFn)
+    { }
+};
 #else
+struct hashtable : public hash_rbtree_map<void*,void*,std::allocator<void*> > {
+  typedef hash_rbtree_map<void*,void*,std::allocator<void*> > Super;
+
+  hashtable(size_t initialSize, hashtable::HashFunction _hashFn, hashtable::CompareFunction compareFn):
+    Super(initialSize, _hashFn, compareFn)
+    { }
+};
+#endif
 
-#  error "MAP type is not specified"
+#endif
 
+#ifdef __cplusplus
+extern "C" {
 #endif
 
+struct hashtable;
+typedef struct hashtable hashtable_t;
+
+hashtable_t*
+hashtable_alloc (long initNumBucket,
+                 ulong_t (*hash)(void*),
+                 long (*comparePairs)(void*, void*));
+
+/* =============================================================================
+ * hashtable_free
+ * =============================================================================
+ */
+void
+hashtable_free (hashtable_t* hashtablePtr);
+
+/* =============================================================================
+ * hashtable_containsKey
+ * =============================================================================
+ */
+bool_t
+hashtable_containsKey (hashtable_t* hashtablePtr, void* keyPtr);
+
+/* =============================================================================
+ * hashtable_find
+ * -- Returns NULL on failure, else pointer to data associated with key
+ * =============================================================================
+ */
+void*
+hashtable_find (hashtable_t* hashtablePtr, void* keyPtr);
+
+/* =============================================================================
+ * hashtable_insert
+ * =============================================================================
+ */
+bool_t
+hashtable_insert (hashtable_t* hashtablePtr, void* keyPtr, void* dataPtr);
+
+/* =============================================================================
+ * TMhashtable_remove
+ * -- Returns TRUE if successful, else FALSE
+ * =============================================================================
+ */
+bool_t
+hashtable_remove (TM_ARGDECL  hashtable_t* hashtablePtr, void* keyPtr);
+
+/* =============================================================================
+ * TMhashtable_find
+ * -- Returns NULL on failure, else pointer to data associated with key
+ * =============================================================================
+ */
+void*
+TMhashtable_find (TM_ARGDECL  hashtable_t* hashtablePtr, void* keyPtr);
+
+/* =============================================================================
+ * TMhashtable_insert
+ * =============================================================================
+ */
+bool_t
+TMhashtable_insert (TM_ARGDECL
+                    hashtable_t* hashtablePtr, void* keyPtr, void* dataPtr);
+
+/* =============================================================================
+ * TMhashtable_remove
+ * -- Returns TRUE if successful, else FALSE
+ * =============================================================================
+ */
+bool_t
+TMhashtable_remove (TM_ARGDECL  hashtable_t* hashtablePtr, void* keyPtr);
+
+
+void TMhashtable_acquire (TM_ARGDECL
+                    hashtable_t* hashtablePtr, void* keyPtr);
+
+#define MAP_T                       hashtable_t
+#define MAP_ALLOC(hash, cmp)        hashtable_alloc(16, hash, cmp)
+#define MAP_FREE(map)               hashtable_free(map)
+#define MAP_CONTAINS(map, key)      hashtable_containsKey(map, (void*)(key))
+#define MAP_FIND(map, key)          hashtable_find(map, (void*)(key))
+#define MAP_INSERT(map, key, data)  hashtable_insert(map, (void*)(key), (void*)(data))
+#define MAP_REMOVE(map, key)        hashtable_remove(map, (void*)(key))
+#define TMMAP_FIND(ht, k)           TMhashtable_find(TM_ARG  ht, (void*)(k))
+#define TMMAP_INSERT(ht, k, d)      TMhashtable_insert(TM_ARG  ht, (void*)(k), (void*)(d))
+#define TMMAP_REMOVE(ht, k)         TMhashtable_remove(TM_ARG  ht, (void*)(k))
+#define TMMAP_ACQUIRE(ht, k)        TMhashtable_acquire(TM_ARG  ht, (void*)(k))
+
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* MAP_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/lib/mt19937ar.c stamp-g/lib/mt19937ar.c
--- stamp-0.9.10/lib/mt19937ar.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/lib/mt19937ar.c	2017-03-21 19:04:59.000000000 +0000
@@ -124,7 +124,7 @@
     unsigned long mti;
 
     mt[0]= s & 0xffffffffUL;
-    for (mti=1; mti<N; mti++) {
+    for (mti=1; mti<RANDOM_N; mti++) {
         mt[mti] =
           (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);
         /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
@@ -147,25 +147,25 @@
     long i, j, k;
     init_genrand(mt, mtiPtr, 19650218UL);
     i=1; j=0;
-    k = (N>key_length ? N : key_length);
+    k = (RANDOM_N>key_length ? RANDOM_N : key_length);
     for (; k; k--) {
         mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
           + init_key[j] + j; /* non linear */
         mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
         i++; j++;
-        if (i>=N) { mt[0] = mt[N-1]; i=1; }
+        if (i>=RANDOM_N) { mt[0] = mt[RANDOM_N-1]; i=1; }
         if (j>=key_length) j=0;
     }
-    for (k=N-1; k; k--) {
+    for (k=RANDOM_N-1; k; k--) {
         mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))
           - i; /* non linear */
         mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
         i++;
-        if (i>=N) { mt[0] = mt[N-1]; i=1; }
+        if (i>=RANDOM_N) { mt[0] = mt[RANDOM_N-1]; i=1; }
     }
 
     mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */
-    (*mtiPtr) = N + 1;
+    (*mtiPtr) = RANDOM_N + 1;
 }
 
 /* generates a random number on [0,0xffffffff]-interval */
@@ -177,22 +177,22 @@
 
     /* mag01[x] = x * MATRIX_A  for x=0,1 */
 
-    if (mti >= N) { /* generate N words at one time */
+    if (mti >= RANDOM_N) { /* generate N words at one time */
         long kk;
 
-        if (mti == N+1)   /* if init_genrand() has not been called, */
+        if (mti == RANDOM_N+1)   /* if init_genrand() has not been called, */
             init_genrand(mt, mtiPtr, 5489UL); /* a default initial seed is used */
 
-        for (kk=0;kk<N-M;kk++) {
+        for (kk=0;kk<RANDOM_N-M;kk++) {
             y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
             mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];
         }
-        for (;kk<N-1;kk++) {
+        for (;kk<RANDOM_N-1;kk++) {
             y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
-            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
+            mt[kk] = mt[kk+(M-RANDOM_N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
         }
-        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
-        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];
+        y = (mt[RANDOM_N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
+        mt[RANDOM_N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];
 
         mti = 0;
     }
diff -x .git -x inputs -Naur stamp-0.9.10/lib/mt19937ar.h stamp-g/lib/mt19937ar.h
--- stamp-0.9.10/lib/mt19937ar.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/lib/mt19937ar.h	2017-03-21 19:03:51.000000000 +0000
@@ -132,15 +132,15 @@
 
 
 /* Period parameters */
-#define N 624
+#define RANDOM_N 624
 #define M 397
 #define MATRIX_A 0x9908b0dfUL   /* constant vector a */
 #define UPPER_MASK 0x80000000UL /* most significant w-r bits */
 #define LOWER_MASK 0x7fffffffUL /* least significant r bits */
 
 #if 0
-static unsigned long mt[N]; /* the array for the state vector  */
-static long mti=N+1; /* mti==N+1 means mt[N] is not initialized */
+static unsigned long mt[RANDOM_N]; /* the array for the state vector  */
+static long mti=N+1; /* mti==N+1 means mt[RANDOM_N] is not initialized */
 #endif
 
 /* initializes mt[N] with a seed */
diff -x .git -x inputs -Naur stamp-0.9.10/lib/pair.c stamp-g/lib/pair.c
--- stamp-0.9.10/lib/pair.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/lib/pair.c	2017-03-20 15:19:41.000000000 +0000
@@ -94,6 +94,7 @@
 }
 
 
+#if 0
 /* =============================================================================
  * Ppair_alloc
  * -- Returns NULL if failure
@@ -132,7 +133,7 @@
 
     return pairPtr;
 }
-
+#endif
 
 /* =============================================================================
  * pair_free
@@ -144,7 +145,7 @@
     free(pairPtr);
 }
 
-
+#if 0
 /* =============================================================================
  * Ppair_free
  * =============================================================================
@@ -166,6 +167,7 @@
     TM_FREE(pairPtr);
 }
 
+#endif
 
 /* =============================================================================
  * pair_swap
diff -x .git -x inputs -Naur stamp-0.9.10/lib/pair.h stamp-g/lib/pair.h
--- stamp-0.9.10/lib/pair.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/lib/pair.h	2017-03-21 18:30:26.000000000 +0000
@@ -144,13 +144,13 @@
 void
 pair_swap (pair_t* pairPtr);
 
-
+#if 0
 #define PPAIR_ALLOC(f,s)    Ppair_alloc(f, s)
 #define PPAIR_FREE(p)       Ppair_free(p)
 
 #define TMPAIR_ALLOC(f,s)   TMpair_alloc(TM_ARG  f, s)
 #define TMPAIR_FREE(p)      TMpair_free(TM_ARG  p)
-
+#endif
 
 #ifdef __cplusplus
 }
diff -x .git -x inputs -Naur stamp-0.9.10/lib/queue.h stamp-g/lib/queue.h
--- stamp-0.9.10/lib/queue.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/lib/queue.h	2017-03-21 18:30:51.000000000 +0000
@@ -74,6 +74,7 @@
 
 
 #include "random.h"
+#include "list.h"
 #include "tm.h"
 #include "types.h"
 
@@ -83,7 +84,7 @@
 #endif
 
 
-typedef struct queue queue_t;
+typedef struct list queue_t;
 
 
 /* =============================================================================
@@ -95,22 +96,6 @@
 
 
 /* =============================================================================
- * Pqueue_alloc
- * =============================================================================
- */
-queue_t*
-Pqueue_alloc (long initCapacity);
-
-
-/* =============================================================================
- * TMqueue_alloc
- * =============================================================================
- */
-queue_t*
-TMqueue_alloc (TM_ARGDECL  long initCapacity);
-
-
-/* =============================================================================
  * queue_free
  * =============================================================================
  */
@@ -119,22 +104,6 @@
 
 
 /* =============================================================================
- * Pqueue_free
- * =============================================================================
- */
-void
-Pqueue_free (queue_t* queuePtr);
-
-
-/* =============================================================================
- * TMqueue_free
- * =============================================================================
- */
-void
-TMqueue_free (TM_ARGDECL  queue_t* queuePtr);
-
-
-/* =============================================================================
  * queue_isEmpty
  * =============================================================================
  */
@@ -176,14 +145,6 @@
 
 
 /* =============================================================================
- * Pqueue_push
- * =============================================================================
- */
-bool_t
-Pqueue_push (queue_t* queuePtr, void* dataPtr);
-
-
-/* =============================================================================
  * TMqueue_push
  * =============================================================================
  */
@@ -209,12 +170,12 @@
 TMqueue_pop (TM_ARGDECL  queue_t* queuePtr);
 
 
-#define PQUEUE_ALLOC(c)     Pqueue_alloc(c)
-#define PQUEUE_FREE(q)      Pqueue_free(q)
+#define PQUEUE_ALLOC(c)     queue_alloc(c)
+#define PQUEUE_FREE(q)      queue_free(q)
 #define PQUEUE_ISEMPTY(q)   queue_isEmpty(q)
 #define PQUEUE_CLEAR(q)     queue_clear(q)
 #define PQUEUE_SHUFFLE(q)   queue_shuffle(q, randomPtr);
-#define PQUEUE_PUSH(q, d)   Pqueue_push(q, (void*)(d))
+#define PQUEUE_PUSH(q, d)   queue_push(q, (void*)(d))
 #define PQUEUE_POP(q)       queue_pop(q)
 
 #define TMQUEUE_ALLOC(c)    TMqueue_alloc(TM_ARG_ALONE  c)
diff -x .git -x inputs -Naur stamp-0.9.10/lib/random.c stamp-g/lib/random.c
--- stamp-0.9.10/lib/random.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/lib/random.c	2017-03-21 19:05:19.000000000 +0000
@@ -72,7 +72,6 @@
 #include <stdlib.h>
 #include "mt19937ar.h"
 #include "random.h"
-#include "tm.h"
 
 
 /* =============================================================================
@@ -85,7 +84,7 @@
 {
     random_t* randomPtr = (random_t*)malloc(sizeof(random_t));
     if (randomPtr != NULL) {
-        randomPtr->mti = N;
+        randomPtr->mti = RANDOM_N;
         init_genrand(randomPtr->mt, &(randomPtr->mti), RANDOM_DEFAULT_SEED);
     }
 
@@ -101,9 +100,9 @@
 random_t*
 Prandom_alloc (void)
 {
-    random_t* randomPtr = (random_t*)P_MALLOC(sizeof(random_t));
+    random_t* randomPtr = (random_t*)malloc(sizeof(random_t));
     if (randomPtr != NULL) {
-        randomPtr->mti = N;
+        randomPtr->mti = RANDOM_N;
         init_genrand(randomPtr->mt, &(randomPtr->mti), RANDOM_DEFAULT_SEED);
     }
 
@@ -129,7 +128,7 @@
 void
 Prandom_free (random_t* randomPtr)
 {
-    P_FREE(randomPtr);
+    free(randomPtr);
 }
 
 
diff -x .git -x inputs -Naur stamp-0.9.10/lib/random.h stamp-g/lib/random.h
--- stamp-0.9.10/lib/random.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/lib/random.h	2017-03-21 19:05:11.000000000 +0000
@@ -85,10 +85,13 @@
 
 typedef struct random {
     unsigned long (*rand)(unsigned long*, unsigned long*);
-    unsigned long mt[N];
+    unsigned long mt[RANDOM_N];
     unsigned long mti;
 } random_t;
 
+inline void random_init(random_t* randomPtr) {
+  randomPtr->mti = RANDOM_N;
+}
 
 /* =============================================================================
  * random_alloc
diff -x .git -x inputs -Naur stamp-0.9.10/lib/thread.c stamp-g/lib/thread.c
--- stamp-0.9.10/lib/thread.c	2017-03-21 17:35:07.000000000 +0000
+++ stamp-g/lib/thread.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,568 +0,0 @@
-/* =============================================================================
- *
- * thread.c
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <stdlib.h>
-#ifdef USE_PAPI
-#include <papi.h>
-#include <papiStdEventDefs.h>
-#endif
-#include "thread.h"
-#include "types.h"
-#include "tm.h"
-
-static THREAD_LOCAL_T    global_threadId;
-static long              global_numThread       = 1;
-static THREAD_BARRIER_T* global_barrierPtr      = NULL;
-static long*             global_threadIds       = NULL;
-static THREAD_ATTR_T     global_threadAttr;
-static THREAD_T*         global_threads         = NULL;
-static void            (*global_funcPtr)(void*) = NULL;
-static void*             global_argPtr          = NULL;
-static volatile bool_t   global_doShutdown      = FALSE;
-
-#ifdef USE_PAPI
-static int isInit;
-static int isSampling;
-static __thread int papiEventSet = PAPI_NULL;
-
-static int papiEvents[3] = {PAPI_L3_TCA, PAPI_L3_TCM, PAPI_TOT_CYC};
-static const char* papiNames[3] = {"L3_ACCESSES", "L3_MISSES", "CyclesCounter"};
-
-//static int papiEvents[2] = {PAPI_TOT_INS, PAPI_TOT_CYC};
-//static const char* papiNames[2] = {"Instructions", "Cycles"};
-static const int maxThreads = 128;
-//static int papiEvents[2] = {PAPI_L1_DCM, PAPI_TOT_CYC};
-//static const char* papiNames[2] = {"L1DCMCounter", "CyclesCounter"};
-static long_long papiResults[(sizeof(papiEvents)/sizeof(*papiEvents)) * 128];
-
-static void handle_error(const char* str) {
-  fprintf(stderr, str);
-  abort();
-}
-
-static void begin(long threadId) {
-  if (threadId == 0) {
-    if (isSampling)
-      handle_error("Sampling already begun");
-    isSampling = 1;
-  } else if (!isSampling) {
-    return;
-  }
-
-  int rv;
-
-  // Init library
-  if (!isInit) {
-    rv = PAPI_library_init(PAPI_VER_CURRENT);
-    if (rv != PAPI_VER_CURRENT && rv < 0) {
-      handle_error("PAPI library version mismatch!");
-    }
-    if (rv < 0) handle_error(PAPI_strerror(rv));
-    if ((rv = PAPI_thread_init(pthread_self)) != PAPI_OK)
-      handle_error(PAPI_strerror(rv));
-    isInit = 1;
-  }
-  // Register thread
-  if ((rv = PAPI_register_thread()) != PAPI_OK) 
-    handle_error(PAPI_strerror(rv));
-  // Create the Event Set
-  if ((rv = PAPI_create_eventset(&papiEventSet)) != PAPI_OK)
-    handle_error(PAPI_strerror(rv));
-  if ((rv = PAPI_add_events(papiEventSet, papiEvents, sizeof(papiEvents)/sizeof(*papiEvents))) != PAPI_OK)
-    handle_error(PAPI_strerror(rv));
-  // Start counting events in the event set
-  if ((rv = PAPI_start(papiEventSet)) != PAPI_OK)
-    handle_error(PAPI_strerror(rv));
-}
-
-static void end(long threadId) {
-  if (threadId == 0) {
-    if (!isSampling)
-      handle_error("Sampling not yet begun");
-    isSampling = 0;
-  } else if (!isSampling) {
-    return;
-  }
-
-  int rv;
-
-  long_long results[sizeof(papiNames)/sizeof(*papiNames)];
-
-  // Get the values
-  if ((rv = PAPI_stop(papiEventSet, results)) != PAPI_OK)
-    handle_error(PAPI_strerror(rv));
-  // Remove all events in the eventset
-  if ((rv = PAPI_cleanup_eventset(papiEventSet)) != PAPI_OK)
-    handle_error(PAPI_strerror(rv));
-  // Free all memory and data structures, EventSet must be empty.
-  if ((rv = PAPI_destroy_eventset(&papiEventSet)) != PAPI_OK)
-    handle_error(PAPI_strerror(rv));
-  // Unregister thread
-  if ((rv = PAPI_unregister_thread()) != PAPI_OK) 
-    handle_error(PAPI_strerror(rv));
-
-  if (threadId >= maxThreads)
-    handle_error("too many threads");
-
-  for (unsigned i = 0; i < sizeof(papiNames)/sizeof(*papiNames); ++i)
-    papiResults[sizeof(papiEvents)/sizeof(*papiEvents) * threadId + i] += results[i];
-
-  if (threadId == 0) {
-    printf("\n");
-    printf("STATTYPE,LOOP,CATEGORY,n,sum");
-    for (int t = 0; t < maxThreads; ++t) {
-      printf(",T%d", t);
-    }
-    printf("\n");
-    for (unsigned i = 0; i < sizeof(papiNames)/sizeof(*papiNames); ++i) {
-      long_long sum = 0;
-      for (int t = 0; t < maxThreads; ++t) {
-        sum += papiResults[sizeof(papiEvents)/sizeof(*papiEvents) * t + i];
-      }
-      printf("STAT,(NULL),%s,%d,%ld", papiNames[i], maxThreads, sum);
-      for (int t = 0; t < maxThreads; ++t) {
-        printf(",%ld", papiResults[sizeof(papiEvents)/sizeof(*papiEvents) * t + i]);
-      }
-      printf("\n");
-    }
-  }
-}
-
-void thread_begin_timing() {
-  begin(0);
-}
-
-void thread_end_timing() {
-  end(0);
-}
-static void thread_begin(long threadId) {
-  if (threadId == 0)
-    return;
-  begin(threadId);
-}
-static void thread_end(long threadId) {
-  if (threadId == 0)
-    return;
-  end(threadId);
-}
-#else
-void thread_end_timing() { }
-void thread_begin_timing() { }
-static void thread_begin(long x) { }
-static void thread_end(long x) { }
-#endif
-/* =============================================================================
- * threadWait
- * -- Synchronizes all threads to start/stop parallel section
- * =============================================================================
- */
-static void
-threadWait (void* argPtr)
-{
-    long threadId = *(long*)argPtr;
-
-    THREAD_LOCAL_SET(global_threadId, (long)threadId);
-
-    while (1) {
-        THREAD_BARRIER(global_barrierPtr, threadId); /* wait for start parallel */
-        if (global_doShutdown) {
-            break;
-        }
-        thread_begin(threadId);
-        global_funcPtr(global_argPtr);
-        thread_end(threadId);
-        THREAD_BARRIER(global_barrierPtr, threadId); /* wait for end parallel */
-        if (threadId == 0) {
-            break;
-        }
-    }
-}
-
-
-/* =============================================================================
- * thread_startup
- * -- Create pool of secondary threads
- * -- numThread is total number of threads (primary + secondaries)
- * =============================================================================
- */
-void
-thread_startup (long numThread)
-{
-#if !defined(STM) && !defined(HTM)
-    if (numThread > 1) {
-      printf("This application does not support multiple threads\n");
-      abort();
-    }
-#endif
-    long i;
-
-    global_numThread = numThread;
-    global_doShutdown = FALSE;
-
-    /* Set up barrier */
-    assert(global_barrierPtr == NULL);
-    global_barrierPtr = THREAD_BARRIER_ALLOC(numThread);
-    assert(global_barrierPtr);
-    THREAD_BARRIER_INIT(global_barrierPtr, numThread);
-
-    /* Set up ids */
-    THREAD_LOCAL_INIT(global_threadId);
-    assert(global_threadIds == NULL);
-    global_threadIds = (long*)malloc(numThread * sizeof(long));
-    assert(global_threadIds);
-    for (i = 0; i < numThread; i++) {
-        global_threadIds[i] = i;
-    }
-
-    /* Set up thread list */
-    assert(global_threads == NULL);
-    global_threads = (THREAD_T*)malloc(numThread * sizeof(THREAD_T));
-    assert(global_threads);
-
-    /* Set up pool */
-    THREAD_ATTR_INIT(global_threadAttr);
-    for (i = 1; i < numThread; i++) {
-        THREAD_CREATE(global_threads[i],
-                      global_threadAttr,
-                      &threadWait,
-                      &global_threadIds[i]);
-    }
-
-    /*
-     * Wait for primary thread to call thread_start
-     */
-}
-
-
-/* =============================================================================
- * thread_start
- * -- Make primary and secondary threads execute work
- * -- Should only be called by primary thread
- * -- funcPtr takes one arguments: argPtr
- * =============================================================================
- */
-void
-thread_start (void (*funcPtr)(void*), void* argPtr)
-{
-    global_funcPtr = funcPtr;
-    global_argPtr = argPtr;
-
-    long threadId = 0; /* primary */
-    threadWait((void*)&threadId);
-}
-
-
-/* =============================================================================
- * thread_shutdown
- * -- Primary thread kills pool of secondary threads
- * =============================================================================
- */
-void
-thread_shutdown ()
-{
-    /* Make secondary threads exit wait() */
-    global_doShutdown = TRUE;
-    THREAD_BARRIER(global_barrierPtr, 0);
-
-    long numThread = global_numThread;
-
-    long i;
-    for (i = 1; i < numThread; i++) {
-        THREAD_JOIN(global_threads[i]);
-    }
-
-    THREAD_BARRIER_FREE(global_barrierPtr);
-    global_barrierPtr = NULL;
-
-    free(global_threadIds);
-    global_threadIds = NULL;
-
-    free(global_threads);
-    global_threads = NULL;
-
-    global_numThread = 1;
-}
-
-
-/* =============================================================================
- * thread_barrier_alloc
- * =============================================================================
- */
-thread_barrier_t*
-thread_barrier_alloc (long numThread)
-{
-    thread_barrier_t* barrierPtr;
-
-    assert(numThread > 0);
-    assert((numThread & (numThread - 1)) == 0); /* must be power of 2 */
-    barrierPtr = (thread_barrier_t*)malloc(numThread * sizeof(thread_barrier_t));
-    if (barrierPtr != NULL) {
-        barrierPtr->numThread = numThread;
-    }
-
-    return barrierPtr;
-}
-
-
-/* =============================================================================
- * thread_barrier_free
- * =============================================================================
- */
-void
-thread_barrier_free (thread_barrier_t* barrierPtr)
-{
-    free(barrierPtr);
-}
-
-
-/* =============================================================================
- * thread_barrier_init
- * =============================================================================
- */
-void
-thread_barrier_init (thread_barrier_t* barrierPtr)
-{
-    long i;
-    long numThread = barrierPtr->numThread;
-
-    for (i = 0; i < numThread; i++) {
-        barrierPtr[i].count = 0;
-        THREAD_MUTEX_INIT(barrierPtr[i].countLock);
-        THREAD_COND_INIT(barrierPtr[i].proceedCond);
-        THREAD_COND_INIT(barrierPtr[i].proceedAllCond);
-    }
-}
-
-
-/* =============================================================================
- * thread_barrier
- * -- Simple logarithmic barrier
- * =============================================================================
- */
-void
-thread_barrier (thread_barrier_t* barrierPtr, long threadId)
-{
-    long i = 2;
-    long base = 0;
-    long index;
-    long numThread = barrierPtr->numThread;
-
-    if (numThread < 2) {
-        return;
-    }
-
-    do {
-        index = base + threadId / i;
-        if ((threadId % i) == 0) {
-            THREAD_MUTEX_LOCK(barrierPtr[index].countLock);
-            barrierPtr[index].count++;
-            while (barrierPtr[index].count < 2) {
-                THREAD_COND_WAIT(barrierPtr[index].proceedCond,
-                                 barrierPtr[index].countLock);
-            }
-            THREAD_MUTEX_UNLOCK(barrierPtr[index].countLock);
-        } else {
-            THREAD_MUTEX_LOCK(barrierPtr[index].countLock);
-            barrierPtr[index].count++;
-            if (barrierPtr[index].count == 2) {
-                THREAD_COND_SIGNAL(barrierPtr[index].proceedCond);
-            }
-            while (THREAD_COND_WAIT(barrierPtr[index].proceedAllCond,
-                                    barrierPtr[index].countLock) != 0)
-            {
-                /* wait */
-            }
-            THREAD_MUTEX_UNLOCK(barrierPtr[index].countLock);
-            break;
-        }
-        base = base + numThread / i;
-        i *= 2;
-    } while (i <= numThread);
-
-    for (i /= 2; i > 1; i /= 2) {
-        base = base - numThread / i;
-        index = base + threadId / i;
-        THREAD_MUTEX_LOCK(barrierPtr[index].countLock);
-        barrierPtr[index].count = 0;
-        THREAD_COND_SIGNAL(barrierPtr[index].proceedAllCond);
-        THREAD_MUTEX_UNLOCK(barrierPtr[index].countLock);
-    }
-}
-
-
-/* =============================================================================
- * thread_getId
- * -- Call after thread_start() to get thread ID inside parallel region
- * =============================================================================
- */
-long
-thread_getId()
-{
-    return (long)THREAD_LOCAL_GET(global_threadId);
-}
-
-
-/* =============================================================================
- * thread_getNumThread
- * -- Call after thread_start() to get number of threads inside parallel region
- * =============================================================================
- */
-long
-thread_getNumThread()
-{
-    return global_numThread;
-}
-
-
-/* =============================================================================
- * thread_barrier_wait
- * -- Call after thread_start() to synchronize threads inside parallel region
- * =============================================================================
- */
-void
-thread_barrier_wait()
-{
-//#ifndef SIMULATOR
-    long threadId = thread_getId();
-//#endif /* !SIMULATOR */
-    THREAD_BARRIER(global_barrierPtr, threadId);
-}
-
-
-/* =============================================================================
- * TEST_THREAD
- * =============================================================================
- */
-#ifdef TEST_THREAD
-
-
-#include <stdio.h>
-#include <unistd.h>
-
-
-#define NUM_THREADS    (4)
-#define NUM_ITERATIONS (3)
-
-
-
-void
-printId (void* argPtr)
-{
-    long threadId = thread_getId();
-    long numThread = thread_getNumThread();
-    long i;
-
-    for ( i = 0; i < NUM_ITERATIONS; i++ ) {
-        thread_barrier_wait();
-        if (threadId == 0) {
-            sleep(1);
-        } else if (threadId == numThread-1) {
-            usleep(100);
-        }
-        printf("i = %li, tid = %li\n", i, threadId);
-        if (threadId == 0) {
-            puts("");
-        }
-        fflush(stdout);
-    }
-}
-
-
-int
-main ()
-{
-    puts("Starting...");
-
-    /* Run in parallel */
-    thread_startup(NUM_THREADS);
-    /* Start timing here */
-    thread_start(printId, NULL);
-    thread_start(printId, NULL);
-    thread_start(printId, NULL);
-    /* Stop timing here */
-    thread_shutdown();
-
-    puts("Done.");
-
-    return 0;
-}
-
-
-#endif /* TEST_THREAD */
-
-
-/* =============================================================================
- *
- * End of thread.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/lib/thread.cpp stamp-g/lib/thread.cpp
--- stamp-0.9.10/lib/thread.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-g/lib/thread.cpp	2017-03-21 18:31:40.000000000 +0000
@@ -0,0 +1,27 @@
+#include "Galois/Galois.h"
+#include "Galois/Statistic.h"
+
+#include "thread.h"
+
+static Galois::StatTimer* timer;
+static Galois::StatManager* manager;
+
+void thread_begin_timing() {
+  timer->start();
+}
+
+void thread_end_timing() {
+  timer->stop();
+}
+
+void thread_startup(long numThread) {
+  Galois::setActiveThreads(numThread); 
+  manager = new Galois::StatManager;
+  timer = new Galois::StatTimer;
+}
+
+void thread_shutdown() {
+  // Print loop statistics as a side-effect of ~StatManager
+  delete timer;
+  delete manager;
+}
diff -x .git -x inputs -Naur stamp-0.9.10/lib/thread.h stamp-g/lib/thread.h
--- stamp-0.9.10/lib/thread.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/lib/thread.h	2017-03-20 15:19:41.000000000 +0000
@@ -1,243 +1,19 @@
-/* =============================================================================
- *
- * thread.h
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
 #ifndef THREAD_H
 #define THREAD_H 1
 
-
-#include <pthread.h>
-#include <stdlib.h>
-#include "types.h"
-#ifdef OTM
-#include "omp.h"
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-
-#define THREAD_T                            pthread_t
-#define THREAD_ATTR_T                       pthread_attr_t
-
-#define THREAD_ATTR_INIT(attr)              pthread_attr_init(&attr)
-#define THREAD_JOIN(tid)                    pthread_join(tid, (void**)NULL)
-#define THREAD_CREATE(tid, attr, fn, arg)   pthread_create(&(tid), \
-                                                           &(attr), \
-                                                           (void* (*)(void*))(fn), \
-                                                           (void*)(arg))
-
-#define THREAD_LOCAL_T                      pthread_key_t
-#define THREAD_LOCAL_INIT(key)              pthread_key_create(&key, NULL)
-#define THREAD_LOCAL_SET(key, val)          pthread_setspecific(key, (void*)(val))
-#define THREAD_LOCAL_GET(key)               pthread_getspecific(key)
-
-#define THREAD_MUTEX_T                      pthread_mutex_t
-#define THREAD_MUTEX_INIT(lock)             pthread_mutex_init(&(lock), NULL)
-#define THREAD_MUTEX_LOCK(lock)             pthread_mutex_lock(&(lock))
-#define THREAD_MUTEX_UNLOCK(lock)           pthread_mutex_unlock(&(lock))
-
-#define THREAD_COND_T                       pthread_cond_t
-#define THREAD_COND_INIT(cond)              pthread_cond_init(&(cond), NULL)
-#define THREAD_COND_SIGNAL(cond)            pthread_cond_signal(&(cond))
-#define THREAD_COND_BROADCAST(cond)         pthread_cond_broadcast(&(cond))
-#define THREAD_COND_WAIT(cond, lock)        pthread_cond_wait(&(cond), &(lock))
-
-#ifdef SIMULATOR
-#  define THREAD_BARRIER_T                  pthread_barrier_t
-#  define THREAD_BARRIER_ALLOC(N)           ((THREAD_BARRIER_T*)malloc(sizeof(THREAD_BARRIER_T)))
-#  define THREAD_BARRIER_INIT(bar, N)       pthread_barrier_init(bar, 0, N)
-#  define THREAD_BARRIER(bar, tid)          pthread_barrier_wait(bar)
-#  define THREAD_BARRIER_FREE(bar)          free(bar)
-#else /* !SIMULATOR */
-#  define THREAD_BARRIER_T                  thread_barrier_t
-#  define THREAD_BARRIER_ALLOC(N)           thread_barrier_alloc(N)
-#  define THREAD_BARRIER_INIT(bar, N)       thread_barrier_init(bar)
-#  define THREAD_BARRIER(bar, tid)          thread_barrier(bar, tid)
-#  define THREAD_BARRIER_FREE(bar)          thread_barrier_free(bar)
-#endif /* !SIMULATOR */
-
-typedef struct thread_barrier {
-    THREAD_MUTEX_T countLock;
-    THREAD_COND_T proceedCond;
-    THREAD_COND_T proceedAllCond;
-    long count;
-    long numThread;
-} thread_barrier_t;
-
-
+void thread_startup(long numThread);
+void thread_shutdown();
 void thread_begin_timing();
 void thread_end_timing();
 
-/* =============================================================================
- * thread_startup
- * -- Create pool of secondary threads
- * -- numThread is total number of threads (primary + secondary)
- * =============================================================================
- */
-void
-thread_startup (long numThread);
-
-
-/* =============================================================================
- * thread_start
- * -- Make primary and secondary threads execute work
- * -- Should only be called by primary thread
- * -- funcPtr takes one arguments: argPtr
- * =============================================================================
- */
-void
-thread_start (void (*funcPtr)(void*), void* argPtr);
-
-
-/* =============================================================================
- * thread_shutdown
- * -- Primary thread kills pool of secondary threads
- * =============================================================================
- */
-void
-thread_shutdown ();
-
-
-/* =============================================================================
- * thread_barrier_alloc
- * =============================================================================
- */
-thread_barrier_t*
-thread_barrier_alloc (long numThreads);
-
-
-/* =============================================================================
- * thread_barrier_free
- * =============================================================================
- */
-void
-thread_barrier_free (thread_barrier_t* barrierPtr);
-
-
-/* =============================================================================
- * thread_barrier_init
- * =============================================================================
- */
-void
-thread_barrier_init (thread_barrier_t* barrierPtr);
-
-
-/* =============================================================================
- * thread_barrier
- * -- Simple logarithmic barrier
- * =============================================================================
- */
-void
-thread_barrier (thread_barrier_t* barrierPtr, long threadId);
-
-
-/* =============================================================================
- * thread_getId
- * -- Call after thread_start() to get thread ID inside parallel region
- * =============================================================================
- */
-long
-thread_getId();
-
-
-/* =============================================================================
- * thread_getNumThread
- * -- Call after thread_start() to get number of threads inside parallel region
- * =============================================================================
- */
-long
-thread_getNumThread();
-
-
-/* =============================================================================
- * thread_barrier_wait
- * -- Call after thread_start() to synchronize threads inside parallel region
- * =============================================================================
- */
-void
-thread_barrier_wait();
-
-
 #ifdef __cplusplus
 }
 #endif
 
 
-#endif /* THREAD_H */
-
 
-/* =============================================================================
- *
- * End of thread.h
- *
- * =============================================================================
- */
+#endif
diff -x .git -x inputs -Naur stamp-0.9.10/lib/tm.h stamp-g/lib/tm.h
--- stamp-0.9.10/lib/tm.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/lib/tm.h	2017-03-21 18:31:59.000000000 +0000
@@ -129,43 +129,9 @@
 #define TM_PRINT2                     printf
 #define TM_PRINT3                     printf
 
-#ifdef STM
-#  include <stm.h>
-#  include <mod_mem.h>
-#  define P_MEMORY_STARTUP(numThread)   /* nothing */
-#  define P_MEMORY_SHUTDOWN()           /* nothing */
-#  define P_MALLOC(size)                malloc(size)
-#  define P_FREE(ptr)                   free(ptr)
-#  define TM_MALLOC(size)               stm_malloc(size)
-#  define TM_FREE(ptr)                  stm_free(ptr, sizeof(stm_word_t))
-#elif defined(STAMP_PALLOC)
-#  include "memory.h"
-#  define P_MEMORY_STARTUP(numThread)   do { \
-                                            bool_t status; \
-                                            status = memory_init((numThread), \
-                                                                 ((1<<28) / numThread), \
-                                                                 2); \
-                                            assert(status); \
-                                        } while (0) /* enforce comma */
-#  define P_MEMORY_SHUTDOWN()           memory_destroy()
-#  define TM_MALLOC(size)               memory_get(thread_getId(), size)
-#  define TM_FREE(ptr)                  
-#  define P_MALLOC(size)                memory_get(thread_getId(), size)
-#  define P_FREE(ptr)                   
-#else
-#  define P_MEMORY_STARTUP(numThread)   /* nothing */
-#  define P_MEMORY_SHUTDOWN()           /* nothing */
-#  define P_MALLOC(size)                malloc(size)
-#  define P_FREE(ptr)                   free(ptr)
-#  define TM_MALLOC(size)               malloc(size)
-#  define TM_FREE(ptr)                  free(ptr)
-#endif
-
-#ifndef XTM_DECL_LOCKABLE
-#  define XTM_DECL_LOCKABLE(type, name) type name
-#  define XTM_LOCKABLE_INIT(expr) 
-#  define XTM_LOCKABLE_VALUE(expr) (expr)
-#endif
+#define P_MEMORY_STARTUP(numThread)   /* nothing */
+#define P_MEMORY_SHUTDOWN()           /* nothing */
+
 
 /* =============================================================================
  * Transactional Memory System Interface
@@ -257,125 +223,37 @@
  * =============================================================================
  */
 
-
-/* =============================================================================
- * HTM - Hardware Transactional Memory
- * =============================================================================
- */
-
-#ifdef HTM
-
-#  include <assert.h>
-#  include "memory.h"
-#  include "thread.h"
-#  include "types.h"
-#  include <speculation.h>
-
-#  define TM_ARG                        /* nothing */
-#  define TM_ARG_ALONE                  /* nothing */
-#  define TM_ARGDECL                    /* nothing */
-#  define TM_ARGDECL_ALONE              /* nothing */
-#  define TM_CALLABLE                   /* nothing */
-
-#  define TM_STARTUP(numThread)         /* nothing */
-#  define TM_SHUTDOWN()                 if (getenv("STM_STATS")) { \
-    TmReport_t r; \
-    tm_get_all_stats(&r); \
-    printf("transactions: %lu rollbacks: %lu jmv: %lu maxroll: %lu other: %lu\n", \
-        r.totalTransactions, r.totalRollbacks, \
-        r.totalSerializedJMV, r.totalSerializedMAXRB, r.totalSerializedOTHER); \
-   }
-#  define TM_THREAD_ENTER()             /* nothing */
-#  define TM_THREAD_EXIT()              /* nothing */
-
-#  define TM_BEGIN()                    _Pragma ("tm_atomic") {
-#  define TM_BEGIN_RO()                 _Pragma ("tm_atomic") {
-#  define TM_END()                      }
-#  define TM_RESTART()                  abort()
-#  define TM_EARLY_RELEASE(var)         
-
-/* =============================================================================
- * STM - Software Transactional Memory
- * =============================================================================
- */
-
-#elif defined(STM)
-
-#  include <string.h>
-
-#  define TM_ARG                        /* nothing */
-#  define TM_ARG_ALONE                  /* nothing */
-#  define TM_ARGDECL                    /* nothing */
-#  define TM_ARGDECL_ALONE              /* nothing */
-#  define TM_CALLABLE                   /* nothing */
-
-#  include <mod_stats.h>
-
-#  define TM_STARTUP(numThread)     if (sizeof(long) != sizeof(void *)) { \
-                                      fprintf(stderr, "Error: unsupported long and pointer sizes\n"); \
-                                      exit(1); \
-                                    } \
-                                    stm_init(); \
-                                    mod_mem_init(0); \
-                                    if (getenv("STM_STATS") != NULL) { \
-                                      mod_stats_init(); \
-                                    }
-#  define TM_SHUTDOWN()             if (getenv("STM_STATS") != NULL) { \
-                                      unsigned long u; \
-                                      if (stm_get_global_stats("global_nb_commits", &u) != 0) \
-                                        printf("#commits    : %lu\n", u); \
-                                      if (stm_get_global_stats("global_nb_aborts", &u) != 0) \
-                                        printf("#aborts     : %lu\n", u); \
-                                      if (stm_get_global_stats("global_max_retries", &u) != 0) \
-                                        printf("Max retries : %lu\n", u); \
-                                    } \
-                                    stm_exit()
-
-#  define TM_THREAD_ENTER()         stm_init_thread()
-#  define TM_THREAD_EXIT()          stm_exit_thread()
-
-#  define TM_START(ro)                do { \
-                                          stm_tx_attr_t _a = {{.read_only = ro}}; \
-                                          sigjmp_buf *_e = stm_start(_a); \
-                                          if (_e != NULL) sigsetjmp(*_e, 0); \
-                                      } while (0)
-#  define TM_BEGIN()                  TM_START(0)
-#  define TM_BEGIN_RO()               TM_START(1)
-#  define TM_END()                    stm_commit()
-#  define TM_RESTART()                stm_abort(0)
-
-#  define TM_EARLY_RELEASE(var)       /* nothing */
-
 /* =============================================================================
  * Sequential execution
  * =============================================================================
  */
 
-#else /* SEQUENTIAL */
-
-#  include <assert.h>
+#include <assert.h>
+#include "thread.h"
 
-#  define TM_ARG                        /* nothing */
-#  define TM_ARG_ALONE                  /* nothing */
-#  define TM_ARGDECL                    /* nothing */
-#  define TM_ARGDECL_ALONE              /* nothing */
-#  define TM_CALLABLE                   /* nothing */
-
-#  define TM_STARTUP(numThread)         /* nothing */
-#  define TM_SHUTDOWN()                 /* nothing */
-
-#  define TM_THREAD_ENTER()             /* nothing */
-#  define TM_THREAD_EXIT()              /* nothing */
-
-#  define TM_BEGIN()                    /* nothing */
-#  define TM_BEGIN_RO()                 /* nothing */
-#  define TM_END()                      /* nothing */
-#  define TM_RESTART()                  assert(0)
-
-#  define TM_EARLY_RELEASE(var)         /* nothing */
-
-#endif /* SEQUENTIAL */
+#define TM_ARG                        /* nothing */
+#define TM_ARG_ALONE                  /* nothing */
+#define TM_ARGDECL                    /* nothing */
+#define TM_ARGDECL_ALONE              /* nothing */
+#define TM_CALLABLE                   /* nothing */
+
+#define TM_STARTUP(numThread)         /* nothing */
+#define TM_SHUTDOWN()                 /* nothing */
+
+#define TM_THREAD_ENTER()             /* nothing */
+#define TM_THREAD_EXIT()              /* nothing */
+
+#define P_MALLOC(size)              malloc(size)
+#define P_FREE(ptr)                 free(ptr)
+#define TM_MALLOC(size)             malloc(size)
+#define TM_FREE(ptr)                free(ptr)
+
+#define TM_BEGIN()                    /* nothing */
+#define TM_BEGIN_RO()                 /* nothing */
+#define TM_END()                      /* nothing */
+#define TM_RESTART()                  abort()
 
+#define TM_EARLY_RELEASE(var)         /* nothing */
 
 /* =============================================================================
  * Transactional Memory System interface for shared memory accesses
@@ -387,40 +265,17 @@
  * 3) _F suffix: for accessing variables of type "float"
  * =============================================================================
  */
-#if defined(STM)
-
-#  include <wrappers.h>
-
-/* We could also map macros to the stm_(load|store)_long functions if needed */
-
-#  define TM_SHARED_READ(var)           stm_load((volatile stm_word_t *)(void *)&XTM_LOCKABLE_VALUE(var))
-#  define TM_SHARED_READ_P(var)         stm_load_ptr((volatile void **)(void *)&XTM_LOCKABLE_VALUE(var))
-#  define TM_SHARED_READ_F(var)         stm_load_float((volatile float *)(void *)&XTM_LOCKABLE_VALUE(var))
-
-#  define TM_SHARED_WRITE(var, val)     stm_store((volatile stm_word_t *)(void *)&XTM_LOCKABLE_VALUE(var), (stm_word_t)val)
-#  define TM_SHARED_WRITE_P(var, val)   stm_store_ptr((volatile void **)(void *)&XTM_LOCKABLE_VALUE(var), val)
-#  define TM_SHARED_WRITE_F(var, val)   stm_store_float((volatile float *)(void *)&XTM_LOCKABLE_VALUE(var), val)
-
-#  define TM_LOCAL_WRITE(var, val)      ({var = val; var;})
-#  define TM_LOCAL_WRITE_P(var, val)    ({var = val; var;})
-#  define TM_LOCAL_WRITE_F(var, val)    ({var = val; var;})
-
-#else /* !STM */
-
-#  define TM_SHARED_READ(var)           (var)
-#  define TM_SHARED_READ_P(var)         (var)
-#  define TM_SHARED_READ_F(var)         (var)
-
-#  define TM_SHARED_WRITE(var, val)     ({var = val; var;})
-#  define TM_SHARED_WRITE_P(var, val)   ({var = val; var;})
-#  define TM_SHARED_WRITE_F(var, val)   ({var = val; var;})
-
-#  define TM_LOCAL_WRITE(var, val)      ({var = val; var;})
-#  define TM_LOCAL_WRITE_P(var, val)    ({var = val; var;})
-#  define TM_LOCAL_WRITE_F(var, val)    ({var = val; var;})
-
-#endif /* !STM */
-
+#define TM_SHARED_READ(var)           (var)
+#define TM_SHARED_READ_P(var)         (var)
+#define TM_SHARED_READ_F(var)         (var)
+
+#define TM_SHARED_WRITE(var, val)     ({var = val; var;})
+#define TM_SHARED_WRITE_P(var, val)   ({var = val; var;})
+#define TM_SHARED_WRITE_F(var, val)   ({var = val; var;})
+
+#define TM_LOCAL_WRITE(var, val)      ({var = val; var;})
+#define TM_LOCAL_WRITE_P(var, val)    ({var = val; var;})
+#define TM_LOCAL_WRITE_F(var, val)    ({var = val; var;})
 
 #endif /* TM_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/lib/tm.h.orig stamp-g/lib/tm.h.orig
--- stamp-0.9.10/lib/tm.h.orig	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/lib/tm.h.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,573 +0,0 @@
-/* =============================================================================
- *
- * tm.h
- *
- * Utility defines for transactional memory
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Authors: Chi Cao Minh and Martin Trautmann
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#ifndef TM_H
-#define TM_H 1
-
-#ifdef HAVE_CONFIG_H
-# include "STAMP_config.h"
-#endif
-
-/* =============================================================================
- * Simulator Specific Interface
- *
- * MAIN(argc, argv)
- *     Declare the main function with argc being the identifier for the argument
- *     count and argv being the name for the argument string list
- *
- * MAIN_RETURN(int_val)
- *     Returns from MAIN function
- *
- * GOTO_SIM()
- *     Switch simulator to simulation mode
- *
- * GOTO_REAL()
- *     Switch simulator to non-simulation (real) mode
- *     Note: use in sequential region only
- *
- * IS_IN_SIM()
- *     Returns true if simulator is in simulation mode
- *
- * SIM_GET_NUM_CPU(var)
- *     Assigns the number of simulated CPUs to "var"
- *
- * P_MEMORY_STARTUP
- *     Start up the memory allocator system that handles malloc/free
- *     in parallel regions (but not in transactions)
- *
- * P_MEMORY_SHUTDOWN
- *     Shutdown the memory allocator system that handles malloc/free
- *     in parallel regions (but not in transactions)
- *
- * =============================================================================
- */
-#ifdef SIMULATOR
-
-#  include <simapi.h>
-
-#  define MAIN(argc, argv)              void mainX (int argc, \
-                                                    const char** argv, \
-                                                    const char** envp)
-#  define MAIN_RETURN(val)              return /* value is ignored */
-
-#  define GOTO_SIM()                    goto_sim()
-#  define GOTO_REAL()                   goto_real()
-#  define IS_IN_SIM()                   (inSimulation)
-
-#  define SIM_GET_NUM_CPU(var)          ({ \
-                                            if (!IS_IN_SIM()) { \
-                                                GOTO_SIM(); \
-                                                var = Sim_GetNumCpus(); \
-                                                GOTO_REAL(); \
-                                            } else { \
-                                                var = Sim_GetNumCpus(); \
-                                            } \
-                                            var; \
-                                        })
-
-#  define TM_PRINTF                     Sim_Print
-#  define TM_PRINT0                     Sim_Print0
-#  define TM_PRINT1                     Sim_Print1
-#  define TM_PRINT2                     Sim_Print2
-#  define TM_PRINT3                     Sim_Print3
-
-#  include "memory.h"
-#  define P_MEMORY_STARTUP(numThread)   do { \
-                                            bool_t status; \
-                                            status = memory_init((numThread), \
-                                                                 ((1<<28) / numThread), \
-                                                                 2); \
-                                            assert(status); \
-                                        } while (0) /* enforce comma */
-#  define P_MEMORY_SHUTDOWN()           memory_destroy()
-
-#else /* !SIMULATOR */
-
-#  include <stdio.h>
-
-#  define MAIN(argc, argv)              int main (int argc, char** argv)
-#  define MAIN_RETURN(val)              return val
-
-#  define GOTO_SIM()                    /* nothing */
-#  define GOTO_REAL()                   /* nothing */
-#  define IS_IN_SIM()                   (0)
-
-#  define SIM_GET_NUM_CPU(var)          /* nothing */
-
-#  define TM_PRINTF                     printf
-#  define TM_PRINT0                     printf
-#  define TM_PRINT1                     printf
-#  define TM_PRINT2                     printf
-#  define TM_PRINT3                     printf
-
-#  define P_MEMORY_STARTUP(numThread)   /* nothing */
-#  define P_MEMORY_SHUTDOWN()           /* nothing */
-
-#endif /* !SIMULATOR */
-
-
-/* =============================================================================
- * Transactional Memory System Interface
- *
- * TM_ARG
- * TM_ARG_ALONE
- * TM_ARGDECL
- * TM_ARGDECL_ALONE
- *     Used to pass TM thread meta data to functions (see Examples below)
- *
- * TM_STARTUP(numThread)
- *     Startup the TM system (call before any other TM calls)
- *
- * TM_SHUTDOWN()
- *     Shutdown the TM system
- *
- * TM_THREAD_ENTER()
- *     Call when thread first enters parallel region
- *
- * TM_THREAD_EXIT()
- *     Call when thread exits last parallel region
- *
- * P_MALLOC(size)
- *     Allocate memory inside parallel region
- *
- * P_FREE(ptr)
- *     Deallocate memory inside parallel region
- *
- * TM_MALLOC(size)
- *     Allocate memory inside atomic block / transaction
- *
- * TM_FREE(ptr)
- *     Deallocate memory inside atomic block / transaction
- *
- * TM_BEGIN()
- *     Begin atomic block / transaction
- *
- * TM_BEGIN_RO()
- *     Begin atomic block / transaction that only reads shared data
- *
- * TM_END()
- *     End atomic block / transaction
- *
- * TM_RESTART()
- *     Restart atomic block / transaction
- *
- * TM_EARLY_RELEASE()
- *     Remove speculatively read line from the read set
- *
- * =============================================================================
- *
- * Example Usage:
- *
- *     MAIN(argc,argv)
- *     {
- *         TM_STARTUP(8);
- *         // create 8 threads and go parallel
- *         TM_SHUTDOWN();
- *     }
- *
- *     void parallel_region ()
- *     {
- *         TM_THREAD_ENTER();
- *         subfunction1(TM_ARG_ALONE);
- *         subfunction2(TM_ARG  1, 2, 3);
- *         TM_THREAD_EXIT();
- *     }
- *
- *     void subfunction1 (TM_ARGDECL_ALONE)
- *     {
- *         TM_BEGIN_RO()
- *         // ... do work that only reads shared data ...
- *         TM_END()
- *
- *         long* array = (long*)P_MALLOC(10 * sizeof(long));
- *         // ... do work ...
- *         P_FREE(array);
- *     }
- *
- *     void subfunction2 (TM_ARGDECL  long a, long b, long c)
- *     {
- *         TM_BEGIN();
- *         long* array = (long*)TM_MALLOC(a * b * c * sizeof(long));
- *         // ... do work that may read or write shared data ...
- *         TM_FREE(array);
- *         TM_END();
- *     }
- *
- * =============================================================================
- */
-
-
-/* =============================================================================
- * HTM - Hardware Transactional Memory
- * =============================================================================
- */
-
-#ifdef HTM
-
-#  ifndef SIMULATOR
-#    error HTM requries SIMULATOR
-#  endif
-
-#  include <assert.h>
-#  include <tmapi.h>
-#  include "memory.h"
-#  include "thread.h"
-#  include "types.h"
-
-#  define TM_ARG                        /* nothing */
-#  define TM_ARG_ALONE                  /* nothing */
-#  define TM_ARGDECL                    /* nothing */
-#  define TM_ARGDECL_ALONE              /* nothing */
-#  define TM_CALLABLE                   /* nothing */
-
-#  define TM_STARTUP(numThread)         /* nothing */
-#  define TM_SHUTDOWN()                 /* nothing */
-
-#  define TM_THREAD_ENTER()             /* nothing */
-#  define TM_THREAD_EXIT()              /* nothing */
-
-#  define P_MALLOC(size)                memory_get(thread_getId(), size)
-#  define P_FREE(ptr)                   /* TODO: thread local free is non-trivial */
-#  define TM_MALLOC(size)               memory_get(thread_getId(), size)
-#  define TM_FREE(ptr)                  /* TODO: thread local free is non-trivial */
-
-#  ifdef OTM
-
-#    define thread_getId()              omp_get_thread_num()
-#    define thread_getNumThread()       omp_get_num_threads()
-#    define thread_startup(numThread)   omp_set_num_threads(numThread)
-#    define thread_shutdown()           /* nothing */
-#    define thread_barrier_wait();      _Pragma ("omp barrier")
-#    define TM_BEGIN()                  _Pragma ("omp transaction") {
-#    define TM_BEGIN_RO()               _Pragma ("omp transaction") {
-#    define TM_END()                    }
-#    define TM_RESTART()                _TM_Abort()
-
-#    define TM_EARLY_RELEASE(var)       TM_Release(&(var))
-
-#  else /* !OTM */
-
-#    define TM_BEGIN()                    TM_BeginClosed()
-#    define TM_BEGIN_RO()                 TM_BeginClosed()
-#    define TM_END()                      TM_EndClosed()
-#    define TM_RESTART()                  _TM_Abort()
-#    define TM_EARLY_RELEASE(var)         TM_Release(&(var))
-
-#  endif /* !OTM */
-
-
-/* =============================================================================
- * STM - Software Transactional Memory
- * =============================================================================
- */
-
-#elif defined(STM)
-
-#  include <string.h>
-#  include <stm.h>
-#  include "thread.h"
-
-#  if defined (OTM)
-
-#    define TM_ARG                        /* nothing */
-#    define TM_ARG_ALONE                  /* nothing */
-#    define TM_ARGDECL                    /* nothing */
-#    define TM_ARGDECL_ALONE              /* nothing */
-#    define TM_CALLABLE                   _Pragma ("omp tm_function")
-
-#    define thread_getId()                omp_get_thread_num()
-#    define thread_getNumThread()         omp_get_num_threads()
-#    define thread_startup(numThread)     omp_set_num_threads(numThread)
-#    define thread_shutdown()             /* nothing */
-
-#  else /* !OTM */
-
-#    define TM_ARG                        STM_SELF,
-#    define TM_ARG_ALONE                  STM_SELF
-#    define TM_ARGDECL                    STM_THREAD_T* TM_ARG
-#    define TM_ARGDECL_ALONE              STM_THREAD_T* TM_ARG_ALONE
-#    define TM_CALLABLE                   /* nothing */
-
-#endif /* !OTM */
-
-#  ifdef SIMULATOR
-
-#    ifdef OTM
-
-#      define TM_STARTUP(numThread)       STM_STARTUP(); \
-                                          STM_NEW_THREADS(numThread)
-#      define TM_SHUTDOWN()               STM_SHUTDOWN()
-
-#      define TM_THREAD_ENTER()           omp_set_self()
-#      define TM_THREAD_EXIT()            /* Nothing */
-#      define thread_barrier_wait();      _Pragma ("omp barrier")
-
-#      define P_MALLOC(size)              memory_get(thread_getId(), size)
-#      define P_FREE(ptr)                 /* TODO: thread local free is non-trivial */
-#      define TM_MALLOC(size)             memory_get(thread_getId(), size)
-#      define TM_FREE(ptr)                /* TODO: thread local free is non-trivial */
-
-#    else /* !OTM */
-
-#      define TM_STARTUP(numThread)       STM_STARTUP(); \
-                                          STM_NEW_THREADS(numThread)
-#      define TM_SHUTDOWN()               STM_SHUTDOWN()
-
-#      define TM_THREAD_ENTER()           TM_ARGDECL_ALONE = \
-                                              STM_GET_THREAD(thread_getId()); \
-                                          STM_SET_SELF(TM_ARG_ALONE)
-
-#      define TM_THREAD_EXIT()            STM_FREE_THREAD(TM_ARG_ALONE)
-
-#      define P_MALLOC(size)              memory_get(thread_getId(), size)
-#      define P_FREE(ptr)                 /* TODO: thread local free is non-trivial */
-#      define TM_MALLOC(size)             memory_get(thread_getId(), size)
-#      define TM_FREE(ptr)                /* TODO: thread local free is non-trivial */
-
-#    endif /* !OTM */
-
-#  else /* !SIMULATOR */
-
-#    ifdef OTM
-
-#      include <omp.h>
-#      include "tl2.h"
-
-#      define TM_STARTUP(numThread)     STM_STARTUP()
-#      define TM_SHUTDOWN()             STM_SHUTDOWN()
-
-#      define TM_THREAD_ENTER()         /* nothing */
-#      define TM_THREAD_EXIT()          /* nothing */
-#      define thread_barrier_wait();    _Pragma ("omp barrier")
-
-#      define P_MALLOC(size)            malloc(size)
-#      define P_FREE(ptr)               free(ptr)
-#      define TM_MALLOC(size)           malloc(size)
-#      define TM_FREE(ptr)              /* TODO: fix memory free problem with OpenTM */
-
-#    else /* !OTM */
-
-#      define TM_STARTUP(numThread)     STM_STARTUP()
-#      define TM_SHUTDOWN()             STM_SHUTDOWN()
-
-#      define TM_THREAD_ENTER()         TM_ARGDECL_ALONE = STM_NEW_THREAD(); \
-                                        STM_INIT_THREAD(TM_ARG_ALONE, thread_getId())
-#      define TM_THREAD_EXIT()          STM_FREE_THREAD(TM_ARG_ALONE)
-
-#      define P_MALLOC(size)            malloc(size)
-#      define P_FREE(ptr)               free(ptr)
-#      define TM_MALLOC(size)           STM_MALLOC(size)
-#      define TM_FREE(ptr)              STM_FREE(ptr)
-
-#    endif /* !OTM */
-
-#  endif /* !SIMULATOR */
-
-#  ifdef OTM
-
-#    define TM_BEGIN()                  _Pragma ("omp transaction") {
-#    define TM_BEGIN_RO()               _Pragma ("omp transaction") {
-#    define TM_END()                    }
-#    define TM_RESTART()                omp_abort()
-
-#    define TM_EARLY_RELEASE(var)       /* nothing */
-
-#  else /* !OTM */
-
-#    define TM_BEGIN()                  STM_BEGIN_WR()
-#    define TM_BEGIN_RO()               STM_BEGIN_RD()
-#    define TM_END()                    STM_END()
-#    define TM_RESTART()                STM_RESTART()
-
-#    define TM_EARLY_RELEASE(var)       /* nothing */
-
-#  endif /* !OTM */
-
-
-/* =============================================================================
- * Sequential execution
- * =============================================================================
- */
-
-#else /* SEQUENTIAL */
-
-#  include <assert.h>
-
-#  define TM_ARG                        /* nothing */
-#  define TM_ARG_ALONE                  /* nothing */
-#  define TM_ARGDECL                    /* nothing */
-#  define TM_ARGDECL_ALONE              /* nothing */
-#  define TM_CALLABLE                   /* nothing */
-
-#  define TM_STARTUP(numThread)         /* nothing */
-#  define TM_SHUTDOWN()                 /* nothing */
-
-#  define TM_THREAD_ENTER()             /* nothing */
-#  define TM_THREAD_EXIT()              /* nothing */
-
-#  ifdef SIMULATOR
-
-#    include "thread.h"
-
-#    define P_MALLOC(size)              memory_get(thread_getId(), size)
-#    define P_FREE(ptr)                 /* TODO: thread local free is non-trivial */
-#    define TM_MALLOC(size)             memory_get(thread_getId(), size)
-#    define TM_FREE(ptr)                /* TODO: thread local free is non-trivial */
-
-#  else /* !SIMULATOR */
-
-#    define P_MALLOC(size)              malloc(size)
-#    define P_FREE(ptr)                 free(ptr)
-#    define TM_MALLOC(size)             malloc(size)
-#    define TM_FREE(ptr)                free(ptr)
-
-#  endif /* !SIMULATOR */
-
-#  define TM_BEGIN()                    /* nothing */
-#  define TM_BEGIN_RO()                 /* nothing */
-#  define TM_END()                      /* nothing */
-#  define TM_RESTART()                  assert(0)
-
-#  define TM_EARLY_RELEASE(var)         /* nothing */
-
-#endif /* SEQUENTIAL */
-
-
-/* =============================================================================
- * Transactional Memory System interface for shared memory accesses
- *
- * There are 3 flavors of each function:
- *
- * 1) no suffix: for accessing variables of size "long"
- * 2) _P suffix: for accessing variables of type "pointer"
- * 3) _F suffix: for accessing variables of type "float"
- * =============================================================================
- */
-#if defined(STM)
-
-#if defined(OTM)
-
-#  define TM_SHARED_READ(var)           (var)
-#  define TM_SHARED_READ_P(var)         (var)
-#  define TM_SHARED_READ_F(var)         (var)
-
-#  define TM_SHARED_WRITE(var, val)     ({var = val; var;})
-#  define TM_SHARED_WRITE_P(var, val)   ({var = val; var;})
-#  define TM_SHARED_WRITE_F(var, val)   ({var = val; var;})
-
-#  define TM_LOCAL_WRITE(var, val)      ({var = val; var;})
-#  define TM_LOCAL_WRITE_P(var, val)    ({var = val; var;})
-#  define TM_LOCAL_WRITE_F(var, val)    ({var = val; var;})
-
-#else /* OTM */
-
-#  define TM_SHARED_READ(var)           STM_READ(var)
-#  define TM_SHARED_READ_P(var)         STM_READ_P(var)
-#  define TM_SHARED_READ_F(var)         STM_READ_F(var)
-
-#  define TM_SHARED_WRITE(var, val)     STM_WRITE((var), val)
-#  define TM_SHARED_WRITE_P(var, val)   STM_WRITE_P((var), val)
-#  define TM_SHARED_WRITE_F(var, val)   STM_WRITE_F((var), val)
-
-#  define TM_LOCAL_WRITE(var, val)      STM_LOCAL_WRITE(var, val)
-#  define TM_LOCAL_WRITE_P(var, val)    STM_LOCAL_WRITE_P(var, val)
-#  define TM_LOCAL_WRITE_F(var, val)    STM_LOCAL_WRITE_F(var, val)
-
-#endif /* !OTM */
-
-#else /* !STM */
-
-#  define TM_SHARED_READ(var)           (var)
-#  define TM_SHARED_READ_P(var)         (var)
-#  define TM_SHARED_READ_F(var)         (var)
-
-#  define TM_SHARED_WRITE(var, val)     ({var = val; var;})
-#  define TM_SHARED_WRITE_P(var, val)   ({var = val; var;})
-#  define TM_SHARED_WRITE_F(var, val)   ({var = val; var;})
-
-#  define TM_LOCAL_WRITE(var, val)      ({var = val; var;})
-#  define TM_LOCAL_WRITE_P(var, val)    ({var = val; var;})
-#  define TM_LOCAL_WRITE_F(var, val)    ({var = val; var;})
-
-#endif /* !STM */
-
-
-#endif /* TM_H */
-
-
-/* =============================================================================
- *
- * End of tm.h
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/lib/vector.h stamp-g/lib/vector.h
--- stamp-0.9.10/lib/vector.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/lib/vector.h	2017-03-20 15:19:41.000000000 +0000
@@ -75,19 +75,22 @@
 
 #include "tm.h"
 #include "types.h"
-
+#include "list.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 
+#if 0
 typedef struct vector {
     long size;
     long capacity;
     void** elements;
 } vector_t;
-
+#else
+typedef struct list vector_t;
+#endif
 
 /* =============================================================================
  * vector_alloc
@@ -131,6 +134,8 @@
 void*
 vector_at (vector_t* vectorPtr, long i);
 
+void*
+vector_back (vector_t* vectorPtr);
 
 /* =============================================================================
  * vector_pushBack
@@ -180,7 +185,7 @@
  * =============================================================================
  */
 void
-vector_sort (vector_t* vectorPtr, int (*compare) (const void*, const void*));
+vector_sort (vector_t* vectorPtr, long (*compare) (const void*, const void*));
 
 
 /* =============================================================================
@@ -199,15 +204,15 @@
 Pvector_copy (vector_t* dstVectorPtr, vector_t* srcVectorPtr);
 
 
-#define PVECTOR_ALLOC(n)            Pvector_alloc(n)
-#define PVECTOR_FREE(v)             Pvector_free(v)
-#define PVECTOR_PUSHBACK(v, data)   Pvector_pushBack(v, data)
+//#define PVECTOR_ALLOC(n)            vector_alloc(n)
+//#define PVECTOR_FREE(v)             vector_free(v)
+#define PVECTOR_PUSHBACK(v, data)   vector_pushBack(v, data)
 #define PVECTOR_POPBACK(v)          vector_popBack(v)
 #define PVECTOR_AT(v, i)            vector_at(v, i)
 #define PVECTOR_GETSIZE(v)          vector_getSize(v)
 #define PVECTOR_CLEAR(v)            vector_clear(v)
 #define PVECTOR_SORT(v, cmp)        vector_sort(v, cmp)
-#define PVECTOR_COPY(dst, src)      Pvector_copy(dst, src)
+#define PVECTOR_COPY(dst, src)      vector_copy(dst, src)
 
 
 #ifdef __cplusplus
diff -x .git -x inputs -Naur stamp-0.9.10/ssca2/CMakeLists.txt stamp-g/ssca2/CMakeLists.txt
--- stamp-0.9.10/ssca2/CMakeLists.txt	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/ssca2/CMakeLists.txt	2017-03-20 15:19:41.000000000 +0000
@@ -11,19 +11,19 @@
 #CFLAGS += -DENABLE_KERNEL4
 
 set(sources
-	alg_radix_smp.c 
-	computeGraph.c 
-	createPartition.c 
-        #cutClusters.c 
-        #findSubGraphs.c 
+	alg_radix_smp.c
+	computeGraph.cpp 
+        createPartition.c 
+	#cutClusters.c 
+	#findSubGraphs.c 
 	genScalData.c 
-        getStartLists.c 
+        #getStartLists.c 
 	getUserParameters.c 
 	globals.c 
 	ssca2.c 
 	${LIB_DIR}/mt19937ar.c 
-	${LIB_DIR}/random.c 
-	${LIB_DIR}/thread.c)
+	${LIB_DIR}/random.c
+	${LIB_DIR}/thread.cpp)
 
 app(ssca2 ${sources})
 
diff -x .git -x inputs -Naur stamp-0.9.10/ssca2/Makefile.orig stamp-g/ssca2/Makefile.orig
--- stamp-0.9.10/ssca2/Makefile.orig	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/ssca2/Makefile.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-EXECS = RUN_graphAnalysis
-
-SIMPLE_DIR = ../simple-4.4H
-
-OPT        = -O$(O_LEVEL)
-OPT        = -g
-
-include $(SIMPLE_DIR)/Makefile.smp.mk
diff -x .git -x inputs -Naur stamp-0.9.10/ssca2/alg_radix_smp.c stamp-g/ssca2/alg_radix_smp.c
--- stamp-0.9.10/ssca2/alg_radix_smp.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/ssca2/alg_radix_smp.c	2017-03-20 15:19:41.000000000 +0000
@@ -81,6 +81,7 @@
 static unsigned long* global_lTemp2  = NULL;
 
 
+#if 0
 /* =============================================================================
  * all_countsort_node
  *
@@ -174,7 +175,7 @@
         P_FREE(myHisto);
     }
 }
-
+#endif
 
 /* =============================================================================
  * all_countsort_node_aux_seq
@@ -236,7 +237,7 @@
     free(myHisto);
 }
 
-
+#if 0
 /* =============================================================================
  * all_countsort_node_aux
  *
@@ -406,7 +407,7 @@
         P_FREE(lTemp);
     }
 }
-
+#endif
 
 /* =============================================================================
  * all_radixsort_node_aux_s3_seq
@@ -437,7 +438,7 @@
     free(lTemp2);
 }
 
-
+#if 0
 /* =============================================================================
  * all_radixsort_node_aux_s3
  *
@@ -481,7 +482,7 @@
         P_FREE(lTemp2);
     }
 }
-
+#endif
 
 /* =============================================================================
  *
diff -x .git -x inputs -Naur stamp-0.9.10/ssca2/computeGraph.c stamp-g/ssca2/computeGraph.c
--- stamp-0.9.10/ssca2/computeGraph.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/ssca2/computeGraph.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,635 +0,0 @@
-/* =============================================================================
- *
- * computeGraph.c
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include "computeGraph.h"
-#include "createPartition.h"
-#include "defs.h"
-#include "globals.h"
-#include "thread.h"
-#include "utility.h"
-#include "tm.h"
-
-typedef struct LockableULong {
-    XTM_DECL_LOCKABLE(ULONGINT_T, value1);
-} LockableULong;
-
-typedef struct LockableULongPtr {
-    XTM_DECL_LOCKABLE(LockableULong*, value2);
-} LockableULongPtr;
-
-static ULONGINT_T*  global_p                 = NULL;
-static XTM_DECL_LOCKABLE(ULONGINT_T,   global_maxNumVertices);//    = 0;
-static ULONGINT_T   global_outVertexListSize = 0;
-static LockableULong*  global_impliedEdgeList   = NULL;
-static LockableULongPtr* global_auxArr            = NULL;
-
-/* =============================================================================
- * prefix_sums
- * =============================================================================
- */
-static void
-prefix_sums (ULONGINT_T* result, LONGINT_T* input, ULONGINT_T arraySize)
-{
-    long myId = thread_getId();
-    long numThread = thread_getNumThread();
-
-    ULONGINT_T* p = NULL;
-    if (myId == 0) {
-        p = (ULONGINT_T*)P_MALLOC(NOSHARE(numThread) * sizeof(ULONGINT_T));
-        assert(p);
-        global_p = p;
-    }
-
-    thread_barrier_wait();
-
-    p = global_p;
-
-    long start;
-    long end;
-
-    long r = arraySize / numThread;
-    start = myId * r + 1;
-    end = (myId + 1) * r;
-    if (myId == (numThread - 1)) {
-        end = arraySize;
-    }
-
-    ULONGINT_T j;
-    for (j = start; j < end; j++) {
-        result[j] = input[j-1] + result[j-1];
-    }
-
-    p[NOSHARE(myId)] = result[end-1];
-
-    thread_barrier_wait();
-
-    if (myId == 0) {
-        for (j = 1; j < numThread; j++) {
-            p[NOSHARE(j)] += p[NOSHARE(j-1)];
-        }
-    }
-
-    thread_barrier_wait();
-
-    if (myId > 0) {
-        ULONGINT_T add_value = p[NOSHARE(myId-1)];
-        for (j = start-1; j < end; j++) {
-            result[j] += add_value;
-        }
-    }
-
-    thread_barrier_wait();
-
-    if (myId == 0) {
-        P_FREE(p);
-    }
-}
-
-static void
-prefix_sums2 (ULONGINT_T* result, LockableLong* input, ULONGINT_T arraySize)
-{
-    long myId = thread_getId();
-    long numThread = thread_getNumThread();
-
-    ULONGINT_T* p = NULL;
-    if (myId == 0) {
-        p = (ULONGINT_T*)P_MALLOC(NOSHARE(numThread) * sizeof(ULONGINT_T));
-        assert(p);
-        global_p = p;
-    }
-
-    thread_barrier_wait();
-
-    p = global_p;
-
-    long start;
-    long end;
-
-    long r = arraySize / numThread;
-    start = myId * r + 1;
-    end = (myId + 1) * r;
-    if (myId == (numThread - 1)) {
-        end = arraySize;
-    }
-
-    ULONGINT_T j;
-    for (j = start; j < end; j++) {
-        result[j] = XTM_LOCKABLE_VALUE(input[j-1].value) + result[j-1];
-    }
-
-    p[NOSHARE(myId)] = result[end-1];
-
-    thread_barrier_wait();
-
-    if (myId == 0) {
-        for (j = 1; j < numThread; j++) {
-            p[NOSHARE(j)] += p[NOSHARE(j-1)];
-        }
-    }
-
-    thread_barrier_wait();
-
-    if (myId > 0) {
-        ULONGINT_T add_value = p[NOSHARE(myId-1)];
-        for (j = start-1; j < end; j++) {
-            result[j] += add_value;
-        }
-    }
-
-    thread_barrier_wait();
-
-    if (myId == 0) {
-        P_FREE(p);
-    }
-}
-
-
-/* =============================================================================
- * computeGraph
- * =============================================================================
- */
-void
-computeGraph (void* argPtr)
-{
-    TM_THREAD_ENTER();
-
-    graph*    GPtr       = ((computeGraph_arg_t*)argPtr)->GPtr;
-    graphSDG* SDGdataPtr = ((computeGraph_arg_t*)argPtr)->SDGdataPtr;
-
-    long myId = thread_getId();
-    long numThread = thread_getNumThread();
-
-    ULONGINT_T j;
-    ULONGINT_T maxNumVertices = 0;
-    ULONGINT_T numEdgesPlaced = SDGdataPtr->numEdgesPlaced;
-
-    /*
-     * First determine the number of vertices by scanning the tuple
-     * startVertex list
-     */
-
-    long i;
-    long i_start;
-    long i_stop;
-    createPartition(0, numEdgesPlaced, myId, numThread, &i_start, &i_stop);
-
-    for (i = i_start; i < i_stop; i++) {
-        if (SDGdataPtr->startVertex[i] > maxNumVertices) {
-            maxNumVertices = SDGdataPtr->startVertex[i];
-        }
-    }
-
-    TM_BEGIN();
-    long tmp_maxNumVertices = (long)TM_SHARED_READ(global_maxNumVertices);
-    long new_maxNumVertices = MAX(tmp_maxNumVertices, maxNumVertices) + 1;
-    TM_SHARED_WRITE(global_maxNumVertices, new_maxNumVertices);
-    TM_END();
-
-    thread_barrier_wait();
-
-    maxNumVertices = XTM_LOCKABLE_VALUE(global_maxNumVertices);
-
-    if (myId == 0) {
-
-        GPtr->numVertices = maxNumVertices;
-        GPtr->numEdges    = numEdgesPlaced;
-        GPtr->intWeight   = SDGdataPtr->intWeight;
-        GPtr->strWeight   = SDGdataPtr->strWeight;
-
-        for (i = 0; i < numEdgesPlaced; i++) {
-            if (GPtr->intWeight[numEdgesPlaced-i-1] < 0) {
-                GPtr->numStrEdges = -(GPtr->intWeight[numEdgesPlaced-i-1]) + 1;
-                GPtr->numIntEdges = numEdgesPlaced - GPtr->numStrEdges;
-                break;
-            }
-        }
-
-        GPtr->outDegree =
-            (LONGINT_T*)P_MALLOC((GPtr->numVertices) * sizeof(LONGINT_T));
-        assert(GPtr->outDegree);
-
-        GPtr->outVertexIndex =
-            (ULONGINT_T*)P_MALLOC((GPtr->numVertices) * sizeof(ULONGINT_T));
-        assert(GPtr->outVertexIndex);
-    }
-
-    thread_barrier_wait();
-
-    createPartition(0, GPtr->numVertices, myId, numThread, &i_start, &i_stop);
-
-    for (i = i_start; i < i_stop; i++) {
-        GPtr->outDegree[i] = 0;
-        GPtr->outVertexIndex[i] = 0;
-    }
-
-    ULONGINT_T outVertexListSize = 0;
-
-    thread_barrier_wait();
-
-    ULONGINT_T i0 = -1UL;
-
-    for (i = i_start; i < i_stop; i++) {
-
-        ULONGINT_T k = i;
-        if ((outVertexListSize == 0) && (k != 0)) {
-            while (i0 == -1UL) {
-                for (j = 0; j < numEdgesPlaced; j++) {
-                    if (k == SDGdataPtr->startVertex[j]) {
-                        i0 = j;
-                        break;
-                    }
-
-                }
-                k--;
-            }
-        }
-
-        if ((outVertexListSize == 0) && (k == 0)) {
-            i0 = 0;
-        }
-
-        for (j = i0; j < numEdgesPlaced; j++) {
-            if (i == GPtr->numVertices-1) {
-                break;
-            }
-            if ((i != SDGdataPtr->startVertex[j])) {
-                if ((j > 0) && (i == SDGdataPtr->startVertex[j-1])) {
-                    if (j-i0 >= 1) {
-                        outVertexListSize++;
-                        GPtr->outDegree[i]++;
-                        ULONGINT_T t;
-                        for (t = i0+1; t < j; t++) {
-                            if (SDGdataPtr->endVertex[t] !=
-                                SDGdataPtr->endVertex[t-1])
-                            {
-                                outVertexListSize++;
-                                GPtr->outDegree[i] = GPtr->outDegree[i]+1;
-                            }
-                        }
-                    }
-                }
-                i0 = j;
-                break;
-            }
-        }
-
-        if (i == GPtr->numVertices-1) {
-            if (numEdgesPlaced-i0 >= 0) {
-                outVertexListSize++;
-                GPtr->outDegree[i]++;
-                ULONGINT_T t;
-                for (t = i0+1; t < numEdgesPlaced; t++) {
-                    if (SDGdataPtr->endVertex[t] != SDGdataPtr->endVertex[t-1]) {
-                        outVertexListSize++;
-                        GPtr->outDegree[i]++;
-                    }
-                }
-            }
-        }
-
-    } /* for i */
-
-    thread_barrier_wait();
-
-    prefix_sums(GPtr->outVertexIndex, GPtr->outDegree, GPtr->numVertices);
-
-    // XXX For some reason, TinySTM does not generate the correct code
-    // for the summation below, just implement with atomic increment
-    __sync_fetch_and_add(&global_outVertexListSize, outVertexListSize);
-
-    thread_barrier_wait();
-
-    // XXX race
-    //TM_BEGIN();
-    //TM_SHARED_WRITE(
-    //    global_outVertexListSize,
-    //    ((long)TM_SHARED_READ(global_outVertexListSize) + outVertexListSize)
-    //);
-    //TM_END();
-
-    thread_barrier_wait();
-
-    outVertexListSize = global_outVertexListSize;
-
-    if (myId == 0) {
-        GPtr->numDirectedEdges = outVertexListSize;
-        GPtr->outVertexList =
-            (ULONGINT_T*)P_MALLOC(outVertexListSize * sizeof(ULONGINT_T));
-        assert(GPtr->outVertexList);
-        GPtr->paralEdgeIndex =
-            (ULONGINT_T*)P_MALLOC(outVertexListSize * sizeof(ULONGINT_T));
-        assert(GPtr->paralEdgeIndex);
-        GPtr->outVertexList[0] = SDGdataPtr->endVertex[0];
-    }
-
-    thread_barrier_wait();
-
-    /*
-     * Evaluate outVertexList
-     */
-
-    i0 = -1UL;
-
-    for (i = i_start; i < i_stop; i++) {
-
-        ULONGINT_T k = i;
-        while ((i0 == -1UL) && (k != 0)) {
-            for (j = 0; j < numEdgesPlaced; j++) {
-                if (k == SDGdataPtr->startVertex[j]) {
-                    i0 = j;
-                    break;
-                }
-            }
-            k--;
-        }
-
-        if ((i0 == -1) && (k == 0)) {
-            i0 = 0;
-        }
-
-        for (j = i0; j < numEdgesPlaced; j++) {
-            if (i == GPtr->numVertices-1) {
-                break;
-            }
-            if (i != SDGdataPtr->startVertex[j]) {
-                if ((j > 0) && (i == SDGdataPtr->startVertex[j-1])) {
-                    if (j-i0 >= 1) {
-                        long ii = GPtr->outVertexIndex[i];
-                        ULONGINT_T r = 0;
-                        GPtr->paralEdgeIndex[ii] = i0;
-                        GPtr->outVertexList[ii] = SDGdataPtr->endVertex[i0];
-                        r++;
-                        ULONGINT_T t;
-                        for (t = i0+1; t < j; t++) {
-                            if (SDGdataPtr->endVertex[t] !=
-                                SDGdataPtr->endVertex[t-1])
-                            {
-                                GPtr->paralEdgeIndex[ii+r] = t;
-                                GPtr->outVertexList[ii+r] = SDGdataPtr->endVertex[t];
-                                r++;
-                            }
-                        }
-
-                    }
-                }
-                i0 = j;
-                break;
-            }
-        } /* for j */
-
-        if (i == GPtr->numVertices-1) {
-            ULONGINT_T r = 0;
-            if (numEdgesPlaced-i0 >= 0) {
-                long ii = GPtr->outVertexIndex[i];
-                GPtr->paralEdgeIndex[ii+r] = i0;
-                GPtr->outVertexList[ii+r] = SDGdataPtr->endVertex[i0];
-                r++;
-                ULONGINT_T t;
-                for (t = i0+1; t < numEdgesPlaced; t++) {
-                    if (SDGdataPtr->endVertex[t] != SDGdataPtr->endVertex[t-1]) {
-                        GPtr->paralEdgeIndex[ii+r] = t;
-                        GPtr->outVertexList[ii+r] = SDGdataPtr->endVertex[t];
-                        r++;
-                    }
-                }
-            }
-        }
-
-    } /* for i */
-
-    thread_barrier_wait();
-
-    if (myId == 0) {
-        P_FREE(SDGdataPtr->startVertex);
-        P_FREE(SDGdataPtr->endVertex);
-        GPtr->inDegree =
-            (LockableLong*)P_MALLOC(GPtr->numVertices * sizeof(LockableLong));
-        assert(GPtr->inDegree);
-        GPtr->inVertexIndex =
-            (ULONGINT_T*)P_MALLOC(GPtr->numVertices * sizeof(ULONGINT_T));
-        assert(GPtr->inVertexIndex);
-    }
-
-    thread_barrier_wait();
-
-    for (i = i_start; i < i_stop; i++) {
-        XTM_LOCKABLE_VALUE(GPtr->inDegree[i].value) = 0;
-        XTM_LOCKABLE_INIT(GPtr->inDegree[i].value);
-        GPtr->inVertexIndex[i] = 0;
-    }
-
-    /* A temp. array to store the inplied edges */
-    LockableULong* impliedEdgeList;
-    if (myId == 0) {
-        impliedEdgeList = (LockableULong*)P_MALLOC(GPtr->numVertices
-                                                * MAX_CLUSTER_SIZE
-                                                * sizeof(LockableULong));
-        global_impliedEdgeList = impliedEdgeList;
-    }
-
-    thread_barrier_wait();
-
-    impliedEdgeList = global_impliedEdgeList;
-
-    createPartition(0,
-                    (GPtr->numVertices * MAX_CLUSTER_SIZE),
-                    myId,
-                    numThread,
-                    &i_start,
-                    &i_stop);
-
-    for (i = i_start; i < i_stop; i++) {
-        XTM_LOCKABLE_VALUE(impliedEdgeList[i].value1) = 0;
-        XTM_LOCKABLE_INIT(impliedEdgeList[i].value1);
-    }
-
-    /*
-     * An auxiliary array to store implied edges, in case we overshoot
-     * MAX_CLUSTER_SIZE
-     */
-
-    LockableULongPtr* auxArr;
-    if (myId == 0) {
-        auxArr = (LockableULongPtr*)P_MALLOC(GPtr->numVertices * sizeof(*auxArr));
-        assert(auxArr);
-        global_auxArr = auxArr;
-        for (i = 0; i < GPtr->numVertices; ++i) {
-            XTM_LOCKABLE_INIT(auxArr[i].value2);
-        }
-    }
-
-    thread_barrier_wait();
-
-    auxArr = global_auxArr;
-
-    createPartition(0, GPtr->numVertices, myId, numThread, &i_start, &i_stop);
-
-    for (i = i_start; i < i_stop; i++) {
-        /* Inspect adjacency list of vertex i */
-        for (j = GPtr->outVertexIndex[i];
-             j < (GPtr->outVertexIndex[i] + GPtr->outDegree[i]);
-             j++)
-        {
-            ULONGINT_T v = GPtr->outVertexList[j];
-            ULONGINT_T k;
-            for (k = GPtr->outVertexIndex[v];
-                 k < (GPtr->outVertexIndex[v] + GPtr->outDegree[v]);
-                 k++)
-            {
-                if (GPtr->outVertexList[k] == i) {
-                    break;
-                }
-            }
-            if (k == GPtr->outVertexIndex[v]+GPtr->outDegree[v]) {
-                TM_BEGIN();
-                /* Add i to the impliedEdgeList of v */
-                long inDegree = (long)TM_SHARED_READ(GPtr->inDegree[v].value);
-                TM_SHARED_WRITE(GPtr->inDegree[v].value, (inDegree + 1));
-                if (inDegree < MAX_CLUSTER_SIZE) {
-                    TM_SHARED_WRITE(impliedEdgeList[v*MAX_CLUSTER_SIZE+inDegree].value1,
-                                    i);
-                } else {
-                    /* Use auxiliary array to store the implied edge */
-                    /* Create an array if it's not present already */
-                    LockableULong* a = NULL;
-                    if ((inDegree % MAX_CLUSTER_SIZE) == 0) {
-                        a = (LockableULong*)TM_MALLOC(MAX_CLUSTER_SIZE
-                                                   * sizeof(*a));
-                        assert(a);
-                        TM_SHARED_WRITE_P(auxArr[v].value2, a);
-                    } else {
-                        a = XTM_LOCKABLE_VALUE(auxArr[v].value2);
-                    }
-                    TM_SHARED_WRITE(a[inDegree % MAX_CLUSTER_SIZE].value1, i);
-                }
-                TM_END();
-            }
-        }
-    } /* for i */
-
-    thread_barrier_wait();
-
-    prefix_sums2(GPtr->inVertexIndex, GPtr->inDegree, GPtr->numVertices);
-
-    if (myId == 0) {
-        GPtr->numUndirectedEdges = GPtr->inVertexIndex[GPtr->numVertices-1]
-                                   + XTM_LOCKABLE_VALUE(GPtr->inDegree[GPtr->numVertices-1].value);
-        GPtr->inVertexList =
-            (ULONGINT_T *)P_MALLOC(GPtr->numUndirectedEdges * sizeof(ULONGINT_T));
-    }
-
-    thread_barrier_wait();
-
-    /*
-     * Create the inVertex List
-     */
-
-    for (i = i_start; i < i_stop; i++) {
-        for (j = GPtr->inVertexIndex[i];
-             j < (GPtr->inVertexIndex[i] + XTM_LOCKABLE_VALUE(GPtr->inDegree[i].value));
-             j++)
-        {
-            if ((j - GPtr->inVertexIndex[i]) < MAX_CLUSTER_SIZE) {
-                GPtr->inVertexList[j] =
-                    XTM_LOCKABLE_VALUE(impliedEdgeList[i*MAX_CLUSTER_SIZE+j-GPtr->inVertexIndex[i]].value1);
-            } else {
-                GPtr->inVertexList[j] =
-                    XTM_LOCKABLE_VALUE(XTM_LOCKABLE_VALUE(auxArr[i].value2)[(j-GPtr->inVertexIndex[i]) % MAX_CLUSTER_SIZE].value1);
-            }
-        }
-    }
-
-    thread_barrier_wait();
-
-    if (myId == 0) {
-        P_FREE(impliedEdgeList);
-    }
-
-    for (i = i_start; i < i_stop; i++) {
-        if (XTM_LOCKABLE_VALUE(GPtr->inDegree[i].value) > MAX_CLUSTER_SIZE) {
-            TM_FREE(XTM_LOCKABLE_VALUE(auxArr[i].value2));
-        }
-    }
-
-    thread_barrier_wait();
-
-    if (myId == 0) {
-        P_FREE(auxArr);
-    }
-
-    TM_THREAD_EXIT();
-}
-
-
-/* =============================================================================
- *
- * End of computeGraph.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/ssca2/computeGraph.cpp stamp-g/ssca2/computeGraph.cpp
--- stamp-0.9.10/ssca2/computeGraph.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-g/ssca2/computeGraph.cpp	2017-03-21 18:34:01.000000000 +0000
@@ -0,0 +1,1063 @@
+/* =============================================================================
+ *
+ * computeGraph.c
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+
+#include "Galois/Galois.h"
+#include "Galois/Accumulator.h"
+#include "Galois/WorkList/WorkList.h"
+extern "C" {
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "computeGraph.h"
+#include "createPartition.h"
+#include "defs.h"
+#include "globals.h"
+#include "thread.h"
+#include "utility.h"
+#include "tm.h"
+}
+#define ORIGINAL 0
+#define thread_barrier_wait(x)
+#include <deque>
+
+static ULONGINT_T*  global_p                 = NULL;
+static ULONGINT_T   global_maxNumVertices    = 0;
+static ULONGINT_T   global_outVertexListSize = 0;
+static ULONGINT_T*  global_impliedEdgeList   = NULL;
+static ULONGINT_T** global_auxArr            = NULL;
+
+
+struct Fn10 {
+    ULONGINT_T* result;
+    LONGINT_T* input;
+    ULONGINT_T arraySize;
+    ULONGINT_T* p;
+
+    Fn10(ULONGINT_T* _result, LONGINT_T* _input, ULONGINT_T _arraySize, ULONGINT_T* _p):
+      result(_result), input(_input), arraySize(_arraySize), p(_p) { }
+
+
+    void operator()(unsigned myId, unsigned numThread) {
+        long start;
+        long end;
+
+        long r = arraySize / numThread;
+        start = myId * r + 1;
+        end = (myId + 1) * r;
+        if (myId == (numThread - 1)) {
+            end = arraySize;
+        }
+
+        ULONGINT_T j;
+        for (j = start; j < end; j++) {
+            result[j] = input[j-1] + result[j-1];
+        }
+
+        p[NOSHARE(myId)] = result[end-1];
+    }
+};
+
+struct Fn11 {
+    ULONGINT_T* result;
+    LONGINT_T* input;
+    ULONGINT_T arraySize;
+    ULONGINT_T* p;
+
+    Fn11(ULONGINT_T* _result, LONGINT_T* _input, ULONGINT_T _arraySize, ULONGINT_T* _p):
+      result(_result), input(_input), arraySize(_arraySize), p(_p) { }
+
+
+    void operator()(unsigned myId, unsigned numThread) {
+        long start;
+        long end;
+
+        long r = arraySize / numThread;
+        start = myId * r + 1;
+        end = (myId + 1) * r;
+        if (myId == (numThread - 1)) {
+            end = arraySize;
+        }
+
+        if (myId > 0) {
+            ULONGINT_T add_value = p[NOSHARE(myId-1)];
+            for (ULONGINT_T j = start-1; j < end; j++) {
+                result[j] += add_value;
+            }
+        }
+    }
+};
+
+/* =============================================================================
+ * prefix_sums
+ * =============================================================================
+ */
+static void
+prefix_sums (ULONGINT_T* result, LONGINT_T* input, ULONGINT_T arraySize)
+{
+#if ORIGINAL
+    long myId = 0; //thread_getId();
+    long numThread = 1; //thread_getNumThread();
+#else
+    long myId = 0;
+    long numThread = Galois::getActiveThreads();
+#endif
+
+    ULONGINT_T* p = NULL;
+    if (myId == 0) {
+        p = (ULONGINT_T*)P_MALLOC(NOSHARE(numThread) * sizeof(ULONGINT_T));
+        assert(p);
+        global_p = p;
+    }
+
+#if ORIGINAL
+    thread_barrier_wait();
+
+    p = global_p;
+
+    long start;
+    long end;
+
+    long r = arraySize / numThread;
+    start = myId * r + 1;
+    end = (myId + 1) * r;
+    if (myId == (numThread - 1)) {
+        end = arraySize;
+    }
+
+    ULONGINT_T j;
+    for (j = start; j < end; j++) {
+        result[j] = input[j-1] + result[j-1];
+    }
+
+    p[NOSHARE(myId)] = result[end-1];
+
+    thread_barrier_wait();
+#else
+    Galois::on_each(Fn10(result, input, arraySize, p));
+#endif
+
+    if (myId == 0) {
+        for (ULONGINT_T j = 1; j < numThread; j++) {
+            p[NOSHARE(j)] += p[NOSHARE(j-1)];
+        }
+    }
+
+#if ORIGINAL
+    thread_barrier_wait();
+
+    if (myId > 0) {
+        ULONGINT_T add_value = p[NOSHARE(myId-1)];
+        for (j = start-1; j < end; j++) {
+            result[j] += add_value;
+        }
+    }
+
+    thread_barrier_wait();
+#else
+    Galois::on_each(Fn11(result, input, arraySize, p));
+#endif
+
+    if (myId == 0) {
+        P_FREE(p);
+    }
+}
+
+
+struct Fn1 {
+    graphSDG* SDGdataPtr;
+    Galois::GReduceMax<long>& accum;
+
+    Fn1(
+      graphSDG* _SDGdataPtr,
+      Galois::GReduceMax<long>& _accum):
+    SDGdataPtr(_SDGdataPtr),
+    accum(_accum) { }
+
+    void operator()(long i) {
+        accum.update(SDGdataPtr->startVertex[i]);
+    }
+};
+
+
+struct Fn2 {
+    graph* GPtr;
+
+    Fn2(
+        graph* _GPtr): GPtr(_GPtr) { }
+
+    void operator()(long i) {
+          GPtr->outDegree[i] = 0;
+          GPtr->outVertexIndex[i] = 0;
+    }
+};
+
+struct Fn3 {
+    Galois::GAccumulator<long>& accumOutVertexListSize;
+    graph* GPtr;
+    graphSDG* SDGdataPtr;
+
+    Fn3(
+    Galois::GAccumulator<long>& _accumOutVertexListSize,
+    graph* _GPtr,
+    graphSDG* _SDGdataPtr
+    ):
+    accumOutVertexListSize(_accumOutVertexListSize),
+    GPtr(_GPtr),
+    SDGdataPtr(_SDGdataPtr) { }
+
+    void operator()(unsigned myId, unsigned numThread) {
+        ULONGINT_T outVertexListSize = 0;
+        ULONGINT_T numEdgesPlaced = SDGdataPtr->numEdgesPlaced;
+        long i_start, i_stop;
+        createPartition(0, GPtr->numVertices, myId, numThread, &i_start, &i_stop);
+
+        ULONGINT_T i0 = -1UL;
+
+        for (long i = i_start; i < i_stop; i++) {
+            ULONGINT_T k = i;
+            if ((outVertexListSize == 0) && (k != 0)) {
+                while (i0 == -1UL) {
+                    for (ULONGINT_T j = 0; j < numEdgesPlaced; j++) {
+                        if (k == SDGdataPtr->startVertex[j]) {
+                            i0 = j;
+                            break;
+                        }
+
+                    }
+                    k--;
+                }
+            }
+
+            if ((outVertexListSize == 0) && (k == 0)) {
+                i0 = 0;
+            }
+
+            for (ULONGINT_T j = i0; j < numEdgesPlaced; j++) {
+                if (i == GPtr->numVertices-1) {
+                    break;
+                }
+                if ((i != SDGdataPtr->startVertex[j])) {
+                    if ((j > 0) && (i == SDGdataPtr->startVertex[j-1])) {
+                        if (j-i0 >= 1) {
+                            outVertexListSize++;
+                            GPtr->outDegree[i]++;
+                            ULONGINT_T t;
+                            for (t = i0+1; t < j; t++) {
+                                if (SDGdataPtr->endVertex[t] !=
+                                    SDGdataPtr->endVertex[t-1])
+                                {
+                                    outVertexListSize++;
+                                    GPtr->outDegree[i] = GPtr->outDegree[i]+1;
+                                }
+                            }
+                        }
+                    }
+                    i0 = j;
+                    break;
+                }
+            }
+
+            if (i == GPtr->numVertices-1) {
+                if (numEdgesPlaced-i0 >= 0) {
+                    outVertexListSize++;
+                    GPtr->outDegree[i]++;
+                    ULONGINT_T t;
+                    for (t = i0+1; t < numEdgesPlaced; t++) {
+                        if (SDGdataPtr->endVertex[t] != SDGdataPtr->endVertex[t-1]) {
+                            outVertexListSize++;
+                            GPtr->outDegree[i]++;
+                        }
+                    }
+                }
+            }
+        } /* for i */
+
+        accumOutVertexListSize.update(outVertexListSize);
+    }
+};
+
+struct Fn4 {
+    graph* GPtr;
+    graphSDG* SDGdataPtr;
+
+    Fn4(
+    graph* _GPtr,
+    graphSDG* _SDGdataPtr
+    ):
+    GPtr(_GPtr),
+    SDGdataPtr(_SDGdataPtr) { }
+
+    void operator()(unsigned myId, unsigned numThread) {
+        ULONGINT_T numEdgesPlaced = SDGdataPtr->numEdgesPlaced;
+        long i_start, i_stop;
+        createPartition(0, GPtr->numVertices, myId, numThread, &i_start, &i_stop);
+
+        ULONGINT_T i0 = -1UL;
+        for (long i = i_start; i < i_stop; i++) {
+
+            ULONGINT_T k = i;
+            while ((i0 == -1UL) && (k != 0)) {
+                for (ULONGINT_T j = 0; j < numEdgesPlaced; j++) {
+                    if (k == SDGdataPtr->startVertex[j]) {
+                        i0 = j;
+                        break;
+                    }
+                }
+                k--;
+            }
+
+            if ((i0 == -1) && (k == 0)) {
+                i0 = 0;
+            }
+
+            for (ULONGINT_T j = i0; j < numEdgesPlaced; j++) {
+                if (i == GPtr->numVertices-1) {
+                    break;
+                }
+                if (i != SDGdataPtr->startVertex[j]) {
+                    if ((j > 0) && (i == SDGdataPtr->startVertex[j-1])) {
+                        if (j-i0 >= 1) {
+                            long ii = GPtr->outVertexIndex[i];
+                            ULONGINT_T r = 0;
+                            GPtr->paralEdgeIndex[ii] = i0;
+                            GPtr->outVertexList[ii] = SDGdataPtr->endVertex[i0];
+                            r++;
+                            ULONGINT_T t;
+                            for (t = i0+1; t < j; t++) {
+                                if (SDGdataPtr->endVertex[t] !=
+                                    SDGdataPtr->endVertex[t-1])
+                                {
+                                    GPtr->paralEdgeIndex[ii+r] = t;
+                                    GPtr->outVertexList[ii+r] = SDGdataPtr->endVertex[t];
+                                    r++;
+                                }
+                            }
+
+                        }
+                    }
+                    i0 = j;
+                    break;
+                }
+            } /* for j */
+
+            if (i == GPtr->numVertices-1) {
+                ULONGINT_T r = 0;
+                if (numEdgesPlaced-i0 >= 0) {
+                    long ii = GPtr->outVertexIndex[i];
+                    GPtr->paralEdgeIndex[ii+r] = i0;
+                    GPtr->outVertexList[ii+r] = SDGdataPtr->endVertex[i0];
+                    r++;
+                    ULONGINT_T t;
+                    for (t = i0+1; t < numEdgesPlaced; t++) {
+                        if (SDGdataPtr->endVertex[t] != SDGdataPtr->endVertex[t-1]) {
+                            GPtr->paralEdgeIndex[ii+r] = t;
+                            GPtr->outVertexList[ii+r] = SDGdataPtr->endVertex[t];
+                            r++;
+                        }
+                    }
+                }
+            }
+        } /* for i */
+    }
+};
+
+struct Fn5 {
+    graph* GPtr;
+
+    Fn5(
+        graph* _GPtr): GPtr(_GPtr) { }
+
+    void operator()(long i) {
+          GPtr->inDegree[i] = 0;
+          GPtr->inVertexIndex[i] = 0;
+    }
+};
+
+struct Fn6 {
+    ULONGINT_T* impliedEdgeList;
+
+    Fn6(
+    ULONGINT_T* _impliedEdgeList
+    ):
+    impliedEdgeList(_impliedEdgeList) { }
+
+    void operator()(long i) {
+        impliedEdgeList[i] = 0;
+    }
+};
+
+struct Fn7 {
+    graph* GPtr;
+    ULONGINT_T** auxArr;
+    ULONGINT_T* impliedEdgeList;
+    Galois::Runtime::Lockable* locks;
+    Galois::Runtime::MM::FixedSizeAllocator heap;
+
+    Fn7(
+    graph* _GPtr,
+    ULONGINT_T** _auxArr,
+    ULONGINT_T* _impliedEdgeList,
+    Galois::Runtime::Lockable* _locks
+       ): 
+    GPtr(_GPtr),
+    auxArr(_auxArr),
+    impliedEdgeList(_impliedEdgeList),
+    locks(_locks),
+    heap(MAX_CLUSTER_SIZE * sizeof(ULONGINT_T))
+    { }
+
+    void operator()(long i, Galois::UserContext<long>& ctx) {
+        for (ULONGINT_T j = GPtr->outVertexIndex[i];
+             j < (GPtr->outVertexIndex[i] + GPtr->outDegree[i]);
+             j++)
+        {
+            ULONGINT_T v = GPtr->outVertexList[j];
+#ifndef HTM
+            Galois::Runtime::acquire(&locks[v], Galois::MethodFlag::ALL);
+#endif
+        }
+
+        /* Inspect adjacency list of vertex i */
+        for (ULONGINT_T j = GPtr->outVertexIndex[i];
+             j < (GPtr->outVertexIndex[i] + GPtr->outDegree[i]);
+             j++)
+        {
+            ULONGINT_T v = GPtr->outVertexList[j];
+            ULONGINT_T k;
+            for (k = GPtr->outVertexIndex[v];
+                 k < (GPtr->outVertexIndex[v] + GPtr->outDegree[v]);
+                 k++)
+            {
+                if (GPtr->outVertexList[k] == i) {
+                    break;
+                }
+            }
+            if (k == GPtr->outVertexIndex[v]+GPtr->outDegree[v]) {
+                /* Add i to the impliedEdgeList of v */
+                long inDegree = GPtr->inDegree[v];
+                GPtr->inDegree[v] = inDegree + 1;
+                if (inDegree < MAX_CLUSTER_SIZE) {
+                    impliedEdgeList[v*MAX_CLUSTER_SIZE+inDegree] = i;
+                } else {
+                    /* Use auxiliary array to store the implied edge */
+                    /* Create an array if it's not present already */
+                    ULONGINT_T* a = NULL;
+                    if ((inDegree % MAX_CLUSTER_SIZE) == 0) {
+                        
+                        a = (ULONGINT_T*) heap.allocate(MAX_CLUSTER_SIZE
+                                                   * sizeof(ULONGINT_T));
+                        assert(a);
+                        auxArr[v] = a;
+                    } else {
+                        a = auxArr[v];
+                    }
+                    a[inDegree % MAX_CLUSTER_SIZE] = i;
+                }
+            }
+        }
+    }
+};
+
+struct Fn8 {
+    graph* GPtr;
+    ULONGINT_T* impliedEdgeList;
+    ULONGINT_T** auxArr;
+
+    Fn8(
+    graph* _GPtr,
+    ULONGINT_T* _impliedEdgeList,
+    ULONGINT_T** _auxArr
+       ):
+    GPtr(_GPtr),
+    impliedEdgeList(_impliedEdgeList),
+    auxArr(_auxArr) { }
+
+    void operator()(long i) {
+        for (ULONGINT_T j = GPtr->inVertexIndex[i];
+             j < (GPtr->inVertexIndex[i] + GPtr->inDegree[i]);
+             j++)
+        {
+            if ((j - GPtr->inVertexIndex[i]) < MAX_CLUSTER_SIZE) {
+                GPtr->inVertexList[j] =
+                    impliedEdgeList[i*MAX_CLUSTER_SIZE+j-GPtr->inVertexIndex[i]];
+            } else {
+                GPtr->inVertexList[j] =
+                    auxArr[i][(j-GPtr->inVertexIndex[i]) % MAX_CLUSTER_SIZE];
+            }
+        }
+    }
+};
+
+struct Fn9 {
+    graph* GPtr;
+    ULONGINT_T* impliedEdgeList;
+    ULONGINT_T** auxArr;
+    Galois::Runtime::MM::FixedSizeAllocator heap;
+
+    Fn9(
+    graph* _GPtr,
+    ULONGINT_T** _auxArr
+       ):
+    GPtr(_GPtr),
+    auxArr(_auxArr),
+    heap(MAX_CLUSTER_SIZE * sizeof(ULONGINT_T))
+  { }
+
+    void operator()(long i) {
+        if (GPtr->inDegree[i] > MAX_CLUSTER_SIZE) {
+            heap.deallocate(auxArr[i]);
+        }
+    }
+};
+
+struct Fn13 {
+    Galois::Runtime::Lockable* locks;
+
+    Fn13(Galois::Runtime::Lockable* _locks): locks(_locks) { }
+
+    void operator()(long i) {
+        new (&locks[i]) Galois::Runtime::Lockable();
+    }
+};
+
+/* =============================================================================
+ * computeGraph
+ * =============================================================================
+ */
+void
+computeGraph (void* argPtr)
+{
+    TM_THREAD_ENTER();
+
+    graph*    GPtr       = ((computeGraph_arg_t*)argPtr)->GPtr;
+    graphSDG* SDGdataPtr = ((computeGraph_arg_t*)argPtr)->SDGdataPtr;
+
+#if ORIGINAL
+    long myId = 0; //thread_getId();
+    long numThread = 1; //thread_getNumThread();
+#else
+    long myId = 0;
+#endif
+
+    ULONGINT_T j;
+    ULONGINT_T maxNumVertices = 0;
+    ULONGINT_T numEdgesPlaced = SDGdataPtr->numEdgesPlaced;
+
+    /*
+     * First determine the number of vertices by scanning the tuple
+     * startVertex list
+     */
+
+    long i;
+    long i_start;
+    long i_stop;
+#if ORIGINAL
+    createPartition(0, numEdgesPlaced, myId, numThread, &i_start, &i_stop);
+
+    for (i = i_start; i < i_stop; i++) {
+        if (SDGdataPtr->startVertex[i] > maxNumVertices) {
+            maxNumVertices = SDGdataPtr->startVertex[i];
+        }
+    }
+
+    TM_BEGIN();
+    long tmp_maxNumVertices = (long)TM_SHARED_READ(global_maxNumVertices);
+    long new_maxNumVertices = (tmp_maxNumVertices > maxNumVertices ? tmp_maxNumVertices : maxNumVertices) + 1; //MAX(tmp_maxNumVertices, maxNumVertices) + 1;
+    TM_SHARED_WRITE(global_maxNumVertices, new_maxNumVertices);
+    TM_END();
+
+    thread_barrier_wait();
+
+    maxNumVertices = global_maxNumVertices;
+#else
+    Galois::GReduceMax<long> accumMaxNumVertices;
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(numEdgesPlaced),
+        Fn1(SDGdataPtr, accumMaxNumVertices));
+    maxNumVertices = accumMaxNumVertices.reduce() + 1;
+#endif
+    if (myId == 0) {
+
+        GPtr->numVertices = maxNumVertices;
+        GPtr->numEdges    = numEdgesPlaced;
+        GPtr->intWeight   = SDGdataPtr->intWeight;
+        GPtr->strWeight   = SDGdataPtr->strWeight;
+
+        for (long i = 0; i < numEdgesPlaced; i++) {
+            if (GPtr->intWeight[numEdgesPlaced-i-1] < 0) {
+                GPtr->numStrEdges = -(GPtr->intWeight[numEdgesPlaced-i-1]) + 1;
+                GPtr->numIntEdges = numEdgesPlaced - GPtr->numStrEdges;
+                break;
+            }
+        }
+
+        GPtr->outDegree =
+            (LONGINT_T*)P_MALLOC((GPtr->numVertices) * sizeof(LONGINT_T));
+        assert(GPtr->outDegree);
+
+        GPtr->outVertexIndex =
+            (ULONGINT_T*)P_MALLOC((GPtr->numVertices) * sizeof(ULONGINT_T));
+        assert(GPtr->outVertexIndex);
+    }
+
+#if ORIGINAL
+    thread_barrier_wait();
+
+    createPartition(0, GPtr->numVertices, myId, numThread, &i_start, &i_stop);
+
+    for (i = i_start; i < i_stop; i++) {
+        GPtr->outDegree[i] = 0;
+        GPtr->outVertexIndex[i] = 0;
+    }
+
+    thread_barrier_wait();
+#else
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(GPtr->numVertices),
+        Fn2(GPtr));
+#endif
+
+#if ORIGINAL
+    ULONGINT_T outVertexListSize = 0;
+
+    thread_barrier_wait();
+
+    ULONGINT_T i0 = -1UL;
+
+    for (i = i_start; i < i_stop; i++) {
+
+        ULONGINT_T k = i;
+        if ((outVertexListSize == 0) && (k != 0)) {
+            while (i0 == -1UL) {
+                for (j = 0; j < numEdgesPlaced; j++) {
+                    if (k == SDGdataPtr->startVertex[j]) {
+                        i0 = j;
+                        break;
+                    }
+
+                }
+                k--;
+            }
+        }
+
+        if ((outVertexListSize == 0) && (k == 0)) {
+            i0 = 0;
+        }
+
+        for (j = i0; j < numEdgesPlaced; j++) {
+            if (i == GPtr->numVertices-1) {
+                break;
+            }
+            if ((i != SDGdataPtr->startVertex[j])) {
+                if ((j > 0) && (i == SDGdataPtr->startVertex[j-1])) {
+                    if (j-i0 >= 1) {
+                        outVertexListSize++;
+                        GPtr->outDegree[i]++;
+                        ULONGINT_T t;
+                        for (t = i0+1; t < j; t++) {
+                            if (SDGdataPtr->endVertex[t] !=
+                                SDGdataPtr->endVertex[t-1])
+                            {
+                                outVertexListSize++;
+                                GPtr->outDegree[i] = GPtr->outDegree[i]+1;
+                            }
+                        }
+                    }
+                }
+                i0 = j;
+                break;
+            }
+        }
+
+        if (i == GPtr->numVertices-1) {
+            if (numEdgesPlaced-i0 >= 0) {
+                outVertexListSize++;
+                GPtr->outDegree[i]++;
+                ULONGINT_T t;
+                for (t = i0+1; t < numEdgesPlaced; t++) {
+                    if (SDGdataPtr->endVertex[t] != SDGdataPtr->endVertex[t-1]) {
+                        outVertexListSize++;
+                        GPtr->outDegree[i]++;
+                    }
+                }
+            }
+        }
+
+    } /* for i */
+
+    thread_barrier_wait();
+#else
+    Galois::GAccumulator<long> accumOutVertexListSize;
+    Galois::on_each(Fn3(accumOutVertexListSize, GPtr, SDGdataPtr));
+
+    ULONGINT_T outVertexListSize = accumOutVertexListSize.reduce();
+#endif
+
+#if ORIGINAL
+    prefix_sums(GPtr->outVertexIndex, GPtr->outDegree, GPtr->numVertices);
+
+    //thread_barrier_wait();
+
+    TM_BEGIN();
+    TM_SHARED_WRITE(
+        global_outVertexListSize,
+        ((long)TM_SHARED_READ(global_outVertexListSize) + outVertexListSize)
+    );
+    TM_END();
+
+    thread_barrier_wait();
+
+    outVertexListSize = global_outVertexListSize;
+#else
+    prefix_sums(GPtr->outVertexIndex, GPtr->outDegree, GPtr->numVertices);
+#endif
+    if (myId == 0) {
+        GPtr->numDirectedEdges = outVertexListSize;
+        GPtr->outVertexList =
+            (ULONGINT_T*)P_MALLOC(outVertexListSize * sizeof(ULONGINT_T));
+        assert(GPtr->outVertexList);
+        GPtr->paralEdgeIndex =
+            (ULONGINT_T*)P_MALLOC(outVertexListSize * sizeof(ULONGINT_T));
+        assert(GPtr->paralEdgeIndex);
+        GPtr->outVertexList[0] = SDGdataPtr->endVertex[0];
+    }
+
+#if ORIGINAL
+    thread_barrier_wait();
+
+    /*
+     * Evaluate outVertexList
+     */
+
+    i0 = -1UL;
+
+    for (i = i_start; i < i_stop; i++) {
+
+        ULONGINT_T k = i;
+        while ((i0 == -1UL) && (k != 0)) {
+            for (j = 0; j < numEdgesPlaced; j++) {
+                if (k == SDGdataPtr->startVertex[j]) {
+                    i0 = j;
+                    break;
+                }
+            }
+            k--;
+        }
+
+        if ((i0 == -1) && (k == 0)) {
+            i0 = 0;
+        }
+
+        for (j = i0; j < numEdgesPlaced; j++) {
+            if (i == GPtr->numVertices-1) {
+                break;
+            }
+            if (i != SDGdataPtr->startVertex[j]) {
+                if ((j > 0) && (i == SDGdataPtr->startVertex[j-1])) {
+                    if (j-i0 >= 1) {
+                        long ii = GPtr->outVertexIndex[i];
+                        ULONGINT_T r = 0;
+                        GPtr->paralEdgeIndex[ii] = i0;
+                        GPtr->outVertexList[ii] = SDGdataPtr->endVertex[i0];
+                        r++;
+                        ULONGINT_T t;
+                        for (t = i0+1; t < j; t++) {
+                            if (SDGdataPtr->endVertex[t] !=
+                                SDGdataPtr->endVertex[t-1])
+                            {
+                                GPtr->paralEdgeIndex[ii+r] = t;
+                                GPtr->outVertexList[ii+r] = SDGdataPtr->endVertex[t];
+                                r++;
+                            }
+                        }
+
+                    }
+                }
+                i0 = j;
+                break;
+            }
+        } /* for j */
+
+        if (i == GPtr->numVertices-1) {
+            ULONGINT_T r = 0;
+            if (numEdgesPlaced-i0 >= 0) {
+                long ii = GPtr->outVertexIndex[i];
+                GPtr->paralEdgeIndex[ii+r] = i0;
+                GPtr->outVertexList[ii+r] = SDGdataPtr->endVertex[i0];
+                r++;
+                ULONGINT_T t;
+                for (t = i0+1; t < numEdgesPlaced; t++) {
+                    if (SDGdataPtr->endVertex[t] != SDGdataPtr->endVertex[t-1]) {
+                        GPtr->paralEdgeIndex[ii+r] = t;
+                        GPtr->outVertexList[ii+r] = SDGdataPtr->endVertex[t];
+                        r++;
+                    }
+                }
+            }
+        }
+
+    } /* for i */
+
+    thread_barrier_wait();
+#else
+    Galois::on_each(Fn4(GPtr, SDGdataPtr));
+#endif
+
+    if (myId == 0) {
+        P_FREE(SDGdataPtr->startVertex);
+        P_FREE(SDGdataPtr->endVertex);
+        GPtr->inDegree =
+            (LONGINT_T*)P_MALLOC(GPtr->numVertices * sizeof(LONGINT_T));
+        assert(GPtr->inDegree);
+        GPtr->inVertexIndex =
+            (ULONGINT_T*)P_MALLOC(GPtr->numVertices * sizeof(ULONGINT_T));
+        assert(GPtr->inVertexIndex);
+    }
+
+#if ORIGINAL
+    thread_barrier_wait();
+
+    for (i = i_start; i < i_stop; i++) {
+        GPtr->inDegree[i] = 0;
+        GPtr->inVertexIndex[i] = 0;
+    }
+#else
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(GPtr->numVertices),
+        Fn5(GPtr));
+#endif
+
+    /* A temp. array to store the inplied edges */
+    ULONGINT_T* impliedEdgeList;
+    if (myId == 0) {
+        impliedEdgeList = (ULONGINT_T*)P_MALLOC(GPtr->numVertices
+                                                * MAX_CLUSTER_SIZE
+                                                * sizeof(ULONGINT_T));
+        global_impliedEdgeList = impliedEdgeList;
+    }
+
+#if ORIGINAL
+    thread_barrier_wait();
+
+    impliedEdgeList = global_impliedEdgeList;
+
+    createPartition(0,
+                    (GPtr->numVertices * MAX_CLUSTER_SIZE),
+                    myId,
+                    numThread,
+                    &i_start,
+                    &i_stop);
+
+    for (i = i_start; i < i_stop; i++) {
+        impliedEdgeList[i] = 0;
+    }
+#else
+    impliedEdgeList = global_impliedEdgeList;
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(GPtr->numVertices * MAX_CLUSTER_SIZE),
+        Fn6(impliedEdgeList));
+#endif
+    /*
+     * An auxiliary array to store implied edges, in case we overshoot
+     * MAX_CLUSTER_SIZE
+     */
+
+    ULONGINT_T** auxArr;
+    if (myId == 0) {
+        auxArr = (ULONGINT_T**)P_MALLOC(GPtr->numVertices * sizeof(ULONGINT_T*));
+        assert(auxArr);
+        global_auxArr = auxArr;
+    }
+
+#if ORIGINAL
+    thread_barrier_wait();
+
+    auxArr = global_auxArr;
+
+    createPartition(0, GPtr->numVertices, myId, numThread, &i_start, &i_stop);
+
+    for (i = i_start; i < i_stop; i++) {
+        /* Inspect adjacency list of vertex i */
+        for (j = GPtr->outVertexIndex[i];
+             j < (GPtr->outVertexIndex[i] + GPtr->outDegree[i]);
+             j++)
+        {
+            ULONGINT_T v = GPtr->outVertexList[j];
+            ULONGINT_T k;
+            for (k = GPtr->outVertexIndex[v];
+                 k < (GPtr->outVertexIndex[v] + GPtr->outDegree[v]);
+                 k++)
+            {
+                if (GPtr->outVertexList[k] == i) {
+                    break;
+                }
+            }
+            if (k == GPtr->outVertexIndex[v]+GPtr->outDegree[v]) {
+                TM_BEGIN();
+                /* Add i to the impliedEdgeList of v */
+                long inDegree = (long)TM_SHARED_READ(GPtr->inDegree[v]);
+                TM_SHARED_WRITE(GPtr->inDegree[v], (inDegree + 1));
+                if (inDegree < MAX_CLUSTER_SIZE) {
+                    TM_SHARED_WRITE(impliedEdgeList[v*MAX_CLUSTER_SIZE+inDegree],
+                                    i);
+                } else {
+                    /* Use auxiliary array to store the implied edge */
+                    /* Create an array if it's not present already */
+                    ULONGINT_T* a = NULL;
+                    if ((inDegree % MAX_CLUSTER_SIZE) == 0) {
+                        a = (ULONGINT_T*)TM_MALLOC(MAX_CLUSTER_SIZE
+                                                   * sizeof(ULONGINT_T));
+                        assert(a);
+                        TM_SHARED_WRITE_P(auxArr[v], a);
+                    } else {
+                        a = auxArr[v];
+                    }
+                    TM_SHARED_WRITE(a[inDegree % MAX_CLUSTER_SIZE], i);
+                }
+                TM_END();
+            }
+        }
+    } /* for i */
+
+    thread_barrier_wait();
+#else
+    auxArr = global_auxArr;
+    Galois::Runtime::Lockable* locks = NULL;
+#ifndef HTM
+    locks = (Galois::Runtime::Lockable*) P_MALLOC(sizeof(*locks) * GPtr->numVertices);
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(GPtr->numVertices),
+      Fn13(locks));
+#endif
+    Galois::for_each(boost::counting_iterator<long>(0), boost::counting_iterator<long>(GPtr->numVertices),
+        Fn7(GPtr, auxArr, impliedEdgeList, locks), Galois::wl<Galois::WorkList::StableIterator<boost::counting_iterator<long>>>());
+
+    if (locks)
+        P_FREE(locks);
+#endif
+
+    prefix_sums(GPtr->inVertexIndex, GPtr->inDegree, GPtr->numVertices);
+
+    if (myId == 0) {
+        GPtr->numUndirectedEdges = GPtr->inVertexIndex[GPtr->numVertices-1]
+                                   + GPtr->inDegree[GPtr->numVertices-1];
+        GPtr->inVertexList =
+            (ULONGINT_T *)P_MALLOC(GPtr->numUndirectedEdges * sizeof(ULONGINT_T));
+    }
+
+#if ORIGINAL
+    thread_barrier_wait();
+
+    /*
+     * Create the inVertex List
+     */
+
+    for (i = i_start; i < i_stop; i++) {
+        for (j = GPtr->inVertexIndex[i];
+             j < (GPtr->inVertexIndex[i] + GPtr->inDegree[i]);
+             j++)
+        {
+            if ((j - GPtr->inVertexIndex[i]) < MAX_CLUSTER_SIZE) {
+                GPtr->inVertexList[j] =
+                    impliedEdgeList[i*MAX_CLUSTER_SIZE+j-GPtr->inVertexIndex[i]];
+            } else {
+                GPtr->inVertexList[j] =
+                    auxArr[i][(j-GPtr->inVertexIndex[i]) % MAX_CLUSTER_SIZE];
+            }
+        }
+    }
+
+    thread_barrier_wait();
+#else
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(GPtr->numVertices),
+        Fn8(GPtr, impliedEdgeList, auxArr));
+#endif
+
+    if (myId == 0) {
+        P_FREE(impliedEdgeList);
+    }
+
+#if ORIGINAL
+    for (i = i_start; i < i_stop; i++) {
+        if (GPtr->inDegree[i] > MAX_CLUSTER_SIZE) {
+            P_FREE(auxArr[i]);
+        }
+    }
+
+    thread_barrier_wait();
+#else
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(GPtr->numVertices),
+        Fn9(GPtr, auxArr));
+#endif
+
+    if (myId == 0) {
+        P_FREE(auxArr);
+    }
+
+    TM_THREAD_EXIT();
+}
+
+
+/* =============================================================================
+ *
+ * End of computeGraph.c
+ *
+ * =============================================================================
+ */
diff -x .git -x inputs -Naur stamp-0.9.10/ssca2/computeGraph.h stamp-g/ssca2/computeGraph.h
--- stamp-0.9.10/ssca2/computeGraph.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/ssca2/computeGraph.h	2017-03-20 15:19:41.000000000 +0000
@@ -70,6 +70,9 @@
 
 #include "defs.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef struct computeGragh_arg {
     graph* GPtr;
@@ -84,6 +87,9 @@
 void
 computeGraph (void* argPtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* COMPUTEGRAPH_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/ssca2/defs.h stamp-g/ssca2/defs.h
--- stamp-0.9.10/ssca2/defs.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/ssca2/defs.h	2017-03-20 15:19:41.000000000 +0000
@@ -67,8 +67,6 @@
 #ifndef DEFS_H
 #define DEFS_H 1
 
-#include "tm.h"
-
 typedef unsigned long int  ULONGINT_T;
 typedef long int           LONGINT_T;
 typedef short int          SHORTINT_T;
@@ -94,10 +92,6 @@
 
 } graphSDG;
 
-typedef struct LockableLong {
-    XTM_DECL_LOCKABLE(LONGINT_T, value);
-} LockableLong;
-
 typedef struct /*the graph data structure*/
 {
     ULONGINT_T numVertices;
@@ -114,7 +108,7 @@
     ULONGINT_T* outVertexList;
     ULONGINT_T* paralEdgeIndex;
 
-    LockableLong*  inDegree;
+    LONGINT_T*  inDegree;
     ULONGINT_T* inVertexIndex;
     ULONGINT_T* inVertexList;
 
diff -x .git -x inputs -Naur stamp-0.9.10/ssca2/getStartLists.c stamp-g/ssca2/getStartLists.c
--- stamp-0.9.10/ssca2/getStartLists.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/ssca2/getStartLists.c	2017-03-20 15:19:41.000000000 +0000
@@ -77,7 +77,7 @@
 #include "tm.h"
 #include "utility.h"
 
-static XTM_DECL_LOCKABLE(LONGINT_T, global_maxWeight); //          = 0;
+static LONGINT_T global_maxWeight          = 0;
 static long*     global_i_edgeStartCounter = NULL;
 static long*     global_i_edgeEndCounter   = NULL;
 static edge*     global_maxIntWtList       = NULL;
@@ -128,7 +128,7 @@
 
     thread_barrier_wait();
 
-    maxWeight = XTM_LOCKABLE_VALUE(global_maxWeight);
+    maxWeight = global_maxWeight;
 
     /*
      * Create partial lists
diff -x .git -x inputs -Naur stamp-0.9.10/ssca2/ssca2.c stamp-g/ssca2/ssca2.c
--- stamp-0.9.10/ssca2/ssca2.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/ssca2/ssca2.c	2017-03-21 18:34:11.000000000 +0000
@@ -171,14 +171,7 @@
 
 #ifdef USE_PARALLEL_DATA_GENERATION
     GOTO_SIM();
-#ifdef OTM
-#pragma omp parallel
-    {
-        genScalData((void*)SDGdata);
-    }
-#else
-    thread_start(genScalData, (void*)SDGdata);
-#endif
+    genScalData((void*)SDGdata);
     GOTO_REAL();
 #else /* !USE_PARALLEL_DATA_GENERATION */
     genScalData_seq(SDGdata);
@@ -212,22 +205,15 @@
     computeGraphArgs.GPtr       = G;
     computeGraphArgs.SDGdataPtr = SDGdata;
 
-    TIMER_READ(start);
 
     GOTO_SIM();
     thread_begin_timing();
-#ifdef OTM
-#pragma omp parallel
-    {
-        computeGraph((void*)&computeGraphArgs);
-    }
-#else
-    thread_start(computeGraph, (void*)&computeGraphArgs);
-#endif
+    TIMER_READ(start);
+    computeGraph((void*)&computeGraphArgs);
+    TIMER_READ(stop);
     thread_end_timing();
     GOTO_REAL();
 
-    TIMER_READ(stop);
 
     time = TIMER_DIFF_SECONDS(start, stop);
     totalTime += time;
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/CMakeLists.txt stamp-g/vacation/CMakeLists.txt
--- stamp-0.9.10/vacation/CMakeLists.txt	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/vacation/CMakeLists.txt	2017-03-20 15:19:41.000000000 +0000
@@ -4,20 +4,22 @@
 #
 # ==============================================================================
 
-add_definitions(-DLIST_NO_DUPLICATES -DMAP_USE_RBTREE)
+#add_definitions(-DLIST_NO_DUPLICATES -DMAP_USE_RBTREE)
 
 set(sources
-	client.c 
+	client.cpp 
 	customer.c 
 	manager.c 
-	reservation.c 
+	reservation.cpp
 	vacation.c 
-	${LIB_DIR}/list.c 
-	${LIB_DIR}/pair.c 
+        #${LIB_DIR}/list.c 
+	${LIB_DIR}/deque.cpp
+        #${LIB_DIR}/pair.c 
 	${LIB_DIR}/mt19937ar.c 
 	${LIB_DIR}/random.c 
-	${LIB_DIR}/rbtree.c 
-	${LIB_DIR}/thread.c)
+        #${LIB_DIR}/rbtree.c 
+        ${LIB_DIR}/map.cpp
+	${LIB_DIR}/thread.cpp)
 
 app(vacation ${sources})
 
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/action.h stamp-g/vacation/action.h
--- stamp-0.9.10/vacation/action.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/vacation/action.h	2017-03-20 15:19:41.000000000 +0000
@@ -72,6 +72,9 @@
 #ifndef ACTION_H
 #define ACTION_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef enum action {
     ACTION_MAKE_RESERVATION = 0,
@@ -80,6 +83,10 @@
     NUM_ACTION
 } action_t;
 
+#ifdef __cplusplus
+}
+#endif
+
 
 #endif /* ACTION_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/client.c stamp-g/vacation/client.c
--- stamp-0.9.10/vacation/client.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/vacation/client.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,327 +0,0 @@
-/* =============================================================================
- *
- * client.c
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include "action.h"
-#include "client.h"
-#include "manager.h"
-#include "reservation.h"
-#include "thread.h"
-#include "types.h"
-
-
-/* =============================================================================
- * client_alloc
- * -- Returns NULL on failure
- * =============================================================================
- */
-client_t*
-client_alloc (long id,
-              manager_t* managerPtr,
-              long numOperation,
-              long numQueryPerTransaction,
-              long queryRange,
-              long percentUser)
-{
-    client_t* clientPtr;
-
-    clientPtr = (client_t*)malloc(sizeof(client_t));
-    if (clientPtr == NULL) {
-        return NULL;
-    }
-
-    clientPtr->randomPtr = random_alloc();
-    if (clientPtr->randomPtr == NULL) {
-        return NULL;
-    }
-
-    clientPtr->id = id;
-    clientPtr->managerPtr = managerPtr;
-    random_seed(clientPtr->randomPtr, id);
-    clientPtr->numOperation = numOperation;
-    clientPtr->numQueryPerTransaction = numQueryPerTransaction;
-    clientPtr->queryRange = queryRange;
-    clientPtr->percentUser = percentUser;
-
-    return clientPtr;
-}
-
-
-/* =============================================================================
- * client_free
- * =============================================================================
- */
-void
-client_free (client_t* clientPtr)
-{
-    free(clientPtr);
-}
-
-
-/* =============================================================================
- * selectAction
- * =============================================================================
- */
-static action_t
-selectAction (long r, long percentUser)
-{
-    action_t action;
-
-    if (r < percentUser) {
-        action = ACTION_MAKE_RESERVATION;
-    } else if (r & 1) {
-        action = ACTION_DELETE_CUSTOMER;
-    } else {
-        action = ACTION_UPDATE_TABLES;
-    }
-
-    return action;
-}
-
-
-/* =============================================================================
- * client_run
- * -- Execute list operations on the database
- * =============================================================================
- */
-void
-client_run (void* argPtr)
-{
-    TM_THREAD_ENTER();
-
-    long myId = thread_getId();
-    client_t* clientPtr = ((client_t**)argPtr)[myId];
-
-    manager_t* managerPtr = clientPtr->managerPtr;
-    random_t*  randomPtr  = clientPtr->randomPtr;
-
-    long numOperation           = clientPtr->numOperation;
-    long numQueryPerTransaction = clientPtr->numQueryPerTransaction;
-    long queryRange             = clientPtr->queryRange;
-    long percentUser            = clientPtr->percentUser;
-
-    long* types  = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
-    long* ids    = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
-    long* ops    = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
-    long* prices = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
-
-    long i;
-
-    for (i = 0; i < numOperation; i++) {
-
-        long r = random_generate(randomPtr) % 100;
-        action_t action = selectAction(r, percentUser);
-
-        switch (action) {
-
-            case ACTION_MAKE_RESERVATION: {
-                long maxPrices[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
-                long maxIds[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
-                long n;
-                long numQuery = random_generate(randomPtr) % numQueryPerTransaction + 1;
-                long customerId = random_generate(randomPtr) % queryRange + 1;
-                for (n = 0; n < numQuery; n++) {
-                    types[n] = random_generate(randomPtr) % NUM_RESERVATION_TYPE;
-                    ids[n] = (random_generate(randomPtr) % queryRange) + 1;
-                }
-                bool_t isFound = FALSE;
-                TM_BEGIN();
-                for (n = 0; n < numQuery; n++) {
-                    long t = types[n];
-                    long id = ids[n];
-                    long price = -1;
-                    switch (t) {
-                        case RESERVATION_CAR:
-                            if (MANAGER_QUERY_CAR(managerPtr, id) >= 0) {
-                                price = MANAGER_QUERY_CAR_PRICE(managerPtr, id);
-                            }
-                            break;
-                        case RESERVATION_FLIGHT:
-                            if (MANAGER_QUERY_FLIGHT(managerPtr, id) >= 0) {
-                                price = MANAGER_QUERY_FLIGHT_PRICE(managerPtr, id);
-                            }
-                            break;
-                        case RESERVATION_ROOM:
-                            if (MANAGER_QUERY_ROOM(managerPtr, id) >= 0) {
-                                price = MANAGER_QUERY_ROOM_PRICE(managerPtr, id);
-                            }
-                            break;
-                        default:
-                            assert(0);
-                    }
-                    if (price > maxPrices[t]) {
-                        maxPrices[t] = price;
-                        maxIds[t] = id;
-                        isFound = TRUE;
-                    }
-                } /* for n */
-                if (isFound) {
-                    MANAGER_ADD_CUSTOMER(managerPtr, customerId);
-                }
-                if (maxIds[RESERVATION_CAR] > 0) {
-                    MANAGER_RESERVE_CAR(managerPtr,
-                                        customerId, maxIds[RESERVATION_CAR]);
-                }
-                if (maxIds[RESERVATION_FLIGHT] > 0) {
-                    MANAGER_RESERVE_FLIGHT(managerPtr,
-                                           customerId, maxIds[RESERVATION_FLIGHT]);
-                }
-                if (maxIds[RESERVATION_ROOM] > 0) {
-                    MANAGER_RESERVE_ROOM(managerPtr,
-                                         customerId, maxIds[RESERVATION_ROOM]);
-                }
-                TM_END();
-                break;
-            }
-
-            case ACTION_DELETE_CUSTOMER: {
-                long customerId = random_generate(randomPtr) % queryRange + 1;
-                TM_BEGIN();
-                long bill = MANAGER_QUERY_CUSTOMER_BILL(managerPtr, customerId);
-                if (bill >= 0) {
-                    MANAGER_DELETE_CUSTOMER(managerPtr, customerId);
-                }
-                TM_END();
-                break;
-            }
-
-            case ACTION_UPDATE_TABLES: {
-                long numUpdate = random_generate(randomPtr) % numQueryPerTransaction + 1;
-                long n;
-                for (n = 0; n < numUpdate; n++) {
-                    types[n] = random_generate(randomPtr) % NUM_RESERVATION_TYPE;
-                    ids[n] = (random_generate(randomPtr) % queryRange) + 1;
-                    ops[n] = random_generate(randomPtr) % 2;
-                    if (ops[n]) {
-                        prices[n] = ((random_generate(randomPtr) % 5) * 10) + 50;
-                    }
-                }
-                TM_BEGIN();
-                for (n = 0; n < numUpdate; n++) {
-                    long t = types[n];
-                    long id = ids[n];
-                    long doAdd = ops[n];
-                    if (doAdd) {
-                        long newPrice = prices[n];
-                        switch (t) {
-                            case RESERVATION_CAR:
-                                MANAGER_ADD_CAR(managerPtr, id, 100, newPrice);
-                                break;
-                            case RESERVATION_FLIGHT:
-                                MANAGER_ADD_FLIGHT(managerPtr, id, 100, newPrice);
-                                break;
-                            case RESERVATION_ROOM:
-                                MANAGER_ADD_ROOM(managerPtr, id, 100, newPrice);
-                                break;
-                            default:
-                                assert(0);
-                        }
-                    } else { /* do delete */
-                        switch (t) {
-                            case RESERVATION_CAR:
-                                MANAGER_DELETE_CAR(managerPtr, id, 100);
-                                break;
-                            case RESERVATION_FLIGHT:
-                                MANAGER_DELETE_FLIGHT(managerPtr, id);
-                                break;
-                            case RESERVATION_ROOM:
-                                MANAGER_DELETE_ROOM(managerPtr, id, 100);
-                                break;
-                            default:
-                                assert(0);
-                        }
-                    }
-                }
-                TM_END();
-                break;
-            }
-
-            default:
-                assert(0);
-
-        } /* switch (action) */
-
-    } /* for i */
-
-    TM_THREAD_EXIT();
-}
-
-
-/* =============================================================================
- *
- * End of client.c
- *
- * =============================================================================
- */
-
-
-
-
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/client.cpp stamp-g/vacation/client.cpp
--- stamp-0.9.10/vacation/client.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-g/vacation/client.cpp	2017-03-21 18:35:49.000000000 +0000
@@ -0,0 +1,422 @@
+/* =============================================================================
+ *
+ * client.c
+ *
+ * =============================================================================
+ *
+ * Copyright (C) Stanford University, 2006.  All Rights Reserved.
+ * Author: Chi Cao Minh
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+
+#include "Galois/Galois.h"
+#include "Galois/Bag.h"
+
+#include <assert.h>
+#include "action.h"
+#include "client.h"
+#include "manager.h"
+#include "reservation.h"
+#include "thread.h"
+#include "types.h"
+
+
+/* =============================================================================
+ * client_alloc
+ * -- Returns NULL on failure
+ * =============================================================================
+ */
+client_t*
+client_alloc (long id,
+              manager_t* managerPtr,
+              long numOperation,
+              long numQueryPerTransaction,
+              long queryRange,
+              long percentUser)
+{
+    client_t* clientPtr;
+
+    clientPtr = (client_t*)malloc(sizeof(client_t));
+    if (clientPtr == NULL) {
+        return NULL;
+    }
+
+    clientPtr->randomPtr = random_alloc();
+    if (clientPtr->randomPtr == NULL) {
+        return NULL;
+    }
+
+    clientPtr->id = id;
+    clientPtr->managerPtr = managerPtr;
+    random_seed(clientPtr->randomPtr, id);
+    clientPtr->numOperation = numOperation;
+    clientPtr->numQueryPerTransaction = numQueryPerTransaction;
+    clientPtr->queryRange = queryRange;
+    clientPtr->percentUser = percentUser;
+
+    return clientPtr;
+}
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void
+client_init() {
+    Galois::preAlloc(2*15 * Galois::getActiveThreads() + Galois::Runtime::MM::numPageAllocTotal() * 4);
+}
+
+}
+
+/* =============================================================================
+ * client_free
+ * =============================================================================
+ */
+void
+client_free (client_t* clientPtr)
+{
+    random_free(clientPtr->randomPtr);
+    free(clientPtr);
+}
+
+
+/* =============================================================================
+ * selectAction
+ * =============================================================================
+ */
+static action_t
+selectAction (long r, long percentUser)
+{
+    action_t action;
+
+    if (r < percentUser) {
+        action = ACTION_MAKE_RESERVATION;
+    } else if (r & 1) {
+        action = ACTION_DELETE_CUSTOMER;
+    } else {
+        action = ACTION_UPDATE_TABLES;
+    }
+
+    return action;
+}
+
+template<int MaxQuery>
+struct GenericAction {
+  static const int max_query = MaxQuery;
+  long types[MaxQuery];
+  long ids[MaxQuery];
+  long ops[MaxQuery];
+  long prices[MaxQuery];
+  long numQuery;
+  long customerId;
+  action_t action;
+};
+
+typedef GenericAction<4> Action;
+
+struct Fn1 {
+    Galois::InsertBag<Action>& actions;
+    client_t** clientPtrs;
+
+    void operator()(unsigned tid, unsigned total) {
+        client_t* clientPtr = clientPtrs[tid];
+        random_t*  randomPtr  = clientPtr->randomPtr;
+
+        long numOperation           = clientPtr->numOperation;
+        long numQueryPerTransaction = clientPtr->numQueryPerTransaction;
+        long queryRange             = clientPtr->queryRange;
+        long percentUser            = clientPtr->percentUser;
+
+        for (long i = 0; i < numOperation; i++) {
+            Action& a = actions.emplace();
+            a.action = selectAction(random_generate(randomPtr) % 100, percentUser);
+            switch (a.action) {
+                case ACTION_MAKE_RESERVATION: {
+                    a.numQuery = random_generate(randomPtr) % numQueryPerTransaction + 1;
+                    a.customerId = random_generate(randomPtr) % queryRange + 1;
+                    for (long n = 0; n < a.numQuery; n++) {
+                        a.types[n] = random_generate(randomPtr) % NUM_RESERVATION_TYPE;
+                        a.ids[n] = (random_generate(randomPtr) % queryRange) + 1;
+                    }
+                    break;
+                }
+                case ACTION_DELETE_CUSTOMER: {
+                    a.customerId = random_generate(randomPtr) % queryRange + 1;
+                    break;
+                }
+                case ACTION_UPDATE_TABLES: {
+                    a.numQuery = random_generate(randomPtr) % numQueryPerTransaction + 1;
+                    for (long n = 0; n < a.numQuery; n++) {
+                        a.types[n] = random_generate(randomPtr) % NUM_RESERVATION_TYPE;
+                        a.ids[n] = (random_generate(randomPtr) % queryRange) + 1;
+                        a.ops[n] = random_generate(randomPtr) % 2;
+                        if (a.ops[n]) {
+                            a.prices[n] = ((random_generate(randomPtr) % 5) * 10) + 50;
+                        }
+                    }
+                    break;
+                }
+                default: abort();
+            }
+        }
+    }
+};
+
+
+struct Fn3 {
+    typedef int tt_does_not_need_push;
+
+    client_t** clientPtrs;
+
+    void operator()(const Action& a, Galois::UserContext<Action>& ctx) {
+        client_t* clientPtr = clientPtrs[Galois::Runtime::LL::getTID()];
+        manager_t* managerPtr = clientPtr->managerPtr;
+
+        switch (a.action) {
+            case ACTION_MAKE_RESERVATION: {
+                long maxPrices[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
+                long maxIds[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
+                long n;
+                bool_t isFound = FALSE;
+                TM_BEGIN();
+#ifndef HTM
+                managerPtr->customerTablePtr->acquire((void*)a.customerId);
+                for (n = 0; n < a.numQuery; n++) {
+                    long t = a.types[n];
+                    long id = a.ids[n];
+                    long price = -1;
+                    switch (t) {
+                        case RESERVATION_CAR: managerPtr->carTablePtr->acquire((void*)id); break;
+                        case RESERVATION_FLIGHT: managerPtr->flightTablePtr->acquire((void*)id); break;
+                        case RESERVATION_ROOM: managerPtr->roomTablePtr->acquire((void*)id); break;
+                        default: assert(0);
+                    }
+                } /* for n */
+                //Galois::Runtime::checkWrite(Galois::MethodFlag::WRITE, false);
+#endif
+                for (n = 0; n < a.numQuery; n++) {
+                    long t = a.types[n];
+                    long id = a.ids[n];
+                    long price = -1;
+                    switch (t) {
+                        case RESERVATION_CAR:
+                            if (MANAGER_QUERY_CAR(managerPtr, id) >= 0) {
+                                price = MANAGER_QUERY_CAR_PRICE(managerPtr, id);
+                            }
+                            break;
+                        case RESERVATION_FLIGHT:
+                            if (MANAGER_QUERY_FLIGHT(managerPtr, id) >= 0) {
+                                price = MANAGER_QUERY_FLIGHT_PRICE(managerPtr, id);
+                            }
+                            break;
+                        case RESERVATION_ROOM:
+                            if (MANAGER_QUERY_ROOM(managerPtr, id) >= 0) {
+                                price = MANAGER_QUERY_ROOM_PRICE(managerPtr, id);
+                            }
+                            break;
+                        default:
+                            assert(0);
+                    }
+                    if (price > maxPrices[t]) {
+                        maxPrices[t] = price;
+                        maxIds[t] = id;
+                        isFound = TRUE;
+                    }
+                } /* for n */
+                if (isFound) {
+                    MANAGER_ADD_CUSTOMER(managerPtr, a.customerId);
+                }
+                if (maxIds[RESERVATION_CAR] > 0) {
+                    MANAGER_RESERVE_CAR(managerPtr,
+                                        a.customerId, maxIds[RESERVATION_CAR]);
+                }
+                if (maxIds[RESERVATION_FLIGHT] > 0) {
+                    MANAGER_RESERVE_FLIGHT(managerPtr,
+                                           a.customerId, maxIds[RESERVATION_FLIGHT]);
+                }
+                if (maxIds[RESERVATION_ROOM] > 0) {
+                    MANAGER_RESERVE_ROOM(managerPtr,
+                                         a.customerId, maxIds[RESERVATION_ROOM]);
+                }
+                TM_END();
+                break;
+            }
+
+            case ACTION_DELETE_CUSTOMER: {
+                TM_BEGIN();
+#ifndef HTM
+                managerPtr->customerTablePtr->acquire((void*)a.customerId);
+#endif
+                long bill = MANAGER_QUERY_CUSTOMER_BILL(managerPtr, a.customerId);
+                if (bill >= 0) {
+                    manager_deleteCustomer_acquire(managerPtr, a.customerId);
+                    //Galois::Runtime::checkWrite(Galois::MethodFlag::WRITE, false);
+                    MANAGER_DELETE_CUSTOMER(managerPtr, a.customerId);
+                }
+                TM_END();
+                break;
+            }
+
+            case ACTION_UPDATE_TABLES: {
+                long n;
+                TM_BEGIN();
+#ifndef HTM
+                for (n = 0; n < a.numQuery; n++) {
+                    long t = a.types[n];
+                    long id = a.ids[n];
+                    long newPrice = a.prices[n];
+                    switch (t) {
+                        case RESERVATION_CAR: managerPtr->carTablePtr->acquire((void*)id); break;
+                        case RESERVATION_FLIGHT: managerPtr->flightTablePtr->acquire((void*)id); break;
+                        case RESERVATION_ROOM: managerPtr->roomTablePtr->acquire((void*)id); break;
+                        default: assert(0);
+                    }
+                }
+#endif
+                //Galois::Runtime::checkWrite(Galois::MethodFlag::WRITE, false);
+                for (n = 0; n < a.numQuery; n++) {
+                    long t = a.types[n];
+                    long id = a.ids[n];
+                    long doAdd = a.ops[n];
+                    if (doAdd) {
+                        long newPrice = a.prices[n];
+                        switch (t) {
+                            case RESERVATION_CAR:
+                                MANAGER_ADD_CAR(managerPtr, id, 100, newPrice);
+                                break;
+                            case RESERVATION_FLIGHT:
+                                MANAGER_ADD_FLIGHT(managerPtr, id, 100, newPrice);
+                                break;
+                            case RESERVATION_ROOM:
+                                MANAGER_ADD_ROOM(managerPtr, id, 100, newPrice);
+                                break;
+                            default:
+                                assert(0);
+                        }
+                    } else { /* do delete */
+                        switch (t) {
+                            case RESERVATION_CAR:
+                                MANAGER_DELETE_CAR(managerPtr, id, 100);
+                                break;
+                            case RESERVATION_FLIGHT:
+                                MANAGER_DELETE_FLIGHT(managerPtr, id);
+                                break;
+                            case RESERVATION_ROOM:
+                                MANAGER_DELETE_ROOM(managerPtr, id, 100);
+                                break;
+                            default:
+                                assert(0);
+                        }
+                    }
+                }
+                TM_END();
+                break;
+            }
+
+            default:
+                assert(0);
+        } /* switch (action) */
+    }
+};
+
+
+
+/* =============================================================================
+ * client_run
+ * -- Execute list operations on the database
+ * =============================================================================
+ */
+void
+client_run (void* argPtr)
+{
+    Galois::reportPageAlloc("MeminfoPre");
+    TM_THREAD_ENTER();
+
+    //long myId = thread_getId();
+    //client_t* clientPtr = ((client_t**)argPtr)[myId];
+    client_t** clientPtrs = (client_t**)argPtr;
+
+
+    long numQueryPerTransaction = clientPtrs[0]->numQueryPerTransaction;
+    if (Action::max_query < numQueryPerTransaction)
+        abort();
+
+    long i;
+
+    Galois::InsertBag<Action> actions;
+    Fn1 fn1 = { actions, clientPtrs };
+    Galois::on_each(fn1);
+
+    Fn3 fn3 = { clientPtrs };
+    Galois::for_each(actions.begin(), actions.end(), fn3, Galois::wl<Galois::WorkList::dChunkedFIFO<32>>());
+    TM_THREAD_EXIT();
+    Galois::reportPageAlloc("MeminfoPost");
+}
+
+
+/* =============================================================================
+ *
+ * End of client.c
+ *
+ * =============================================================================
+ */
+
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/client.h stamp-g/vacation/client.h
--- stamp-0.9.10/vacation/client.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/vacation/client.h	2017-03-20 15:19:41.000000000 +0000
@@ -78,6 +78,10 @@
 #include "random.h"
 #include "tm.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct client {
     long id;
     manager_t* managerPtr;
@@ -119,6 +123,9 @@
 void
 client_run (void* argPtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* CLIENT_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/customer.c stamp-g/vacation/customer.c
--- stamp-0.9.10/vacation/customer.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/vacation/customer.c	2017-03-20 15:19:41.000000000 +0000
@@ -106,9 +106,9 @@
 
     customerPtr->id = id;
 
-    XTM_LOCKABLE_VALUE(customerPtr->reservationInfoListPtr) = TMLIST_ALLOC(&compareReservationInfo);
-    XTM_LOCKABLE_INIT(customerPtr->reservationInfoListPtr);
-    assert(XTM_LOCKABLE_VALUE(customerPtr->reservationInfoListPtr) != NULL);
+    //customerPtr->reservationInfoListPtr = LIST_ALLOC(&compareReservationInfo);
+    customerPtr->reservationInfoListPtr = LIST_ALLOC(NULL);
+    assert(customerPtr->reservationInfoListPtr != NULL);
 
     return customerPtr;
 }
@@ -124,9 +124,8 @@
 
     customerPtr->id = id;
 
-    XTM_LOCKABLE_VALUE(customerPtr->reservationInfoListPtr) = list_alloc(&compareReservationInfo);
-    XTM_LOCKABLE_INIT(customerPtr->reservationInfoListPtr);
-    assert(XTM_LOCKABLE_VALUE(customerPtr->reservationInfoListPtr) != NULL);
+    customerPtr->reservationInfoListPtr = list_alloc(&compareReservationInfo);
+    assert(customerPtr->reservationInfoListPtr != NULL);
 
     return customerPtr;
 }
@@ -153,7 +152,7 @@
 {
     list_t* reservationInfoListPtr =
         (list_t*)TM_SHARED_READ(customerPtr->reservationInfoListPtr);
-    TMLIST_FREE(reservationInfoListPtr);
+    LIST_FREE(reservationInfoListPtr);
     TM_FREE(customerPtr);
 }
 
@@ -176,7 +175,7 @@
     list_t* reservationInfoListPtr =
         (list_t*)TM_SHARED_READ(customerPtr->reservationInfoListPtr);
 
-    return TMLIST_INSERT(reservationInfoListPtr, (void*)reservationInfoPtr);
+    return LIST_INSERT(reservationInfoListPtr, (void*)reservationInfoPtr);
 }
 
 
@@ -190,6 +189,7 @@
                                 customer_t* customerPtr,
                                 reservation_type_t type, long id)
 {
+#if 0
     reservation_info_t findReservationInfo;
 
     findReservationInfo.type = type;
@@ -200,21 +200,23 @@
         (list_t*)TM_SHARED_READ(customerPtr->reservationInfoListPtr);
 
     reservation_info_t* reservationInfoPtr =
-        (reservation_info_t*)TMLIST_FIND(reservationInfoListPtr,
+        (reservation_info_t*)LIST_FIND(reservationInfoListPtr,
                                          &findReservationInfo);
 
     if (reservationInfoPtr == NULL) {
         return FALSE;
     }
 
-    bool_t status = TMLIST_REMOVE(reservationInfoListPtr,
+    bool_t status = LIST_REMOVE(reservationInfoListPtr,
                                   (void*)&findReservationInfo);
     if (status == FALSE) {
         TM_RESTART();
+        abort();
     }
 
     RESERVATION_INFO_FREE(reservationInfoPtr);
-
+#endif
+    abort();
     return TRUE;
 }
 
@@ -232,10 +234,10 @@
     list_t* reservationInfoListPtr =
         (list_t*)TM_SHARED_READ(customerPtr->reservationInfoListPtr);
 
-    TMLIST_ITER_RESET(&it, reservationInfoListPtr);
-    while (TMLIST_ITER_HASNEXT(&it, reservationInfoListPtr)) {
+    LIST_ITER_RESET(&it, reservationInfoListPtr);
+    while (LIST_ITER_HASNEXT(&it, reservationInfoListPtr)) {
         reservation_info_t* reservationInfoPtr =
-            (reservation_info_t*)TMLIST_ITER_NEXT(&it, reservationInfoListPtr);
+            (reservation_info_t*)LIST_ITER_NEXT(&it, reservationInfoListPtr);
         bill += reservationInfoPtr->price;
     }
 
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/customer.h stamp-g/vacation/customer.h
--- stamp-0.9.10/vacation/customer.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/vacation/customer.h	2017-03-20 15:19:41.000000000 +0000
@@ -79,9 +79,13 @@
 #include "tm.h"
 #include "types.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct customer {
     long id;
-    XTM_DECL_LOCKABLE(list_t*, reservationInfoListPtr);
+    list_t* reservationInfoListPtr;
 } customer_t;
 
 
@@ -173,6 +177,10 @@
     customer_free(TM_ARG  cust)
 
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* CUSTOMER_H */
 
 
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/manager.c stamp-g/vacation/manager.c
--- stamp-0.9.10/vacation/manager.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/vacation/manager.c	2017-03-20 15:19:41.000000000 +0000
@@ -74,7 +74,7 @@
 #include <stdlib.h>
 #include "customer.h"
 #include "map.h"
-#include "pair.h"
+//#include "pair.h"
 #include "manager.h"
 #include "reservation.h"
 #include "tm.h"
@@ -184,7 +184,7 @@
 {
     reservation_t* reservationPtr;
 
-    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
+    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
     if (reservationPtr == NULL) {
         /* Create new reservation */
         if (num < 1 || price < 0) {
@@ -192,14 +192,14 @@
         }
         reservationPtr = RESERVATION_ALLOC(id, num, price);
         assert(reservationPtr != NULL);
-        TMMAP_INSERT(tablePtr, id, reservationPtr);
+        MAP_INSERT(tablePtr, id, reservationPtr);
     } else {
         /* Update existing reservation */
         if (!RESERVATION_ADD_TO_TOTAL(reservationPtr, num)) {
             return FALSE;
         }
         if ((long)TM_SHARED_READ(reservationPtr->numTotal) == 0) {
-            bool_t status = TMMAP_REMOVE(tablePtr, id);
+            bool_t status = MAP_REMOVE(tablePtr, id);
             if (status == FALSE) {
                 TM_RESTART();
             }
@@ -234,7 +234,7 @@
         if (!reservation_addToTotal_seq(reservationPtr, num)) {
             return FALSE;
         }
-        if (XTM_LOCKABLE_VALUE(reservationPtr->numTotal) == 0) {
+        if (reservationPtr->numTotal == 0) {
             status = MAP_REMOVE(tablePtr, id);
             assert(status);
         } else {
@@ -360,7 +360,7 @@
 {
     reservation_t* reservationPtr;
 
-    reservationPtr = (reservation_t*)TMMAP_FIND(managerPtr->flightTablePtr, flightId);
+    reservationPtr = (reservation_t*)MAP_FIND(managerPtr->flightTablePtr, flightId);
     if (reservationPtr == NULL) {
         return FALSE;
     }
@@ -389,13 +389,13 @@
     customer_t* customerPtr;
     bool_t status;
 
-    if (TMMAP_CONTAINS(managerPtr->customerTablePtr, customerId)) {
+    if (MAP_CONTAINS(managerPtr->customerTablePtr, customerId)) {
         return FALSE;
     }
 
     customerPtr = CUSTOMER_ALLOC(customerId);
     assert(customerPtr != NULL);
-    status = TMMAP_INSERT(managerPtr->customerTablePtr, customerId, customerPtr);
+    status = MAP_INSERT(managerPtr->customerTablePtr, customerId, customerPtr);
     if (status == FALSE) {
         TM_RESTART();
     }
@@ -439,7 +439,7 @@
     list_iter_t it;
     bool_t status;
 
-    customerPtr = (customer_t*)TMMAP_FIND(managerPtr->customerTablePtr, customerId);
+    customerPtr = (customer_t*)MAP_FIND(managerPtr->customerTablePtr, customerId);
     if (customerPtr == NULL) {
         return FALSE;
     }
@@ -449,15 +449,15 @@
     reservationTables[RESERVATION_FLIGHT] = managerPtr->flightTablePtr;
 
     /* Cancel this customer's reservations */
-    reservationInfoListPtr = XTM_LOCKABLE_VALUE(customerPtr->reservationInfoListPtr);
-    TMLIST_ITER_RESET(&it, reservationInfoListPtr);
-    while (TMLIST_ITER_HASNEXT(&it, reservationInfoListPtr)) {
+    reservationInfoListPtr = customerPtr->reservationInfoListPtr;
+    LIST_ITER_RESET(&it, reservationInfoListPtr);
+    while (LIST_ITER_HASNEXT(&it, reservationInfoListPtr)) {
         reservation_info_t* reservationInfoPtr;
         reservation_t* reservationPtr;
         reservationInfoPtr =
-            (reservation_info_t*)TMLIST_ITER_NEXT(&it, reservationInfoListPtr);
+            (reservation_info_t*)LIST_ITER_NEXT(&it, reservationInfoListPtr);
         reservationPtr =
-            (reservation_t*)TMMAP_FIND(reservationTables[reservationInfoPtr->type],
+            (reservation_t*)MAP_FIND(reservationTables[reservationInfoPtr->type],
                                      reservationInfoPtr->id);
         if (reservationPtr == NULL) {
             TM_RESTART();
@@ -469,7 +469,7 @@
         RESERVATION_INFO_FREE(reservationInfoPtr);
     }
 
-    status = TMMAP_REMOVE(managerPtr->customerTablePtr, customerId);
+    status = MAP_REMOVE(managerPtr->customerTablePtr, customerId);
     if (status == FALSE) {
         TM_RESTART();
     }
@@ -478,6 +478,38 @@
     return TRUE;
 }
 
+void
+manager_deleteCustomer_acquire (TM_ARGDECL  manager_t* managerPtr, long customerId)
+{
+    customer_t* customerPtr;
+    MAP_T* reservationTables[NUM_RESERVATION_TYPE];
+    list_t* reservationInfoListPtr;
+    list_iter_t it;
+    bool_t status;
+
+    TMMAP_ACQUIRE(managerPtr->customerTablePtr, (void*) customerId);
+
+    customerPtr = (customer_t*)MAP_FIND(managerPtr->customerTablePtr, customerId);
+    if (customerPtr == NULL) {
+        return;
+    }
+
+    reservationTables[RESERVATION_CAR] = managerPtr->carTablePtr;
+    reservationTables[RESERVATION_ROOM] = managerPtr->roomTablePtr;
+    reservationTables[RESERVATION_FLIGHT] = managerPtr->flightTablePtr;
+
+    /* Cancel this customer's reservations */
+    reservationInfoListPtr = customerPtr->reservationInfoListPtr;
+    LIST_ITER_RESET(&it, reservationInfoListPtr);
+    while (LIST_ITER_HASNEXT(&it, reservationInfoListPtr)) {
+        reservation_info_t* reservationInfoPtr;
+        reservation_t* reservationPtr;
+        reservationInfoPtr =
+            (reservation_info_t*)LIST_ITER_NEXT(&it, reservationInfoListPtr);
+        TMMAP_ACQUIRE(reservationTables[reservationInfoPtr->type], (void*) reservationInfoPtr->id);
+    }
+}
+
 
 /* =============================================================================
  * QUERY INTERFACE
@@ -496,7 +528,7 @@
     long numFree = -1;
     reservation_t* reservationPtr;
 
-    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
+    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
     if (reservationPtr != NULL) {
         numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
     }
@@ -516,7 +548,7 @@
     long price = -1;
     reservation_t* reservationPtr;
 
-    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
+    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
     if (reservationPtr != NULL) {
         price = (long)TM_SHARED_READ(reservationPtr->price);
     }
@@ -615,7 +647,7 @@
     long bill = -1;
     customer_t* customerPtr;
 
-    customerPtr = (customer_t*)TMMAP_FIND(managerPtr->customerTablePtr, customerId);
+    customerPtr = (customer_t*)MAP_FIND(managerPtr->customerTablePtr, customerId);
 
     if (customerPtr != NULL) {
         bill = CUSTOMER_GET_BILL(customerPtr);
@@ -645,12 +677,12 @@
     customer_t* customerPtr;
     reservation_t* reservationPtr;
 
-    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
+    customerPtr = (customer_t*)MAP_FIND(customerTablePtr, customerId);
     if (customerPtr == NULL) {
         return FALSE;
     }
 
-    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
+    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
     if (reservationPtr == NULL) {
         return FALSE;
     }
@@ -746,12 +778,12 @@
     customer_t* customerPtr;
     reservation_t* reservationPtr;
 
-    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
+    customerPtr = (customer_t*)MAP_FIND(customerTablePtr, customerId);
     if (customerPtr == NULL) {
         return FALSE;
     }
 
-    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
+    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
     if (reservationPtr == NULL) {
         return FALSE;
     }
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/manager.h stamp-g/vacation/manager.h
--- stamp-0.9.10/vacation/manager.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/vacation/manager.h	2017-03-20 15:19:41.000000000 +0000
@@ -78,6 +78,10 @@
 #include "tm.h"
 #include "types.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct manager {
     MAP_T* carTablePtr;
     MAP_T* roomTablePtr;
@@ -213,6 +217,8 @@
 bool_t
 manager_deleteCustomer (TM_ARGDECL  manager_t* managerPtr, long customerId);
 
+void
+manager_deleteCustomer_acquire (TM_ARGDECL  manager_t* managerPtr, long customerId);
 
 /* =============================================================================
  * QUERY INTERFACE
@@ -406,6 +412,10 @@
     manager_cancelFlight(TM_ARG  mgr, cust, id)
 
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* MANAGER_H */
 
 
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/operation.h stamp-g/vacation/operation.h
--- stamp-0.9.10/vacation/operation.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/vacation/operation.h	2017-03-20 15:19:41.000000000 +0000
@@ -72,6 +72,10 @@
 #ifndef OPERATION_H
 #define OPERATION_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef enum operation {
     OPERATION_MAKE_RESERVATION = 0L,
     OPERATION_DELETE_CUSTOMER  = 1L,
@@ -79,6 +83,10 @@
     NUM_OPERATION
 } operation_t;
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* OPERATION_H */
 
 
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/reservation.c stamp-g/vacation/reservation.c
--- stamp-0.9.10/vacation/reservation.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/vacation/reservation.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,520 +0,0 @@
-/* =============================================================================
- *
- * reservation.c
- * -- Representation of car, flight, and hotel relations
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <stdlib.h>
-#include "memory.h"
-#include "reservation.h"
-#include "tm.h"
-#include "types.h"
-
-/* =============================================================================
- * DECLARATION OF TM_CALLABLE FUNCTIONS
- * =============================================================================
- */
-
-TM_CALLABLE
-static void
-checkReservation (TM_ARGDECL  reservation_t* reservationPtr);
-
-/* =============================================================================
- * reservation_info_alloc
- * -- Returns NULL on failure
- * =============================================================================
- */
-reservation_info_t*
-reservation_info_alloc (TM_ARGDECL  reservation_type_t type, long id, long price)
-{
-    reservation_info_t* reservationInfoPtr;
-
-    reservationInfoPtr = (reservation_info_t*)TM_MALLOC(sizeof(reservation_info_t));
-    if (reservationInfoPtr != NULL) {
-        reservationInfoPtr->type = type;
-        reservationInfoPtr->id = id;
-        reservationInfoPtr->price = price;
-    }
-
-    return reservationInfoPtr;
-}
-
-
-/* =============================================================================
- * reservation_info_free
- * =============================================================================
- */
-void
-reservation_info_free (TM_ARGDECL  reservation_info_t* reservationInfoPtr)
-{
-    TM_FREE(reservationInfoPtr);
-}
-
-
-/* =============================================================================
- * reservation_info_compare
- * -- Returns -1 if A < B, 0 if A = B, 1 if A > B
- * =============================================================================
- */
-long
-reservation_info_compare (reservation_info_t* aPtr, reservation_info_t* bPtr)
-{
-    long typeDiff;
-
-    typeDiff = aPtr->type - bPtr->type;
-
-    return ((typeDiff != 0) ? (typeDiff) : (aPtr->id - bPtr->id));
-}
-
-
-/* =============================================================================
- * checkReservation
- * -- Check if consistent
- * =============================================================================
- */
-static void
-checkReservation (TM_ARGDECL  reservation_t* reservationPtr)
-{
-    long numUsed = (long)TM_SHARED_READ(reservationPtr->numUsed);
-    if (numUsed < 0) {
-        TM_RESTART();
-    }
-    
-    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
-    if (numFree < 0) {
-        TM_RESTART();
-    }
-
-    long numTotal = (long)TM_SHARED_READ(reservationPtr->numTotal);
-    if (numTotal < 0) {
-        TM_RESTART();
-    }
-
-    if ((numUsed + numFree) != numTotal) {
-        TM_RESTART();
-    }
-
-    long price = (long)TM_SHARED_READ(reservationPtr->price);
-    if (price < 0) {
-        TM_RESTART();
-    }
-}
-
-#define CHECK_RESERVATION(reservation) \
-    checkReservation(TM_ARG  reservation)
-
-
-static void
-checkReservation_seq (reservation_t* reservationPtr)
-{
-    assert(XTM_LOCKABLE_VALUE(reservationPtr->numUsed) >= 0);
-    assert(XTM_LOCKABLE_VALUE(reservationPtr->numFree) >= 0);
-    assert(XTM_LOCKABLE_VALUE(reservationPtr->numTotal) >= 0);
-    assert((XTM_LOCKABLE_VALUE(reservationPtr->numUsed) + XTM_LOCKABLE_VALUE(reservationPtr->numFree)) ==
-           XTM_LOCKABLE_VALUE(reservationPtr->numTotal));
-    assert(XTM_LOCKABLE_VALUE(reservationPtr->price) >= 0);
-}
-
-
-/* =============================================================================
- * reservation_alloc
- * -- Returns NULL on failure
- * =============================================================================
- */
-reservation_t*
-reservation_alloc (TM_ARGDECL  long id, long numTotal, long price)
-{
-    reservation_t* reservationPtr;
-
-    reservationPtr = (reservation_t*)TM_MALLOC(sizeof(reservation_t));
-    if (reservationPtr != NULL) {
-        reservationPtr->id = id;
-        XTM_LOCKABLE_VALUE(reservationPtr->numUsed) = 0;
-        XTM_LOCKABLE_INIT(reservationPtr->numUsed);
-        XTM_LOCKABLE_VALUE(reservationPtr->numFree) = numTotal;
-        XTM_LOCKABLE_INIT(reservationPtr->numFree);
-        XTM_LOCKABLE_VALUE(reservationPtr->numTotal) = numTotal;
-        XTM_LOCKABLE_INIT(reservationPtr->numTotal);
-        XTM_LOCKABLE_VALUE(reservationPtr->price) = price;
-        XTM_LOCKABLE_INIT(reservationPtr->price);
-        CHECK_RESERVATION(reservationPtr);
-    }
-
-    return reservationPtr;
-}
-
-
-reservation_t*
-reservation_alloc_seq (long id, long numTotal, long price)
-{
-    reservation_t* reservationPtr;
-
-    reservationPtr = (reservation_t*)malloc(sizeof(reservation_t));
-    if (reservationPtr != NULL) {
-        reservationPtr->id = id;
-        XTM_LOCKABLE_VALUE(reservationPtr->numUsed) = 0;
-        XTM_LOCKABLE_INIT(reservationPtr->numUsed);
-        XTM_LOCKABLE_VALUE(reservationPtr->numFree) = numTotal;
-        XTM_LOCKABLE_INIT(reservationPtr->numFree);
-        XTM_LOCKABLE_VALUE(reservationPtr->numTotal) = numTotal;
-        XTM_LOCKABLE_INIT(reservationPtr->numTotal);
-        XTM_LOCKABLE_VALUE(reservationPtr->price) = price;
-        XTM_LOCKABLE_INIT(reservationPtr->price);
-        checkReservation_seq(reservationPtr);
-    }
-
-    return reservationPtr;
-}
-
-
-/* =============================================================================
- * reservation_addToTotal
- * -- Adds if 'num' > 0, removes if 'num' < 0;
- * -- Returns TRUE on success, else FALSE
- * =============================================================================
- */
-bool_t
-reservation_addToTotal (TM_ARGDECL  reservation_t* reservationPtr, long num)
-{
-    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
-
-    if (numFree + num < 0) {
-        return FALSE;
-    }
-
-    TM_SHARED_WRITE(reservationPtr->numFree, (numFree + num));
-    TM_SHARED_WRITE(reservationPtr->numTotal,
-                    ((long)TM_SHARED_READ(reservationPtr->numTotal) + num));
-
-    CHECK_RESERVATION(reservationPtr);
-
-    return TRUE;
-}
-
-
-bool_t
-reservation_addToTotal_seq (reservation_t* reservationPtr, long num)
-{
-    if (XTM_LOCKABLE_VALUE(reservationPtr->numFree) + num < 0) {
-        return FALSE;
-    }
-
-    XTM_LOCKABLE_VALUE(reservationPtr->numFree) += num;
-    XTM_LOCKABLE_VALUE(reservationPtr->numTotal) += num;
-
-    checkReservation_seq(reservationPtr);
-
-    return TRUE;
-}
-
-
-/* =============================================================================
- * reservation_make
- * -- Returns TRUE on success, else FALSE
- * =============================================================================
- */
-bool_t
-reservation_make (TM_ARGDECL  reservation_t* reservationPtr)
-{
-    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
-
-    if (numFree < 1) {
-        return FALSE;
-    }
-    TM_SHARED_WRITE(reservationPtr->numUsed,
-                    ((long)TM_SHARED_READ(reservationPtr->numUsed) + 1));
-    TM_SHARED_WRITE(reservationPtr->numFree, (numFree - 1));
-
-    CHECK_RESERVATION(reservationPtr);
-
-    return TRUE;
-}
-
-
-bool_t
-reservation_make_seq (reservation_t* reservationPtr)
-{
-    if (XTM_LOCKABLE_VALUE(reservationPtr->numFree) < 1) {
-        return FALSE;
-    }
-
-    XTM_LOCKABLE_VALUE(reservationPtr->numUsed)++;
-    XTM_LOCKABLE_VALUE(reservationPtr->numFree)--;
-
-    checkReservation_seq(reservationPtr);
-
-    return TRUE;
-}
-
-
-/* =============================================================================
- * reservation_cancel
- * -- Returns TRUE on success, else FALSE
- * =============================================================================
- */
-bool_t
-reservation_cancel (TM_ARGDECL  reservation_t* reservationPtr)
-{
-    long numUsed = (long)TM_SHARED_READ(reservationPtr->numUsed);
-
-    if (numUsed < 1) {
-        return FALSE;
-    }
-
-    TM_SHARED_WRITE(reservationPtr->numUsed, (numUsed - 1));
-    TM_SHARED_WRITE(reservationPtr->numFree,
-                    ((long)TM_SHARED_READ(reservationPtr->numFree) + 1));
-
-    CHECK_RESERVATION(reservationPtr);
-
-    return TRUE;
-}
-
-
-bool_t
-reservation_cancel_seq (reservation_t* reservationPtr)
-{
-    if (XTM_LOCKABLE_VALUE(reservationPtr->numUsed) < 1) {
-        return FALSE;
-    }
-
-    XTM_LOCKABLE_VALUE(reservationPtr->numUsed)--;
-    XTM_LOCKABLE_VALUE(reservationPtr->numFree)++;
-
-    checkReservation_seq(reservationPtr);
-
-    return TRUE;
-}
-
-
-/* =============================================================================
- * reservation_updatePrice
- * -- Failure if 'price' < 0
- * -- Returns TRUE on success, else FALSE
- * =============================================================================
- */
-bool_t
-reservation_updatePrice (TM_ARGDECL  reservation_t* reservationPtr, long newPrice)
-{
-    if (newPrice < 0) {
-        return FALSE;
-    }
-
-    TM_SHARED_WRITE(reservationPtr->price, newPrice);
-
-    CHECK_RESERVATION(reservationPtr);
-
-    return TRUE;
-}
-
-
-bool_t
-reservation_updatePrice_seq (reservation_t* reservationPtr, long newPrice)
-{
-    if (newPrice < 0) {
-        return FALSE;
-    }
-
-    XTM_LOCKABLE_VALUE(reservationPtr->price) = newPrice;
-
-    checkReservation_seq(reservationPtr);
-
-    return TRUE;
-}
-
-
-/* =============================================================================
- * reservation_compare
- * -- Returns -1 if A < B, 0 if A = B, 1 if A > B
- * =============================================================================
- */
-long
-reservation_compare (reservation_t* aPtr, reservation_t* bPtr)
-{
-    return (aPtr->id - bPtr->id);
-}
-
-
-/* =============================================================================
- * reservation_hash
- * =============================================================================
- */
-ulong_t
-reservation_hash (reservation_t* reservationPtr)
-{
-    /* Separate tables for cars, flights, etc, so no need to use 'type' */
-    return (ulong_t)reservationPtr->id;
-}
-
-
-/* =============================================================================
- * reservation_free
- * =============================================================================
- */
-void
-reservation_free (TM_ARGDECL  reservation_t* reservationPtr)
-{
-    TM_FREE(reservationPtr);
-}
-
-
-/* =============================================================================
- * TEST_RESERVATION
- * =============================================================================
- */
-#ifdef TEST_RESERVATION
-
-
-#include <assert.h>
-#include <stdio.h>
-
-
-int
-main ()
-{
-    reservation_info_t* reservationInfo1Ptr;
-    reservation_info_t* reservationInfo2Ptr;
-    reservation_info_t* reservationInfo3Ptr;
-
-    reservation_t* reservation1Ptr;
-    reservation_t* reservation2Ptr;
-    reservation_t* reservation3Ptr;
-
-    assert(memory_init(1, 4, 2));
-
-    puts("Starting...");
-
-    reservationInfo1Ptr = reservation_info_alloc(0, 0, 0);
-    reservationInfo2Ptr = reservation_info_alloc(0, 0, 1);
-    reservationInfo3Ptr = reservation_info_alloc(2, 0, 1);
-
-    /* Test compare */
-    assert(reservation_info_compare(reservationInfo1Ptr, reservationInfo2Ptr) == 0);
-    assert(reservation_info_compare(reservationInfo1Ptr, reservationInfo3Ptr) > 0);
-    assert(reservation_info_compare(reservationInfo2Ptr, reservationInfo3Ptr) > 0);
-
-    reservation1Ptr = reservation_alloc(0, 0, 0);
-    reservation2Ptr = reservation_alloc(0, 0, 1);
-    reservation3Ptr = reservation_alloc(2, 0, 1);
-
-    /* Test compare */
-    assert(reservation_compare(reservation1Ptr, reservation2Ptr) == 0);
-    assert(reservation_compare(reservation1Ptr, reservation3Ptr) != 0);
-    assert(reservation_compare(reservation2Ptr, reservation3Ptr) != 0);
-
-    /* Cannot reserve if total is 0 */
-    assert(!reservation_make(reservation1Ptr));
-
-    /* Cannot cancel if used is 0 */
-    assert(!reservation_cancel(reservation1Ptr));
-
-    /* Cannot update with negative price */
-    assert(!reservation_updatePrice(reservation1Ptr, -1));
-
-    /* Cannot make negative total */
-    assert(!reservation_addToTotal(reservation1Ptr, -1));
-
-    /* Update total and price */
-    assert(reservation_addToTotal(reservation1Ptr, 1));
-    assert(reservation_updatePrice(reservation1Ptr, 1));
-    assert(reservation1Ptr->numUsed == 0);
-    assert(reservation1Ptr->numFree == 1);
-    assert(reservation1Ptr->numTotal == 1);
-    assert(reservation1Ptr->price == 1);
-    checkReservation(reservation1Ptr);
-
-    /* Make and cancel reservation */
-    assert(reservation_make(reservation1Ptr));
-    assert(reservation_cancel(reservation1Ptr));
-    assert(!reservation_cancel(reservation1Ptr));
-
-    reservation_info_free(reservationInfo1Ptr);
-    reservation_info_free(reservationInfo2Ptr);
-    reservation_info_free(reservationInfo3Ptr);
-
-    reservation_free(reservation1Ptr);
-    reservation_free(reservation2Ptr);
-    reservation_free(reservation3Ptr);
-
-    puts("All tests passed.");
-
-    return 0;
-}
-
-
-#endif /* TEST_RESERVATION */
-
-
-/* =============================================================================
- *
- * End of reservation.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/reservation.cpp stamp-g/vacation/reservation.cpp
--- stamp-0.9.10/vacation/reservation.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-g/vacation/reservation.cpp	2017-03-20 15:19:41.000000000 +0000
@@ -0,0 +1,528 @@
+/* =============================================================================
+ *
+ * reservation.c
+ * -- Representation of car, flight, and hotel relations
+ *
+ * =============================================================================
+ *
+ * Copyright (C) Stanford University, 2006.  All Rights Reserved.
+ * Author: Chi Cao Minh
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+
+#include "Galois/Bag.h"
+#include <assert.h>
+#include <stdlib.h>
+#include "memory.h"
+#include "reservation.h"
+#include "tm.h"
+#include "types.h"
+
+/* =============================================================================
+ * DECLARATION OF TM_CALLABLE FUNCTIONS
+ * =============================================================================
+ */
+
+TM_CALLABLE
+static void
+checkReservation (TM_ARGDECL  reservation_t* reservationPtr);
+
+
+static Galois::InsertBag<reservation_info_t>* infoBag;
+static Galois::InsertBag<reservation_t>* resBag;
+
+void initializeReservationPool() {
+  infoBag = new Galois::InsertBag<reservation_info_t>();
+  resBag = new Galois::InsertBag<reservation_t>();
+}
+
+void freeReservationPool() {
+    delete infoBag;
+    delete resBag;
+}
+
+/* =============================================================================
+ * reservation_info_alloc
+ * -- Returns NULL on failure
+ * =============================================================================
+ */
+reservation_info_t*
+reservation_info_alloc (TM_ARGDECL  reservation_type_t type, long id, long price)
+{
+    reservation_info_t* reservationInfoPtr;
+
+    //reservationInfoPtr = (reservation_info_t*)TM_MALLOC(sizeof(reservation_info_t));
+    reservationInfoPtr = (reservation_info_t*) &infoBag->emplace();
+    if (reservationInfoPtr != NULL) {
+        reservationInfoPtr->type = type;
+        reservationInfoPtr->id = id;
+        reservationInfoPtr->price = price;
+    }
+
+    return reservationInfoPtr;
+}
+
+
+/* =============================================================================
+ * reservation_info_free
+ * =============================================================================
+ */
+void
+reservation_info_free (TM_ARGDECL  reservation_info_t* reservationInfoPtr)
+{
+    //TM_FREE(reservationInfoPtr);
+}
+
+
+/* =============================================================================
+ * reservation_info_compare
+ * -- Returns -1 if A < B, 0 if A = B, 1 if A > B
+ * =============================================================================
+ */
+long
+reservation_info_compare (reservation_info_t* aPtr, reservation_info_t* bPtr)
+{
+    long typeDiff;
+
+    typeDiff = aPtr->type - bPtr->type;
+
+    return ((typeDiff != 0) ? (typeDiff) : (aPtr->id - bPtr->id));
+}
+
+
+/* =============================================================================
+ * checkReservation
+ * -- Check if consistent
+ * =============================================================================
+ */
+static void
+checkReservation (TM_ARGDECL  reservation_t* reservationPtr)
+{
+    long numUsed = (long)TM_SHARED_READ(reservationPtr->numUsed);
+    if (numUsed < 0) {
+        TM_RESTART();
+    }
+    
+    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
+    if (numFree < 0) {
+        TM_RESTART();
+    }
+
+    long numTotal = (long)TM_SHARED_READ(reservationPtr->numTotal);
+    if (numTotal < 0) {
+        TM_RESTART();
+    }
+
+    if ((numUsed + numFree) != numTotal) {
+        TM_RESTART();
+    }
+
+    long price = (long)TM_SHARED_READ(reservationPtr->price);
+    if (price < 0) {
+        TM_RESTART();
+    }
+}
+
+#define CHECK_RESERVATION(reservation) \
+    checkReservation(TM_ARG  reservation)
+
+
+static void
+checkReservation_seq (reservation_t* reservationPtr)
+{
+    assert(reservationPtr->numUsed >= 0);
+    assert(reservationPtr->numFree >= 0);
+    assert(reservationPtr->numTotal >= 0);
+    assert((reservationPtr->numUsed + reservationPtr->numFree) ==
+           (reservationPtr->numTotal));
+    assert(reservationPtr->price >= 0);
+}
+
+
+/* =============================================================================
+ * reservation_alloc
+ * -- Returns NULL on failure
+ * =============================================================================
+ */
+reservation_t*
+reservation_alloc (TM_ARGDECL  long id, long numTotal, long price)
+{
+    reservation_t* reservationPtr;
+
+    //reservationPtr = (reservation_t*)TM_MALLOC(sizeof(reservation_t));
+    reservationPtr = (reservation_t*)&resBag->emplace();
+    if (reservationPtr != NULL) {
+        reservationPtr->id = id;
+        reservationPtr->numUsed = 0;
+        reservationPtr->numFree = numTotal;
+        reservationPtr->numTotal = numTotal;
+        reservationPtr->price = price;
+        CHECK_RESERVATION(reservationPtr);
+    }
+
+    return reservationPtr;
+}
+
+
+reservation_t*
+reservation_alloc_seq (long id, long numTotal, long price)
+{
+    reservation_t* reservationPtr;
+
+    reservationPtr = (reservation_t*)malloc(sizeof(reservation_t));
+    if (reservationPtr != NULL) {
+        reservationPtr->id = id;
+        reservationPtr->numUsed = 0;
+        reservationPtr->numFree = numTotal;
+        reservationPtr->numTotal = numTotal;
+        reservationPtr->price = price;
+        checkReservation_seq(reservationPtr);
+    }
+
+    return reservationPtr;
+}
+
+
+/* =============================================================================
+ * reservation_addToTotal
+ * -- Adds if 'num' > 0, removes if 'num' < 0;
+ * -- Returns TRUE on success, else FALSE
+ * =============================================================================
+ */
+bool_t
+reservation_addToTotal (TM_ARGDECL  reservation_t* reservationPtr, long num)
+{
+    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
+
+    if (numFree + num < 0) {
+        return FALSE;
+    }
+
+    TM_SHARED_WRITE(reservationPtr->numFree, (numFree + num));
+    TM_SHARED_WRITE(reservationPtr->numTotal,
+                    ((long)TM_SHARED_READ(reservationPtr->numTotal) + num));
+
+    CHECK_RESERVATION(reservationPtr);
+
+    return TRUE;
+}
+
+
+bool_t
+reservation_addToTotal_seq (reservation_t* reservationPtr, long num)
+{
+    if (reservationPtr->numFree + num < 0) {
+        return FALSE;
+    }
+
+    reservationPtr->numFree += num;
+    reservationPtr->numTotal += num;
+
+    checkReservation_seq(reservationPtr);
+
+    return TRUE;
+}
+
+
+/* =============================================================================
+ * reservation_make
+ * -- Returns TRUE on success, else FALSE
+ * =============================================================================
+ */
+bool_t
+reservation_make (TM_ARGDECL  reservation_t* reservationPtr)
+{
+    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
+
+    if (numFree < 1) {
+        return FALSE;
+    }
+    TM_SHARED_WRITE(reservationPtr->numUsed,
+                    ((long)TM_SHARED_READ(reservationPtr->numUsed) + 1));
+    TM_SHARED_WRITE(reservationPtr->numFree, (numFree - 1));
+
+    CHECK_RESERVATION(reservationPtr);
+
+    return TRUE;
+}
+
+
+bool_t
+reservation_make_seq (reservation_t* reservationPtr)
+{
+    if (reservationPtr->numFree < 1) {
+        return FALSE;
+    }
+
+    reservationPtr->numUsed++;
+    reservationPtr->numFree--;
+
+    checkReservation_seq(reservationPtr);
+
+    return TRUE;
+}
+
+
+/* =============================================================================
+ * reservation_cancel
+ * -- Returns TRUE on success, else FALSE
+ * =============================================================================
+ */
+bool_t
+reservation_cancel (TM_ARGDECL  reservation_t* reservationPtr)
+{
+    long numUsed = (long)TM_SHARED_READ(reservationPtr->numUsed);
+
+    if (numUsed < 1) {
+        return FALSE;
+    }
+
+    TM_SHARED_WRITE(reservationPtr->numUsed, (numUsed - 1));
+    TM_SHARED_WRITE(reservationPtr->numFree,
+                    ((long)TM_SHARED_READ(reservationPtr->numFree) + 1));
+
+    CHECK_RESERVATION(reservationPtr);
+
+    return TRUE;
+}
+
+
+bool_t
+reservation_cancel_seq (reservation_t* reservationPtr)
+{
+    if (reservationPtr->numUsed < 1) {
+        return FALSE;
+    }
+
+    reservationPtr->numUsed--;
+    reservationPtr->numFree++;
+
+    checkReservation_seq(reservationPtr);
+
+    return TRUE;
+}
+
+
+/* =============================================================================
+ * reservation_updatePrice
+ * -- Failure if 'price' < 0
+ * -- Returns TRUE on success, else FALSE
+ * =============================================================================
+ */
+bool_t
+reservation_updatePrice (TM_ARGDECL  reservation_t* reservationPtr, long newPrice)
+{
+    if (newPrice < 0) {
+        return FALSE;
+    }
+
+    TM_SHARED_WRITE(reservationPtr->price, newPrice);
+
+    CHECK_RESERVATION(reservationPtr);
+
+    return TRUE;
+}
+
+
+bool_t
+reservation_updatePrice_seq (reservation_t* reservationPtr, long newPrice)
+{
+    if (newPrice < 0) {
+        return FALSE;
+    }
+
+    reservationPtr->price = newPrice;
+
+    checkReservation_seq(reservationPtr);
+
+    return TRUE;
+}
+
+
+/* =============================================================================
+ * reservation_compare
+ * -- Returns -1 if A < B, 0 if A = B, 1 if A > B
+ * =============================================================================
+ */
+long
+reservation_compare (reservation_t* aPtr, reservation_t* bPtr)
+{
+    return (aPtr->id - bPtr->id);
+}
+
+
+/* =============================================================================
+ * reservation_hash
+ * =============================================================================
+ */
+ulong_t
+reservation_hash (reservation_t* reservationPtr)
+{
+    /* Separate tables for cars, flights, etc, so no need to use 'type' */
+    return (ulong_t)reservationPtr->id;
+}
+
+
+/* =============================================================================
+ * reservation_free
+ * =============================================================================
+ */
+void
+reservation_free (TM_ARGDECL  reservation_t* reservationPtr)
+{
+    //TM_FREE(reservationPtr);
+}
+
+
+/* =============================================================================
+ * TEST_RESERVATION
+ * =============================================================================
+ */
+#ifdef TEST_RESERVATION
+
+
+#include <assert.h>
+#include <stdio.h>
+
+
+int
+main ()
+{
+    reservation_info_t* reservationInfo1Ptr;
+    reservation_info_t* reservationInfo2Ptr;
+    reservation_info_t* reservationInfo3Ptr;
+
+    reservation_t* reservation1Ptr;
+    reservation_t* reservation2Ptr;
+    reservation_t* reservation3Ptr;
+
+    assert(memory_init(1, 4, 2));
+
+    puts("Starting...");
+
+    reservationInfo1Ptr = reservation_info_alloc(0, 0, 0);
+    reservationInfo2Ptr = reservation_info_alloc(0, 0, 1);
+    reservationInfo3Ptr = reservation_info_alloc(2, 0, 1);
+
+    /* Test compare */
+    assert(reservation_info_compare(reservationInfo1Ptr, reservationInfo2Ptr) == 0);
+    assert(reservation_info_compare(reservationInfo1Ptr, reservationInfo3Ptr) > 0);
+    assert(reservation_info_compare(reservationInfo2Ptr, reservationInfo3Ptr) > 0);
+
+    reservation1Ptr = reservation_alloc(0, 0, 0);
+    reservation2Ptr = reservation_alloc(0, 0, 1);
+    reservation3Ptr = reservation_alloc(2, 0, 1);
+
+    /* Test compare */
+    assert(reservation_compare(reservation1Ptr, reservation2Ptr) == 0);
+    assert(reservation_compare(reservation1Ptr, reservation3Ptr) != 0);
+    assert(reservation_compare(reservation2Ptr, reservation3Ptr) != 0);
+
+    /* Cannot reserve if total is 0 */
+    assert(!reservation_make(reservation1Ptr));
+
+    /* Cannot cancel if used is 0 */
+    assert(!reservation_cancel(reservation1Ptr));
+
+    /* Cannot update with negative price */
+    assert(!reservation_updatePrice(reservation1Ptr, -1));
+
+    /* Cannot make negative total */
+    assert(!reservation_addToTotal(reservation1Ptr, -1));
+
+    /* Update total and price */
+    assert(reservation_addToTotal(reservation1Ptr, 1));
+    assert(reservation_updatePrice(reservation1Ptr, 1));
+    assert(reservation1Ptr->numUsed == 0);
+    assert(reservation1Ptr->numFree == 1);
+    assert(reservation1Ptr->numTotal == 1);
+    assert(reservation1Ptr->price == 1);
+    checkReservation(reservation1Ptr);
+
+    /* Make and cancel reservation */
+    assert(reservation_make(reservation1Ptr));
+    assert(reservation_cancel(reservation1Ptr));
+    assert(!reservation_cancel(reservation1Ptr));
+
+    reservation_info_free(reservationInfo1Ptr);
+    reservation_info_free(reservationInfo2Ptr);
+    reservation_info_free(reservationInfo3Ptr);
+
+    reservation_free(reservation1Ptr);
+    reservation_free(reservation2Ptr);
+    reservation_free(reservation3Ptr);
+
+    puts("All tests passed.");
+
+    return 0;
+}
+
+
+#endif /* TEST_RESERVATION */
+
+
+/* =============================================================================
+ *
+ * End of reservation.c
+ *
+ * =============================================================================
+ */
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/reservation.h stamp-g/vacation/reservation.h
--- stamp-0.9.10/vacation/reservation.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/vacation/reservation.h	2017-03-20 15:19:41.000000000 +0000
@@ -77,6 +77,10 @@
 #include "tm.h"
 #include "types.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef enum reservation_type {
     RESERVATION_CAR,
     RESERVATION_FLIGHT,
@@ -92,12 +96,14 @@
 
 typedef struct reservation {
     long id;
-    XTM_DECL_LOCKABLE(long, numUsed);
-    XTM_DECL_LOCKABLE(long, numFree);
-    XTM_DECL_LOCKABLE(long, numTotal);
-    XTM_DECL_LOCKABLE(long, price);
+    long numUsed;
+    long numFree;
+    long numTotal;
+    long price;
 } reservation_t;
 
+void initializeReservationPool();
+void freeReservationPool();
 
 /* =============================================================================
  * reservation_info_alloc
@@ -234,6 +240,9 @@
 #define RESERVATION_FREE(r) \
     reservation_free(TM_ARG  r)
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* RESERVATION_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/vacation.c stamp-g/vacation/vacation.c
--- stamp-0.9.10/vacation/vacation.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/vacation/vacation.c	2017-03-21 18:37:19.000000000 +0000
@@ -402,6 +402,7 @@
     }
 }
 
+void client_init();
 
 /* =============================================================================
  * main
@@ -422,29 +423,26 @@
     managerPtr = initializeManager();
     assert(managerPtr != NULL);
     clients = initializeClients(managerPtr);
+    initializeReservationPool();
     assert(clients != NULL);
     long numThread = global_params[PARAM_CLIENTS];
     TM_STARTUP(numThread);
     P_MEMORY_STARTUP(numThread);
     thread_startup(numThread);
 
+    client_init();
     /* Run transactions */
     printf("Running clients... ");
     fflush(stdout);
-    TIMER_READ(start);
     GOTO_SIM();
+
     thread_begin_timing();
-#ifdef OTM
-#pragma omp parallel
-    {
-        client_run(clients);
-    }
-#else
-    thread_start(client_run, (void*)clients);
-#endif
+    TIMER_READ(start);
+    client_run(clients);
+    TIMER_READ(stop);
     thread_end_timing();
+
     GOTO_REAL();
-    TIMER_READ(stop);
     puts("done.");
     printf("Time = %0.6lf\n",
            TIMER_DIFF_SECONDS(start, stop));
@@ -456,6 +454,7 @@
     /* Clean up */
     printf("Deallocating memory... ");
     fflush(stdout);
+    freeReservationPool();
     freeClients(clients);
     /*
      * TODO: The contents of the manager's table need to be deallocated.
diff -x .git -x inputs -Naur stamp-0.9.10/yada/CMakeLists.txt stamp-g/yada/CMakeLists.txt
--- stamp-0.9.10/yada/CMakeLists.txt	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/yada/CMakeLists.txt	2017-03-20 15:19:41.000000000 +0000
@@ -8,20 +8,23 @@
 
 set(sources
 	coordinate.c 
-	element.c 
-	mesh.c 
-	region.c 
-	yada.c 
-	${LIB_DIR}/avltree.c 
-	${LIB_DIR}/heap.c 
-	${LIB_DIR}/list.c 
+	element.cpp 
+	mesh.cpp 
+	region.cpp 
+	yada.cpp 
+        #${LIB_DIR}/avltree.c 
+        #${LIB_DIR}/heap.c 
+        #${LIB_DIR}/list.c 
 	${LIB_DIR}/mt19937ar.c 
 	${LIB_DIR}/pair.c 
-	${LIB_DIR}/queue.c 
+        #${LIB_DIR}/queue.c 
 	${LIB_DIR}/random.c 
-	${LIB_DIR}/rbtree.c 
-	${LIB_DIR}/thread.c 
-	${LIB_DIR}/vector.c)
+        #${LIB_DIR}/rbtree.c 
+	${LIB_DIR}/thread.cpp
+        ${LIB_DIR}/map.cpp
+        ${LIB_DIR}/deque.cpp
+        #${LIB_DIR}/vector.c
+        )
 
 app(yada ${sources})
 
diff -x .git -x inputs -Naur stamp-0.9.10/yada/coordinate.h stamp-g/yada/coordinate.h
--- stamp-0.9.10/yada/coordinate.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/yada/coordinate.h	2017-03-20 15:19:41.000000000 +0000
@@ -72,6 +72,9 @@
 #ifndef COORDINATE_H
 #define COORDINATE_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef struct coordinate {
     double x;
@@ -111,6 +114,9 @@
 void
 coordinate_print (coordinate_t* coordinatePtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* COORDINATE_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/yada/element.c stamp-g/yada/element.c
--- stamp-0.9.10/yada/element.c	2017-03-21 18:51:27.000000000 +0000
+++ stamp-g/yada/element.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1020 +0,0 @@
-/* =============================================================================
- *
- * element.c
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <float.h>
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include "coordinate.h"
-#include "element.h"
-#include "pair.h"
-#include "tm.h"
-#include "types.h"
-
-
-struct element {
-    coordinate_t coordinates[3];
-    long numCoordinate;
-    coordinate_t circumCenter;
-    double circumRadius;
-    double minAngle;
-    edge_t edges[3];
-    long numEdge;
-    coordinate_t midpoints[3]; /* midpoint of each edge */
-    double radii[3];           /* half of edge length */
-    edge_t* encroachedEdgePtr; /* opposite obtuse angle */
-    bool_t isSkinny;
-    list_t* neighborListPtr;
-    XTM_DECL_LOCKABLE(bool_t, isGarbage);
-    XTM_DECL_LOCKABLE(bool_t, isReferenced);
-};
-
-
-#if defined(TEST_ELEMENT) || defined(TEST_MESH)
-double global_angleConstraint = 20.0;
-#else
-extern double global_angleConstraint;
-#endif
-
-
-/* =============================================================================
- * minimizeCoordinates
- * -- put smallest coordinate in position 0
- * =============================================================================
- */
-static void
-minimizeCoordinates (element_t* elementPtr)
-{
-    long i;
-    coordinate_t* coordinates = elementPtr->coordinates;
-    long numCoordinate = elementPtr->numCoordinate;
-    long minPosition = 0;
-
-    for (i = 1; i < numCoordinate; i++) {
-        if (coordinate_compare(&coordinates[i], &coordinates[minPosition]) < 0) {
-            minPosition = i;
-        }
-    }
-
-    while (minPosition != 0) {
-        coordinate_t tmp = coordinates[0];
-        long j;
-        for (j = 0; j < (numCoordinate - 1); j++) {
-            coordinates[j] = coordinates[j+1];
-        }
-        coordinates[numCoordinate-1] = tmp;
-        minPosition--;
-    }
-}
-
-
-/* =============================================================================
- * checkAngles
- * -- Sets isSkinny to TRUE if the angle constraint is not met
- * =============================================================================
- */
-static void
-checkAngles (element_t* elementPtr)
-{
-    long numCoordinate = elementPtr->numCoordinate;
-    double angleConstraint = global_angleConstraint;
-    double minAngle = 180.0;
-
-    assert(numCoordinate == 2 || numCoordinate == 3);
-    XTM_LOCKABLE_VALUE(elementPtr->isReferenced) = FALSE;
-    elementPtr->isSkinny = FALSE;
-    elementPtr->encroachedEdgePtr = NULL;
-
-    if (numCoordinate == 3) {
-        long i;
-        coordinate_t* coordinates = elementPtr->coordinates;
-        for (i = 0; i < 3; i++) {
-            double angle = coordinate_angle(&coordinates[i],
-                                            &coordinates[(i + 1) % 3],
-                                            &coordinates[(i + 2) % 3]);
-            assert(angle > 0.0);
-            assert(angle < 180.0);
-            if (angle > 90.0) {
-                elementPtr->encroachedEdgePtr = &elementPtr->edges[(i + 1) % 3];
-            }
-            if (angle < angleConstraint) {
-                elementPtr->isSkinny = TRUE;
-            }
-            if (angle < minAngle) {
-                minAngle = angle;
-            }
-        }
-        assert(minAngle < 180.0);
-    }
-
-    elementPtr->minAngle = minAngle;
-}
-
-
-/* =============================================================================
- * calculateCircumCenter
- *
- * Given three points A(ax,ay), B(bx,by), C(cx,cy), circumcenter R(rx,ry):
- *
- *              |                         |
- *              | by - ay   (||b - a||)^2 |
- *              |                         |
- *              | cy - ay   (||c - a||)^2 |
- *              |                         |
- *   rx = ax - -----------------------------
- *                   |                   |
- *                   | bx - ax   by - ay |
- *               2 * |                   |
- *                   | cx - ax   cy - ay |
- *                   |                   |
- *
- *              |                         |
- *              | bx - ax   (||b - a||)^2 |
- *              |                         |
- *              | cx - ax   (||c - a||)^2 |
- *              |                         |
- *   ry = ay + -----------------------------
- *                   |                   |
- *                   | bx - ax   by - ay |
- *               2 * |                   |
- *                   | cx - ax   cy - ay |
- *                   |                   |
- *
- * =============================================================================
- */
-static void
-calculateCircumCircle (element_t* elementPtr)
-{
-    long numCoordinate = elementPtr->numCoordinate;
-    coordinate_t* coordinates = elementPtr->coordinates;
-    coordinate_t* circumCenterPtr = &elementPtr->circumCenter;
-
-    assert(numCoordinate == 2 || numCoordinate == 3);
-
-    if (numCoordinate == 2) {
-        circumCenterPtr->x = (coordinates[0].x + coordinates[1].x) / 2.0;
-        circumCenterPtr->y = (coordinates[0].y + coordinates[1].y) / 2.0;
-    } else {
-        double ax = coordinates[0].x;
-        double ay = coordinates[0].y;
-        double bx = coordinates[1].x;
-        double by = coordinates[1].y;
-        double cx = coordinates[2].x;
-        double cy = coordinates[2].y;
-        double bxDelta = bx - ax;
-        double byDelta = by - ay;
-        double cxDelta = cx - ax;
-        double cyDelta = cy - ay;
-        double bDistance2 = (bxDelta * bxDelta) + (byDelta * byDelta);
-        double cDistance2 = (cxDelta * cxDelta) + (cyDelta * cyDelta);
-        double xNumerator = (byDelta * cDistance2) - (cyDelta * bDistance2);
-        double yNumerator = (bxDelta * cDistance2) - (cxDelta * bDistance2);
-        double denominator = 2 * ((bxDelta * cyDelta) - (cxDelta * byDelta));
-        double rx = ax - (xNumerator / denominator);
-        double ry = ay + (yNumerator / denominator);
-        assert(fabs(denominator) > DBL_MIN); /* make sure not colinear */
-        circumCenterPtr->x = rx;
-        circumCenterPtr->y = ry;
-    }
-
-    elementPtr->circumRadius = coordinate_distance(circumCenterPtr,
-                                                   &coordinates[0]);
-}
-
-
-/* =============================================================================
- * setEdge
- *
-  * Note: Makes pairPtr sorted; i.e., coordinate_compare(first, second) < 0
- * =============================================================================
- */
-static void
-setEdge (element_t* elementPtr, long i)
-{
-    long numCoordinate = elementPtr->numCoordinate;
-    coordinate_t* coordinates = elementPtr->coordinates;
-
-    coordinate_t* firstPtr = &coordinates[i];
-    coordinate_t* secondPtr = &coordinates[(i + 1) % numCoordinate];
-
-    edge_t* edgePtr = &elementPtr->edges[i];
-
-    long cmp = coordinate_compare(firstPtr, secondPtr);
-    assert(cmp != 0);
-    if (cmp < 0) {
-        edgePtr->firstPtr  = (void*)firstPtr;
-        edgePtr->secondPtr = (void*)secondPtr;
-    } else {
-        edgePtr->firstPtr  = (void*)secondPtr;
-        edgePtr->secondPtr = (void*)firstPtr;
-    }
-
-    coordinate_t* midpointPtr = &elementPtr->midpoints[i];
-    midpointPtr->x = (firstPtr->x + secondPtr->x) / 2.0;
-    midpointPtr->y = (firstPtr->y + secondPtr->y) / 2.0;
-
-    elementPtr->radii[i] = coordinate_distance(firstPtr, midpointPtr);
-}
-
-
-/* =============================================================================
- * initEdges
- * =============================================================================
- */
-static void
-initEdges (element_t* elementPtr, coordinate_t* coordinates, long numCoordinate)
-{
-    long numEdge = ((numCoordinate * (numCoordinate - 1)) / 2);
-
-    elementPtr->numEdge = numEdge;
-
-    long e;
-    for (e = 0; e < numEdge; e++) {
-        setEdge(elementPtr, e);
-    }
-}
-
-
-/* =============================================================================
- * element_compare
- * =============================================================================
- */
-long
-element_compare (element_t* aElementPtr, element_t* bElementPtr)
-{
-    long aNumCoordinate = aElementPtr->numCoordinate;
-    long bNumCoordinate = bElementPtr->numCoordinate;
-    coordinate_t* aCoordinates = aElementPtr->coordinates;
-    coordinate_t* bCoordinates = bElementPtr->coordinates;
-
-    if (aNumCoordinate < bNumCoordinate) {
-        return -1;
-    } else if (aNumCoordinate > bNumCoordinate) {
-        return 1;
-    }
-
-    long i;
-    for (i = 0; i < aNumCoordinate; i++) {
-        long compareCoordinate =
-            coordinate_compare(&aCoordinates[i], &bCoordinates[i]);
-        if (compareCoordinate != 0) {
-            return compareCoordinate;
-        }
-    }
-
-    return 0;
-}
-
-
-/* =============================================================================
- * element_listCompare
- *
- * For use in list_t
- * =============================================================================
- */
-long
-element_listCompare (const void* aPtr, const void* bPtr)
-{
-    element_t* aElementPtr = (element_t*)aPtr;
-    element_t* bElementPtr = (element_t*)bPtr;
-
-    return element_compare(aElementPtr, bElementPtr);
-}
-
-
-/* =============================================================================
- * element_mapCompare
- *
- * For use in MAP_T
- * =============================================================================
- */
-long
-element_mapCompare (const pair_t* aPtr, const pair_t* bPtr)
-{
-    element_t* aElementPtr = (element_t*)(aPtr->firstPtr);
-    element_t* bElementPtr = (element_t*)(bPtr->firstPtr);
-
-    return element_compare(aElementPtr, bElementPtr);
-}
-
-
-/* =============================================================================
- * element_alloc
- *
- * Contains a copy of input arg 'coordinates'
- * =============================================================================
- */
-element_t*
-element_alloc (coordinate_t* coordinates, long numCoordinate)
-{
-    element_t* elementPtr;
-
-    elementPtr = (element_t*)malloc(sizeof(element_t));
-    if (elementPtr) {
-        long i;
-        for (i = 0; i < numCoordinate; i++) {
-            elementPtr->coordinates[i] = coordinates[i];
-        }
-        elementPtr->numCoordinate = numCoordinate;
-        minimizeCoordinates(elementPtr);
-        checkAngles(elementPtr);
-        calculateCircumCircle(elementPtr);
-        initEdges(elementPtr, coordinates, numCoordinate);
-        elementPtr->neighborListPtr = list_alloc(element_listCompare);
-        assert(elementPtr->neighborListPtr);
-        XTM_LOCKABLE_VALUE(elementPtr->isGarbage) = FALSE;
-        XTM_LOCKABLE_INIT(elementPtr->isGarbage);
-        XTM_LOCKABLE_VALUE(elementPtr->isReferenced) = FALSE;
-        XTM_LOCKABLE_INIT(elementPtr->isReferenced);
-    }
-
-    return elementPtr;
-}
-
-
-/* =============================================================================
- * Pelement_alloc
- *
- * Contains a copy of input arg 'coordinates'
- * =============================================================================
- */
-element_t*
-Pelement_alloc (coordinate_t* coordinates, long numCoordinate)
-{
-    element_t* elementPtr;
-
-    elementPtr = (element_t*)P_MALLOC(sizeof(element_t));
-    if (elementPtr) {
-        long i;
-        for (i = 0; i < numCoordinate; i++) {
-            elementPtr->coordinates[i] = coordinates[i];
-        }
-        elementPtr->numCoordinate = numCoordinate;
-        minimizeCoordinates(elementPtr);
-        checkAngles(elementPtr);
-        calculateCircumCircle(elementPtr);
-        initEdges(elementPtr, coordinates, numCoordinate);
-        elementPtr->neighborListPtr = PLIST_ALLOC(element_listCompare);
-        assert(elementPtr->neighborListPtr);
-        XTM_LOCKABLE_VALUE(elementPtr->isGarbage) = FALSE;
-        XTM_LOCKABLE_INIT(elementPtr->isGarbage);
-        XTM_LOCKABLE_VALUE(elementPtr->isReferenced) = FALSE;
-        XTM_LOCKABLE_INIT(elementPtr->isReferenced);
-    }
-
-    return elementPtr;
-}
-
-
-/* =============================================================================
- * TMelement_alloc
- *
- * Contains a copy of input arg 'coordinates'
- * =============================================================================
- */
-element_t*
-TMelement_alloc (TM_ARGDECL  coordinate_t* coordinates, long numCoordinate)
-{
-    element_t* elementPtr;
-
-    elementPtr = (element_t*)TM_MALLOC(sizeof(element_t));
-    if (elementPtr) {
-        long i;
-        for (i = 0; i < numCoordinate; i++) {
-            elementPtr->coordinates[i] = coordinates[i];
-        }
-        elementPtr->numCoordinate = numCoordinate;
-        minimizeCoordinates(elementPtr);
-        checkAngles(elementPtr);
-        calculateCircumCircle(elementPtr);
-        initEdges(elementPtr, coordinates, numCoordinate);
-        elementPtr->neighborListPtr = TMLIST_ALLOC(element_listCompare);
-        assert(elementPtr->neighborListPtr);
-        XTM_LOCKABLE_VALUE(elementPtr->isGarbage) = FALSE;
-        XTM_LOCKABLE_INIT(elementPtr->isGarbage);
-        XTM_LOCKABLE_VALUE(elementPtr->isReferenced) = FALSE;
-        XTM_LOCKABLE_INIT(elementPtr->isReferenced);
-    }
-
-    return elementPtr;
-}
-
-
-/* =============================================================================
- * element_free
- * =============================================================================
- */
-void
-element_free (element_t* elementPtr)
-{
-    list_free(elementPtr->neighborListPtr);
-    free(elementPtr);
-}
-
-
-/* =============================================================================
- * Pelement_free
- * =============================================================================
- */
-void
-Pelement_free (element_t* elementPtr)
-{
-    PLIST_FREE(elementPtr->neighborListPtr);
-    P_FREE(elementPtr);
-}
-
-
-/* =============================================================================
- * TMelement_free
- * =============================================================================
- */
-void
-TMelement_free (TM_ARGDECL  element_t* elementPtr)
-{
-    TMLIST_FREE(elementPtr->neighborListPtr);
-    TM_FREE(elementPtr);
-}
-
-
-/* =============================================================================
- * element_getNumEdge
- * =============================================================================
- */
-long
-element_getNumEdge (element_t* elementPtr)
-{
-    return elementPtr->numEdge;
-}
-
-
-/* =============================================================================
- * element_getEdge
- *
- * Returned edgePtr is sorted; i.e., coordinate_compare(first, second) < 0
- * =============================================================================
- */
-edge_t*
-element_getEdge (element_t* elementPtr, long i)
-{
-    if (i < 0 || i > elementPtr->numEdge) {
-        return NULL;
-    }
-
-    return &elementPtr->edges[i];
-}
-
-
-/* =============================================================================
- * element_compareEdge
- * =============================================================================
- */
-static long
-compareEdge (edge_t* aEdgePtr, edge_t* bEdgePtr)
-{
-    long diffFirst = coordinate_compare((coordinate_t*)aEdgePtr->firstPtr,
-                                        (coordinate_t*)bEdgePtr->firstPtr);
-
-    return ((diffFirst != 0) ?
-            (diffFirst) :
-            (coordinate_compare((coordinate_t*)aEdgePtr->secondPtr,
-                                (coordinate_t*)bEdgePtr->secondPtr)));
-}
-
-
-/* ============================================================================
- * element_listCompareEdge
- *
- * For use in list_t
- * ============================================================================
- */
-long
-element_listCompareEdge (const void* aPtr, const void* bPtr)
-{
-    edge_t* aEdgePtr = (edge_t*)(aPtr);
-    edge_t* bEdgePtr = (edge_t*)(bPtr);
-
-    return compareEdge(aEdgePtr, bEdgePtr);
-}
-
-
-/* =============================================================================
- * element_mapCompareEdge
- *
-  * For use in MAP_T
- * =============================================================================
- */
-long
-element_mapCompareEdge (const pair_t* aPtr, const pair_t* bPtr)
-{
-    edge_t* aEdgePtr = (edge_t*)(aPtr->firstPtr);
-    edge_t* bEdgePtr = (edge_t*)(bPtr->firstPtr);
-
-    return compareEdge(aEdgePtr, bEdgePtr);
-}
-
-
-/* =============================================================================
- * element_heapCompare
- *
- * For use in heap_t. Consider using minAngle instead of "do not care".
- * =============================================================================
- */
-long
-element_heapCompare (const void* aPtr, const void* bPtr)
-{
-    element_t* aElementPtr = (element_t*)aPtr;
-    element_t* bElementPtr = (element_t*)bPtr;
-
-    if (aElementPtr->encroachedEdgePtr) {
-        if (bElementPtr->encroachedEdgePtr) {
-            return 0; /* do not care */
-        } else {
-            return 1;
-        }
-    }
-
-    if (bElementPtr->encroachedEdgePtr) {
-        return -1;
-    }
-
-    return 0; /* do not care */
-}
-
-
-/* =============================================================================
- * element_isInCircumCircle
- * =============================================================================
- */
-bool_t
-element_isInCircumCircle (element_t* elementPtr, coordinate_t* coordinatePtr)
-{
-    double distance = coordinate_distance(coordinatePtr,
-                                          &elementPtr->circumCenter);
-
-    return ((distance <= elementPtr->circumRadius) ? TRUE : FALSE);
-}
-
-
-/* =============================================================================
- * isEncroached
- * =============================================================================
- */
-static bool_t
-isEncroached (element_t* elementPtr)
-{
-    return ((elementPtr->encroachedEdgePtr != NULL) ? TRUE : FALSE);
-}
-
-
-/* =============================================================================
- * element_setEncroached
- * =============================================================================
- */
-void
-element_clearEncroached (element_t* elementPtr)
-{
-    elementPtr->encroachedEdgePtr = NULL;
-}
-
-
-/* =============================================================================
- * element_getEncroachedPtr
- * =============================================================================
- */
-edge_t*
-element_getEncroachedPtr (element_t* elementPtr)
-{
-    return elementPtr->encroachedEdgePtr;
-}
-
-
-/* =============================================================================
- * element_isSkinny
- * =============================================================================
- */
-bool_t
-element_isSkinny (element_t* elementPtr)
-{
-    return ((elementPtr->isSkinny) ? TRUE : FALSE);
-}
-
-
-/* =============================================================================
- * element_isBad
- * -- Does it need to be refined?
- * =============================================================================
- */
-bool_t
-element_isBad (element_t* elementPtr)
-{
-    return ((isEncroached(elementPtr) || element_isSkinny(elementPtr)) ?
-            TRUE : FALSE);
-}
-
-
-/* =============================================================================
- * element_isReferenced
- * -- Held by another data structure?
- * =============================================================================
- */
-bool_t
-element_isReferenced (element_t* elementPtr)
-{
-    return XTM_LOCKABLE_VALUE(elementPtr->isReferenced);
-}
-
-
-/* =============================================================================
- * TMelement_isReferenced
- * -- Held by another data structure?
- * =============================================================================
- */
-bool_t
-TMelement_isReferenced (TM_ARGDECL  element_t* elementPtr)
-{
-    return (bool_t)TM_SHARED_READ(elementPtr->isReferenced);
-}
-
-
-/* =============================================================================
- * element_setIsReferenced
- * =============================================================================
- */
-void
-element_setIsReferenced (element_t* elementPtr, bool_t status)
-{
-    XTM_LOCKABLE_VALUE(elementPtr->isReferenced) = status;
-}
-
-
-/* =============================================================================
- * TMelement_setIsReferenced
- * =============================================================================
- */
-void
-TMelement_setIsReferenced (TM_ARGDECL  element_t* elementPtr, bool_t status)
-{
-    TM_SHARED_WRITE(elementPtr->isReferenced, status);
-}
-
-
-/* =============================================================================
- * element_isGarbage
- * -- Can we deallocate?
- * =============================================================================
- */
-bool_t
-element_isGarbage (element_t* elementPtr)
-{
-    return XTM_LOCKABLE_VALUE(elementPtr->isGarbage);
-}
-
-
-/* =============================================================================
- * TMelement_isGarbage
- * -- Can we deallocate?
- * =============================================================================
- */
-bool_t
-TMelement_isGarbage (TM_ARGDECL  element_t* elementPtr)
-{
-    return (bool_t)TM_SHARED_READ(elementPtr->isGarbage);
-}
-
-
-/* =============================================================================
- * element_setIsGarbage
- * =============================================================================
- */
-void
-element_setIsGarbage (element_t* elementPtr, bool_t status)
-{
-    XTM_LOCKABLE_VALUE(elementPtr->isGarbage) = status;
-}
-
-
-/* =============================================================================
- * TMelement_setIsGarbage
- * =============================================================================
- */
-void
-TMelement_setIsGarbage (TM_ARGDECL  element_t* elementPtr, bool_t status)
-{
-    TM_SHARED_WRITE(elementPtr->isGarbage, status);
-}
-
-
-/* =============================================================================
- * element_addNeighbor
- * =============================================================================
- */
-void
-element_addNeighbor (element_t* elementPtr, element_t* neighborPtr)
-{
-    list_insert(elementPtr->neighborListPtr, (void*)neighborPtr);
-    assert(list_getSize(elementPtr->neighborListPtr) <= elementPtr->numEdge);
-}
-
-
-/* =============================================================================
- * TMelement_addNeighbor
- * =============================================================================
- */
-void
-TMelement_addNeighbor (TM_ARGDECL  element_t* elementPtr, element_t* neighborPtr)
-{
-    TMLIST_INSERT(elementPtr->neighborListPtr, (void*)neighborPtr);
-}
-
-
-/* =============================================================================
- * element_getNeighborListPtr
- * =============================================================================
- */
-list_t*
-element_getNeighborListPtr (element_t* elementPtr)
-{
-    return elementPtr->neighborListPtr;
-}
-
-
-/* =============================================================================
- * element_getCommonEdge
- *
- * Returns pointer to aElementPtr's shared edge
- * =============================================================================
- */
-edge_t*
-element_getCommonEdge (element_t* aElementPtr, element_t* bElementPtr)
-{
-    edge_t* aEdges = aElementPtr->edges;
-    edge_t* bEdges = bElementPtr->edges;
-    long aNumEdge = aElementPtr->numEdge;
-    long bNumEdge = bElementPtr->numEdge;
-    long a;
-    long b;
-
-    for (a = 0; a < aNumEdge; a++) {
-        edge_t* aEdgePtr = &aEdges[a];
-        for (b = 0; b < bNumEdge; b++) {
-            edge_t* bEdgePtr = &bEdges[b];
-            if (compareEdge(aEdgePtr, bEdgePtr) == 0) {
-                return aEdgePtr;
-            }
-        }
-    }
-
-    return NULL;
-}
-
-
-/* =============================================================================
- * element_getNewPoint
- * -- Either the element is encroached or is skinny, so get the new point to add
- * =============================================================================
- */
-coordinate_t
-element_getNewPoint (element_t* elementPtr)
-{
-    edge_t* encroachedEdgePtr = elementPtr->encroachedEdgePtr;
-
-    if (encroachedEdgePtr) {
-        long e;
-        long numEdge = elementPtr->numEdge;
-        edge_t* edges = elementPtr->edges;
-        for (e = 0; e < numEdge; e++) {
-            if (compareEdge(encroachedEdgePtr, &edges[e]) == 0) {
-                return elementPtr->midpoints[e];
-            }
-        }
-        assert(0);
-    }
-
-    return elementPtr->circumCenter;
-}
-
-
-/* =============================================================================
- * element_checkAngles
- *
- * Return FALSE if minimum angle constraint not met
- * =============================================================================
- */
-bool_t
-element_checkAngles (element_t* elementPtr)
-{
-    long numCoordinate = elementPtr->numCoordinate;
-    double angleConstraint = global_angleConstraint;
-
-    if (numCoordinate == 3) {
-        long i;
-        coordinate_t* coordinates = elementPtr->coordinates;
-        for (i = 0; i < 3; i++) {
-            double angle = coordinate_angle(&coordinates[i],
-                                            &coordinates[(i + 1) % 3],
-                                            &coordinates[(i + 2) % 3]);
-            if (angle < angleConstraint) {
-                return FALSE;
-            }
-        }
-    }
-
-    return TRUE;
-}
-
-
-/* =============================================================================
- * element_print
- * =============================================================================
- */
-void
-element_print (element_t* elementPtr)
-{
-    long c;
-    long numCoordinate = elementPtr->numCoordinate;
-    coordinate_t* coordinates = elementPtr->coordinates;
-
-    for (c = 0; c < numCoordinate; c++) {
-        coordinate_print(&coordinates[c]);
-        printf(" ");
-    }
-}
-
-
-/* =============================================================================
- * element_printEdge
- * =============================================================================
- */
-void
-element_printEdge (edge_t* edgePtr)
-{
-    coordinate_print((coordinate_t*)edgePtr->firstPtr);
-    printf(" -> ");
-    coordinate_print((coordinate_t*)edgePtr->secondPtr);
-}
-
-
-/* =============================================================================
- * element_printAngles
- * =============================================================================
- */
-void
-element_printAngles (element_t* elementPtr)
-{
-    long numCoordinate = elementPtr->numCoordinate;
-
-    if (numCoordinate == 3) {
-        long i;
-        coordinate_t* coordinates = elementPtr->coordinates;
-        for (i = 0; i < 3; i++) {
-            double angle = coordinate_angle(&coordinates[i],
-                                            &coordinates[(i + 1) % 3],
-                                            &coordinates[(i + 2) % 3]);
-            printf("%0.3lf ", angle);
-        }
-    }
-
-}
-
-
-#ifdef TEST_ELEMENT
-/* =============================================================================
- * TEST_ELEMENT
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <stdio.h>
-
-
-static void
-printElement (element_t* elementPtr)
-{
-    long numCoordinate = elementPtr->numCoordinate;
-    coordinate_t* coordinates = elementPtr->coordinates;
-    long i;
-
-    printf("%li: ", elementPtr->numCoordinate);
-    for (i = 0; i < numCoordinate; i++) {
-        printf("(%.2lf, %.2lf) ", coordinates[i].x, coordinates[i].y);
-    }
-    printf("| (%.2lf, %.2lf)",
-            elementPtr->circumCenter.x, elementPtr->circumCenter.y);
-    printf(" | isBad = %li", (long)element_isBad(elementPtr));
-    puts("");
-}
-
-
-int
-main (int argc, char* argv[])
-{
-    element_t* elementPtr;
-    coordinate_t coordinates[4];
-
-    coordinates[0].x = 1;
-    coordinates[0].y = 0;
-    coordinates[1].x = 0;
-    coordinates[1].y = 1;
-    coordinates[2].x = 0;
-    coordinates[2].y = 0;
-    coordinates[3].x = -2;
-    coordinates[3].y = -2;
-
-    elementPtr = element_alloc(coordinates, 3);
-    assert(elementPtr);
-    printElement(elementPtr);
-    element_free(elementPtr);
-
-    elementPtr = element_alloc(coordinates, 2);
-    assert(elementPtr);
-    printElement(elementPtr);
-    element_free(elementPtr);
-
-    elementPtr = element_alloc(coordinates+1, 3);
-    assert(elementPtr);
-    printElement(elementPtr);
-    element_free(elementPtr);
-
-    return 0;
-}
-
-
-#endif /* TEST_ELEMENT */
-
-
-/* =============================================================================
- *
- * End of element.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/yada/element.cpp stamp-g/yada/element.cpp
--- stamp-0.9.10/yada/element.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-g/yada/element.cpp	2017-03-21 19:12:58.000000000 +0000
@@ -0,0 +1,1019 @@
+/* =============================================================================
+ *
+ * element.c
+ *
+ * =============================================================================
+ *
+ * Copyright (C) Stanford University, 2006.  All Rights Reserved.
+ * Author: Chi Cao Minh
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+
+
+#include <assert.h>
+#include <float.h>
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "coordinate.h"
+#include "element.h"
+#include "pair.h"
+#include "tm.h"
+#include "types.h"
+
+#include <iostream>
+
+#if defined(TEST_ELEMENT) || defined(TEST_MESH)
+double global_angleConstraint = 20.0;
+#else
+extern double global_angleConstraint;
+#endif
+
+
+/* =============================================================================
+ * minimizeCoordinates
+ * -- put smallest coordinate in position 0
+ * =============================================================================
+ */
+static void
+minimizeCoordinates (element_t* elementPtr)
+{
+    long i;
+    coordinate_t* coordinates = elementPtr->coordinates;
+    long numCoordinate = elementPtr->numCoordinate;
+    long minPosition = 0;
+
+    for (i = 1; i < numCoordinate; i++) {
+        if (coordinate_compare(&coordinates[i], &coordinates[minPosition]) < 0) {
+            minPosition = i;
+        }
+    }
+
+    while (minPosition != 0) {
+        coordinate_t tmp = coordinates[0];
+        long j;
+        for (j = 0; j < (numCoordinate - 1); j++) {
+            coordinates[j] = coordinates[j+1];
+        }
+        coordinates[numCoordinate-1] = tmp;
+        minPosition--;
+    }
+}
+
+
+/* =============================================================================
+ * checkAngles
+ * -- Sets isSkinny to TRUE if the angle constraint is not met
+ * =============================================================================
+ */
+static void
+checkAngles (element_t* elementPtr)
+{
+    long numCoordinate = elementPtr->numCoordinate;
+    double angleConstraint = global_angleConstraint;
+    double minAngle = 180.0;
+
+    assert(numCoordinate == 2 || numCoordinate == 3);
+    elementPtr->isReferenced = FALSE;
+    elementPtr->isSkinny = FALSE;
+    elementPtr->encroachedEdgePtr = NULL;
+
+    if (numCoordinate == 3) {
+        long i;
+        coordinate_t* coordinates = elementPtr->coordinates;
+        for (i = 0; i < 3; i++) {
+            double angle = coordinate_angle(&coordinates[i],
+                                            &coordinates[(i + 1) % 3],
+                                            &coordinates[(i + 2) % 3]);
+            assert(angle > 0.0);
+            assert(angle < 180.0);
+            if (angle > 90.0) {
+                elementPtr->encroachedEdgePtr = &elementPtr->edges[(i + 1) % 3];
+            }
+            if (angle < angleConstraint) {
+                elementPtr->isSkinny = TRUE;
+            }
+            if (angle < minAngle) {
+                minAngle = angle;
+            }
+        }
+        assert(minAngle < 180.0);
+    }
+
+    elementPtr->minAngle = minAngle;
+}
+
+
+/* =============================================================================
+ * calculateCircumCenter
+ *
+ * Given three points A(ax,ay), B(bx,by), C(cx,cy), circumcenter R(rx,ry):
+ *
+ *              |                         |
+ *              | by - ay   (||b - a||)^2 |
+ *              |                         |
+ *              | cy - ay   (||c - a||)^2 |
+ *              |                         |
+ *   rx = ax - -----------------------------
+ *                   |                   |
+ *                   | bx - ax   by - ay |
+ *               2 * |                   |
+ *                   | cx - ax   cy - ay |
+ *                   |                   |
+ *
+ *              |                         |
+ *              | bx - ax   (||b - a||)^2 |
+ *              |                         |
+ *              | cx - ax   (||c - a||)^2 |
+ *              |                         |
+ *   ry = ay + -----------------------------
+ *                   |                   |
+ *                   | bx - ax   by - ay |
+ *               2 * |                   |
+ *                   | cx - ax   cy - ay |
+ *                   |                   |
+ *
+ * =============================================================================
+ */
+static void
+calculateCircumCircle (element_t* elementPtr)
+{
+    long numCoordinate = elementPtr->numCoordinate;
+    coordinate_t* coordinates = elementPtr->coordinates;
+    coordinate_t* circumCenterPtr = &elementPtr->circumCenter;
+
+    assert(numCoordinate == 2 || numCoordinate == 3);
+
+    if (numCoordinate == 2) {
+        circumCenterPtr->x = (coordinates[0].x + coordinates[1].x) / 2.0;
+        circumCenterPtr->y = (coordinates[0].y + coordinates[1].y) / 2.0;
+    } else {
+        double ax = coordinates[0].x;
+        double ay = coordinates[0].y;
+        double bx = coordinates[1].x;
+        double by = coordinates[1].y;
+        double cx = coordinates[2].x;
+        double cy = coordinates[2].y;
+        double bxDelta = bx - ax;
+        double byDelta = by - ay;
+        double cxDelta = cx - ax;
+        double cyDelta = cy - ay;
+        double bDistance2 = (bxDelta * bxDelta) + (byDelta * byDelta);
+        double cDistance2 = (cxDelta * cxDelta) + (cyDelta * cyDelta);
+        double xNumerator = (byDelta * cDistance2) - (cyDelta * bDistance2);
+        double yNumerator = (bxDelta * cDistance2) - (cxDelta * bDistance2);
+        double denominator = 2 * ((bxDelta * cyDelta) - (cxDelta * byDelta));
+        double rx = ax - (xNumerator / denominator);
+        double ry = ay + (yNumerator / denominator);
+        assert(fabs(denominator) > DBL_MIN); /* make sure not colinear */
+        circumCenterPtr->x = rx;
+        circumCenterPtr->y = ry;
+    }
+
+    elementPtr->circumRadius = coordinate_distance(circumCenterPtr,
+                                                   &coordinates[0]);
+}
+
+
+/* =============================================================================
+ * setEdge
+ *
+  * Note: Makes pairPtr sorted; i.e., coordinate_compare(first, second) < 0
+ * =============================================================================
+ */
+static void
+setEdge (element_t* elementPtr, long i)
+{
+    long numCoordinate = elementPtr->numCoordinate;
+    coordinate_t* coordinates = elementPtr->coordinates;
+
+    coordinate_t* firstPtr = &coordinates[i];
+    coordinate_t* secondPtr = &coordinates[(i + 1) % numCoordinate];
+
+    edge_t* edgePtr = &elementPtr->edges[i];
+
+    long cmp = coordinate_compare(firstPtr, secondPtr);
+    assert(cmp != 0);
+    if (cmp < 0) {
+        edgePtr->firstPtr  = (void*)firstPtr;
+        edgePtr->secondPtr = (void*)secondPtr;
+    } else {
+        edgePtr->firstPtr  = (void*)secondPtr;
+        edgePtr->secondPtr = (void*)firstPtr;
+    }
+
+    coordinate_t* midpointPtr = &elementPtr->midpoints[i];
+    midpointPtr->x = (firstPtr->x + secondPtr->x) / 2.0;
+    midpointPtr->y = (firstPtr->y + secondPtr->y) / 2.0;
+
+    elementPtr->radii[i] = coordinate_distance(firstPtr, midpointPtr);
+}
+
+
+/* =============================================================================
+ * initEdges
+ * =============================================================================
+ */
+static void
+initEdges (element_t* elementPtr, coordinate_t* coordinates, long numCoordinate)
+{
+    long numEdge = ((numCoordinate * (numCoordinate - 1)) / 2);
+
+    elementPtr->numEdge = numEdge;
+
+    long e;
+    for (e = 0; e < numEdge; e++) {
+        setEdge(elementPtr, e);
+    }
+}
+
+
+/* =============================================================================
+ * element_compare
+ * =============================================================================
+ */
+long
+element_compare (element_t* aElementPtr, element_t* bElementPtr)
+{
+    long aNumCoordinate = aElementPtr->numCoordinate;
+    long bNumCoordinate = bElementPtr->numCoordinate;
+    coordinate_t* aCoordinates = aElementPtr->coordinates;
+    coordinate_t* bCoordinates = bElementPtr->coordinates;
+
+    if (aNumCoordinate < bNumCoordinate) {
+        return -1;
+    } else if (aNumCoordinate > bNumCoordinate) {
+        return 1;
+    }
+
+    long i;
+    for (i = 0; i < aNumCoordinate; i++) {
+        long compareCoordinate =
+            coordinate_compare(&aCoordinates[i], &bCoordinates[i]);
+        if (compareCoordinate != 0) {
+            return compareCoordinate;
+        }
+    }
+
+    return 0;
+}
+
+
+/* =============================================================================
+ * element_listCompare
+ *
+ * For use in list_t
+ * =============================================================================
+ */
+long
+element_listCompare (const void* aPtr, const void* bPtr)
+{
+    element_t* aElementPtr = (element_t*)aPtr;
+    element_t* bElementPtr = (element_t*)bPtr;
+
+    return element_compare(aElementPtr, bElementPtr);
+}
+
+
+/* =============================================================================
+ * element_mapCompare
+ *
+ * For use in MAP_T
+ * =============================================================================
+ */
+long
+element_mapCompare (void* aPtr, void* bPtr)
+{
+    element_t* aElementPtr = (element_t*)(aPtr);
+    element_t* bElementPtr = (element_t*)(bPtr);
+
+    return element_compare(aElementPtr, bElementPtr);
+}
+
+ulong_t element_mapHash(void* voidPtr) {
+    element_t* elementPtr = (element_t*) voidPtr;
+    ulong_t r = 0;
+    for (int i = 0; i < elementPtr->numCoordinate; ++i) {
+        union { double as_double; long as_long; } xcaster = { elementPtr->coordinates[i].x };
+        union { double as_double; long as_long; } ycaster = { elementPtr->coordinates[i].y };
+        r += xcaster.as_long + ycaster.as_long;
+    }
+    return r;
+}
+
+/* =============================================================================
+ * element_alloc
+ *
+ * Contains a copy of input arg 'coordinates'
+ * =============================================================================
+ */
+element_t*
+element_alloc (coordinate_t* coordinates, long numCoordinate)
+{
+    element_t* elementPtr;
+
+    elementPtr = new element_t;
+    if (elementPtr) {
+        long i;
+        for (i = 0; i < numCoordinate; i++) {
+            elementPtr->coordinates[i] = coordinates[i];
+        }
+        elementPtr->numCoordinate = numCoordinate;
+        minimizeCoordinates(elementPtr);
+        checkAngles(elementPtr);
+        calculateCircumCircle(elementPtr);
+        initEdges(elementPtr, coordinates, numCoordinate);
+        //elementPtr->neighborListPtr = list_alloc(element_listCompare);
+        //assert(elementPtr->neighborListPtr);
+        elementPtr->isGarbage = FALSE;
+        elementPtr->isReferenced = FALSE;
+    }
+
+    return elementPtr;
+}
+
+
+#if 0
+/* =============================================================================
+ * Pelement_alloc
+ *
+ * Contains a copy of input arg 'coordinates'
+ * =============================================================================
+ */
+element_t*
+Pelement_alloc (coordinate_t* coordinates, long numCoordinate)
+{
+    element_t* elementPtr;
+
+    elementPtr = (element_t*)P_MALLOC(sizeof(element_t));
+    if (elementPtr) {
+        long i;
+        for (i = 0; i < numCoordinate; i++) {
+            elementPtr->coordinates[i] = coordinates[i];
+        }
+        elementPtr->numCoordinate = numCoordinate;
+        minimizeCoordinates(elementPtr);
+        checkAngles(elementPtr);
+        calculateCircumCircle(elementPtr);
+        initEdges(elementPtr, coordinates, numCoordinate);
+        elementPtr->neighborListPtr = PLIST_ALLOC(element_listCompare);
+        assert(elementPtr->neighborListPtr);
+        elementPtr->isGarbage = FALSE;
+        elementPtr->isReferenced = FALSE;
+    }
+
+    return elementPtr;
+}
+#endif
+
+
+/* =============================================================================
+ * TMelement_alloc
+ *
+ * Contains a copy of input arg 'coordinates'
+ * =============================================================================
+ */
+element_t*
+TMelement_alloc (TM_ARGDECL  coordinate_t* coordinates, long numCoordinate, Galois::InsertBag<element_t>& alloc)
+{
+    element_t* elementPtr;
+
+    elementPtr = (element_t*)&alloc.emplace();//TM_MALLOC(sizeof(element_t));
+    if (elementPtr) {
+        long i;
+        for (i = 0; i < numCoordinate; i++) {
+            elementPtr->coordinates[i] = coordinates[i];
+        }
+        elementPtr->numCoordinate = numCoordinate;
+        minimizeCoordinates(elementPtr);
+        checkAngles(elementPtr);
+        calculateCircumCircle(elementPtr);
+        initEdges(elementPtr, coordinates, numCoordinate);
+        //elementPtr->neighborListPtr = TMLIST_ALLOC(element_listCompare);
+        //assert(elementPtr->neighborListPtr);
+        elementPtr->isGarbage = FALSE;
+        elementPtr->isReferenced = FALSE;
+    }
+
+    return elementPtr;
+}
+
+/* =============================================================================
+ * element_free
+ * =============================================================================
+ */
+void
+element_free (element_t* elementPtr)
+{
+    delete elementPtr;
+}
+
+#if 0
+/* =============================================================================
+ * Pelement_free
+ * =============================================================================
+ */
+void
+Pelement_free (element_t* elementPtr)
+{
+    PLIST_FREE(elementPtr->neighborListPtr);
+    P_FREE(elementPtr);
+}
+
+
+/* =============================================================================
+ * TMelement_free
+ * =============================================================================
+ */
+void
+TMelement_free (TM_ARGDECL  element_t* elementPtr)
+{
+    TMLIST_FREE(elementPtr->neighborListPtr);
+    TM_FREE(elementPtr);
+}
+#endif
+
+/* =============================================================================
+ * element_getNumEdge
+ * =============================================================================
+ */
+long
+element_getNumEdge (element_t* elementPtr)
+{
+    return elementPtr->numEdge;
+}
+
+
+/* =============================================================================
+ * element_getEdge
+ *
+ * Returned edgePtr is sorted; i.e., coordinate_compare(first, second) < 0
+ * =============================================================================
+ */
+edge_t*
+element_getEdge (element_t* elementPtr, long i)
+{
+    if (i < 0 || i > elementPtr->numEdge) {
+        return NULL;
+    }
+
+    return &elementPtr->edges[i];
+}
+
+
+/* =============================================================================
+ * element_compareEdge
+ * =============================================================================
+ */
+static long
+compareEdge (edge_t* aEdgePtr, edge_t* bEdgePtr)
+{
+    long diffFirst = coordinate_compare((coordinate_t*)aEdgePtr->firstPtr,
+                                        (coordinate_t*)bEdgePtr->firstPtr);
+
+    return ((diffFirst != 0) ?
+            (diffFirst) :
+            (coordinate_compare((coordinate_t*)aEdgePtr->secondPtr,
+                                (coordinate_t*)bEdgePtr->secondPtr)));
+}
+
+
+/* ============================================================================
+ * element_listCompareEdge
+ *
+ * For use in list_t
+ * ============================================================================
+ */
+long
+element_listCompareEdge (const void* aPtr, const void* bPtr)
+{
+    edge_t* aEdgePtr = (edge_t*)(aPtr);
+    edge_t* bEdgePtr = (edge_t*)(bPtr);
+
+    return compareEdge(aEdgePtr, bEdgePtr);
+}
+
+ulong_t element_mapHashEdge(void* voidPtr) {
+    edge_t* edgePtr = (edge_t*) voidPtr;
+    coordinate_t* first = (coordinate_t*) edgePtr->firstPtr;
+    coordinate_t* second = (coordinate_t*) edgePtr->secondPtr;
+    ulong_t r = 0;
+    union { double as_double; long as_long; } firstx = { first->x };
+    union { double as_double; long as_long; } firsty = { first->y };
+    union { double as_double; long as_long; } secondx = { second->x };
+    union { double as_double; long as_long; } secondy = { second->y };
+    r += firstx.as_long + firsty.as_long + secondx.as_long + secondy.as_long; 
+    return r;
+}
+
+/* =============================================================================
+ * element_mapCompareEdge
+ *
+  * For use in MAP_T
+ * =============================================================================
+ */
+long
+element_mapCompareEdge (void* a, void* b)
+{
+    edge_t* aEdgePtr = (edge_t*)(a);
+    edge_t* bEdgePtr = (edge_t*)(b);
+
+    return compareEdge(aEdgePtr, bEdgePtr);
+}
+
+
+/* =============================================================================
+ * element_heapCompare
+ *
+ * For use in heap_t. Consider using minAngle instead of "do not care".
+ * =============================================================================
+ */
+long
+element_heapCompare (const void* aPtr, const void* bPtr)
+{
+    element_t* aElementPtr = (element_t*)aPtr;
+    element_t* bElementPtr = (element_t*)bPtr;
+
+    if (aElementPtr->encroachedEdgePtr) {
+        if (bElementPtr->encroachedEdgePtr) {
+            return 0; /* do not care */
+        } else {
+            return 1;
+        }
+    }
+
+    if (bElementPtr->encroachedEdgePtr) {
+        return -1;
+    }
+
+    return 0; /* do not care */
+}
+
+
+/* =============================================================================
+ * element_isInCircumCircle
+ * =============================================================================
+ */
+bool_t
+element_isInCircumCircle (element_t* elementPtr, coordinate_t* coordinatePtr)
+{
+    double distance = coordinate_distance(coordinatePtr,
+                                          &elementPtr->circumCenter);
+
+    return ((distance <= elementPtr->circumRadius) ? TRUE : FALSE);
+}
+
+
+/* =============================================================================
+ * isEncroached
+ * =============================================================================
+ */
+static bool_t
+isEncroached (element_t* elementPtr)
+{
+    return ((elementPtr->encroachedEdgePtr != NULL) ? TRUE : FALSE);
+}
+
+
+/* =============================================================================
+ * element_setEncroached
+ * =============================================================================
+ */
+void
+element_clearEncroached (element_t* elementPtr)
+{
+    elementPtr->encroachedEdgePtr = NULL;
+}
+
+
+/* =============================================================================
+ * element_getEncroachedPtr
+ * =============================================================================
+ */
+edge_t*
+element_getEncroachedPtr (element_t* elementPtr)
+{
+    return elementPtr->encroachedEdgePtr;
+}
+
+
+/* =============================================================================
+ * element_isSkinny
+ * =============================================================================
+ */
+bool_t
+element_isSkinny (element_t* elementPtr)
+{
+    return ((elementPtr->isSkinny) ? TRUE : FALSE);
+}
+
+
+/* =============================================================================
+ * element_isBad
+ * -- Does it need to be refined?
+ * =============================================================================
+ */
+bool_t
+element_isBad (element_t* elementPtr)
+{
+    return ((isEncroached(elementPtr) || element_isSkinny(elementPtr)) ?
+            TRUE : FALSE);
+}
+
+
+/* =============================================================================
+ * element_isReferenced
+ * -- Held by another data structure?
+ * =============================================================================
+ */
+bool_t
+element_isReferenced (element_t* elementPtr)
+{
+    return elementPtr->isReferenced;
+}
+
+
+/* =============================================================================
+ * TMelement_isReferenced
+ * -- Held by another data structure?
+ * =============================================================================
+ */
+bool_t
+TMelement_isReferenced (TM_ARGDECL  element_t* elementPtr)
+{
+    return (bool_t)TM_SHARED_READ(elementPtr->isReferenced);
+}
+
+
+/* =============================================================================
+ * element_setIsReferenced
+ * =============================================================================
+ */
+void
+element_setIsReferenced (element_t* elementPtr, bool_t status)
+{
+    elementPtr->isReferenced = status;
+}
+
+
+/* =============================================================================
+ * TMelement_setIsReferenced
+ * =============================================================================
+ */
+void
+TMelement_setIsReferenced (TM_ARGDECL  element_t* elementPtr, bool_t status)
+{
+    TM_SHARED_WRITE(elementPtr->isReferenced, status);
+}
+
+
+/* =============================================================================
+ * element_isGarbage
+ * -- Can we deallocate?
+ * =============================================================================
+ */
+bool_t
+element_isGarbage (element_t* elementPtr)
+{
+    return elementPtr->isGarbage;
+}
+
+
+/* =============================================================================
+ * TMelement_isGarbage
+ * -- Can we deallocate?
+ * =============================================================================
+ */
+bool_t
+TMelement_isGarbage (TM_ARGDECL  element_t* elementPtr)
+{
+    return (bool_t)TM_SHARED_READ(elementPtr->isGarbage);
+}
+
+
+/* =============================================================================
+ * element_setIsGarbage
+ * =============================================================================
+ */
+void
+element_setIsGarbage (element_t* elementPtr, bool_t status)
+{
+    elementPtr->isGarbage = status;
+}
+
+
+/* =============================================================================
+ * TMelement_setIsGarbage
+ * =============================================================================
+ */
+void
+TMelement_setIsGarbage (TM_ARGDECL  element_t* elementPtr, bool_t status)
+{
+    TM_SHARED_WRITE(elementPtr->isGarbage, status);
+}
+
+
+/* =============================================================================
+ * element_addNeighbor
+ * =============================================================================
+ */
+void
+element_addNeighbor (element_t* elementPtr, element_t* neighborPtr)
+{
+    list_insert(&elementPtr->neighborList, (void*)neighborPtr);
+    assert(list_getSize(&elementPtr->neighborList) <= elementPtr->numEdge);
+}
+
+
+/* =============================================================================
+ * TMelement_addNeighbor
+ * =============================================================================
+ */
+void
+TMelement_addNeighbor (TM_ARGDECL  element_t* elementPtr, element_t* neighborPtr)
+{
+    LIST_INSERT(&elementPtr->neighborList, (void*)neighborPtr);
+}
+
+
+/* =============================================================================
+ * element_getNeighborListPtr
+ * =============================================================================
+ */
+list_t*
+element_getNeighborListPtr (element_t* elementPtr)
+{
+    return &elementPtr->neighborList;
+}
+
+
+/* =============================================================================
+ * element_getCommonEdge
+ *
+ * Returns pointer to aElementPtr's shared edge
+ * =============================================================================
+ */
+edge_t*
+element_getCommonEdge (element_t* aElementPtr, element_t* bElementPtr)
+{
+    edge_t* aEdges = aElementPtr->edges;
+    edge_t* bEdges = bElementPtr->edges;
+    long aNumEdge = aElementPtr->numEdge;
+    long bNumEdge = bElementPtr->numEdge;
+    long a;
+    long b;
+
+    for (a = 0; a < aNumEdge; a++) {
+        edge_t* aEdgePtr = &aEdges[a];
+        for (b = 0; b < bNumEdge; b++) {
+            edge_t* bEdgePtr = &bEdges[b];
+            if (compareEdge(aEdgePtr, bEdgePtr) == 0) {
+                return aEdgePtr;
+            }
+        }
+    }
+
+    return NULL;
+}
+
+
+/* =============================================================================
+ * element_getNewPoint
+ * -- Either the element is encroached or is skinny, so get the new point to add
+ * =============================================================================
+ */
+coordinate_t
+element_getNewPoint (element_t* elementPtr)
+{
+    edge_t* encroachedEdgePtr = elementPtr->encroachedEdgePtr;
+
+    if (encroachedEdgePtr) {
+        long e;
+        long numEdge = elementPtr->numEdge;
+        edge_t* edges = elementPtr->edges;
+        for (e = 0; e < numEdge; e++) {
+            if (compareEdge(encroachedEdgePtr, &edges[e]) == 0) {
+                return elementPtr->midpoints[e];
+            }
+        }
+        assert(0);
+    }
+
+    return elementPtr->circumCenter;
+}
+
+
+/* =============================================================================
+ * element_checkAngles
+ *
+ * Return FALSE if minimum angle constraint not met
+ * =============================================================================
+ */
+bool_t
+element_checkAngles (element_t* elementPtr)
+{
+    long numCoordinate = elementPtr->numCoordinate;
+    double angleConstraint = global_angleConstraint;
+
+    if (numCoordinate == 3) {
+        long i;
+        coordinate_t* coordinates = elementPtr->coordinates;
+        for (i = 0; i < 3; i++) {
+            double angle = coordinate_angle(&coordinates[i],
+                                            &coordinates[(i + 1) % 3],
+                                            &coordinates[(i + 2) % 3]);
+            if (angle < angleConstraint) {
+                return FALSE;
+            }
+        }
+    }
+
+    return TRUE;
+}
+
+
+/* =============================================================================
+ * element_print
+ * =============================================================================
+ */
+void
+element_print (element_t* elementPtr)
+{
+    long c;
+    long numCoordinate = elementPtr->numCoordinate;
+    coordinate_t* coordinates = elementPtr->coordinates;
+
+    for (c = 0; c < numCoordinate; c++) {
+        coordinate_print(&coordinates[c]);
+        printf(" ");
+    }
+}
+
+
+/* =============================================================================
+ * element_printEdge
+ * =============================================================================
+ */
+void
+element_printEdge (edge_t* edgePtr)
+{
+    coordinate_print((coordinate_t*)edgePtr->firstPtr);
+    printf(" -> ");
+    coordinate_print((coordinate_t*)edgePtr->secondPtr);
+}
+
+
+/* =============================================================================
+ * element_printAngles
+ * =============================================================================
+ */
+void
+element_printAngles (element_t* elementPtr)
+{
+    long numCoordinate = elementPtr->numCoordinate;
+
+    if (numCoordinate == 3) {
+        long i;
+        coordinate_t* coordinates = elementPtr->coordinates;
+        for (i = 0; i < 3; i++) {
+            double angle = coordinate_angle(&coordinates[i],
+                                            &coordinates[(i + 1) % 3],
+                                            &coordinates[(i + 2) % 3]);
+            printf("%0.3lf ", angle);
+        }
+    }
+
+}
+
+
+#ifdef TEST_ELEMENT
+/* =============================================================================
+ * TEST_ELEMENT
+ * =============================================================================
+ */
+
+
+#include <assert.h>
+#include <stdio.h>
+
+
+static void
+printElement (element_t* elementPtr)
+{
+    long numCoordinate = elementPtr->numCoordinate;
+    coordinate_t* coordinates = elementPtr->coordinates;
+    long i;
+
+    printf("%li: ", elementPtr->numCoordinate);
+    for (i = 0; i < numCoordinate; i++) {
+        printf("(%.2lf, %.2lf) ", coordinates[i].x, coordinates[i].y);
+    }
+    printf("| (%.2lf, %.2lf)",
+            elementPtr->circumCenter.x, elementPtr->circumCenter.y);
+    printf(" | isBad = %li", (long)element_isBad(elementPtr));
+    puts("");
+}
+
+
+int
+main (int argc, char* argv[])
+{
+    element_t* elementPtr;
+    coordinate_t coordinates[4];
+
+    coordinates[0].x = 1;
+    coordinates[0].y = 0;
+    coordinates[1].x = 0;
+    coordinates[1].y = 1;
+    coordinates[2].x = 0;
+    coordinates[2].y = 0;
+    coordinates[3].x = -2;
+    coordinates[3].y = -2;
+
+    elementPtr = element_alloc(coordinates, 3);
+    assert(elementPtr);
+    printElement(elementPtr);
+    element_free(elementPtr);
+
+    elementPtr = element_alloc(coordinates, 2);
+    assert(elementPtr);
+    printElement(elementPtr);
+    element_free(elementPtr);
+
+    elementPtr = element_alloc(coordinates+1, 3);
+    assert(elementPtr);
+    printElement(elementPtr);
+    element_free(elementPtr);
+
+    return 0;
+}
+
+
+#endif /* TEST_ELEMENT */
+
+
+/* =============================================================================
+ *
+ * End of element.c
+ *
+ * =============================================================================
+ */
diff -x .git -x inputs -Naur stamp-0.9.10/yada/element.h stamp-g/yada/element.h
--- stamp-0.9.10/yada/element.h	2017-03-21 17:30:14.000000000 +0000
+++ stamp-g/yada/element.h	2017-03-20 15:19:41.000000000 +0000
@@ -79,18 +79,21 @@
 #include "tm.h"
 #include "types.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef pair_t         edge_t;
 typedef struct element element_t;
 
-
+#if 0
 /* =============================================================================
  * element_compare
  * =============================================================================
  */
 long
 element_compare (element_t* aElementPtr, element_t* bElementPtr);
-
+#endif
 
 /* =============================================================================
  * element_listCompare
@@ -109,8 +112,10 @@
  * =============================================================================
  */
 long
-element_mapCompare (const pair_t* aPtr, const pair_t* bPtr);
+element_mapCompare (void* aPtr, void* bPtr);
 
+ulong_t element_mapHashEdge(void* voidPtr);
+ulong_t element_mapHash(void* voidPtr);
 
 /* =============================================================================
  * element_alloc
@@ -132,15 +137,6 @@
 Pelement_alloc (coordinate_t* coordinates, long numCoordinate);
 
 
-/* =============================================================================
- * TMelement_alloc
- *
- * Contains a copy of input arg 'coordinates'
- * =============================================================================
- */
-element_t*
-TMelement_alloc (TM_ARGDECL  coordinate_t* coordinates, long numCoordinate);
-
 
 /* =============================================================================
  * element_free
@@ -201,7 +197,7 @@
  * =============================================================================
  */
 long
-element_mapCompareEdge (const pair_t* aPtr, const pair_t* bPtr);
+element_mapCompareEdge (void* aPtr, void* bPtr);
 
 
 /* =============================================================================
@@ -332,7 +328,6 @@
 void
 element_addNeighbor (element_t* elementPtr, element_t* neighborPtr);
 
-
 /* =============================================================================
  * TMelement_addNeighbor
  * =============================================================================
@@ -405,7 +400,7 @@
 #define PELEMENT_FREE(e)                /*Pelement_free(e)*/
 
 
-#define TMELEMENT_ALLOC(c, n)           TMelement_alloc(TM_ARG  c, n)
+#define TMELEMENT_ALLOC(c, n, b)           TMelement_alloc(TM_ARG  c, n, b)
 #define TMELEMENT_FREE(e)               /*TMelement_free(TM_ARG  e)*/
 #define TMELEMENT_ISREFERENCED(e)       TMelement_isReferenced(TM_ARG  e)
 #define TMELEMENT_SETISREFERENCED(e, s) TMelement_setIsReferenced(TM_ARG  e, s)
@@ -414,6 +409,49 @@
 #define TMELEMENT_ADDNEIGHBOR(e, n)     TMelement_addNeighbor(TM_ARG  e, n)
 #define TMELEMENT_GETNEIGHBORLIST(e)    TMelement_getNeighborListPtr(TM_ARG  e)
 
+#ifdef __cplusplus
+}
+
+#include "Galois/Bag.h"
+
+struct element {
+#ifndef HTM
+    Galois::Runtime::Lockable lock;
+#endif
+    coordinate_t coordinates[3];
+    long numCoordinate;
+    coordinate_t circumCenter;
+    double circumRadius;
+    double minAngle;
+    edge_t edges[3];
+    long numEdge;
+    coordinate_t midpoints[3]; /* midpoint of each edge */
+    double radii[3];           /* half of edge length */
+    edge_t* encroachedEdgePtr; /* opposite obtuse angle */
+    bool_t isSkinny;
+    list_t neighborList;
+    bool_t isGarbage;
+    bool_t isReferenced;
+
+    element(): neighborList(element_listCompare) { }
+
+    void acquire() {
+#ifndef HTM
+        Galois::Runtime::acquire(&lock, Galois::MethodFlag::ALL);
+#endif
+    }
+};
+
+/* =============================================================================
+ * TMelement_alloc
+ *
+ * Contains a copy of input arg 'coordinates'
+ * =============================================================================
+ */
+element_t*
+TMelement_alloc (TM_ARGDECL  coordinate_t* coordinates, long numCoordinate, Galois::InsertBag<element_t>&);
+
+#endif
 
 #endif /* ELEMENT_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/yada/mesh.c stamp-g/yada/mesh.c
--- stamp-0.9.10/yada/mesh.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/yada/mesh.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,612 +0,0 @@
-/* =============================================================================
- *
- * mesh.c
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "element.h"
-#include "list.h"
-#include "map.h"
-#include "mesh.h"
-#include "queue.h"
-#include "random.h"
-#include "set.h"
-#include "tm.h"
-#include "types.h"
-#include "utility.h"
-
-
-struct mesh {
-    XTM_DECL_LOCKABLE(element_t*, rootElementPtr);
-    queue_t* initBadQueuePtr;
-    long size;
-    SET_T* boundarySetPtr;
-};
-
-
-/* =============================================================================
- * mesh_alloc
- * =============================================================================
- */
-mesh_t*
-mesh_alloc ()
-{
-    mesh_t* meshPtr = (mesh_t*)malloc(sizeof(mesh_t));
-
-    if (meshPtr) {
-        XTM_LOCKABLE_VALUE(meshPtr->rootElementPtr) = NULL;
-        XTM_LOCKABLE_INIT(meshPtr->rootElementPtr);
-        meshPtr->initBadQueuePtr = queue_alloc(-1);
-        assert(meshPtr->initBadQueuePtr);
-        meshPtr->size = 0;
-        meshPtr->boundarySetPtr = SET_ALLOC(NULL, &element_listCompareEdge);
-        assert(meshPtr->boundarySetPtr);
-    }
-
-    return meshPtr;
-}
-
-
-/* =============================================================================
- * mesh_free
- * =============================================================================
- */
-void
-mesh_free (mesh_t* meshPtr)
-{
-    queue_free(meshPtr->initBadQueuePtr);
-    SET_FREE(meshPtr->boundarySetPtr);
-    free(meshPtr);
-}
-
-
-/* =============================================================================
- * mesh_insert
- * =============================================================================
- */
-void
-mesh_insert (mesh_t* meshPtr, element_t* elementPtr, MAP_T* edgeMapPtr)
-{
-    /*
-     * Assuming fully connected graph, we just need to record one element.
-     * The root element is not needed for the actual refining, but rather
-     * for checking the validity of the final mesh.
-     */
-    if (!XTM_LOCKABLE_VALUE(meshPtr->rootElementPtr)) {
-        XTM_LOCKABLE_VALUE(meshPtr->rootElementPtr) = elementPtr;
-    }
-
-    /*
-     * Record existence of each of this element's edges
-     */
-    long i;
-    long numEdge = element_getNumEdge(elementPtr);
-    for (i = 0; i < numEdge; i++) {
-        pair_t* edgePtr = element_getEdge(elementPtr, i);
-        if (!MAP_CONTAINS(edgeMapPtr, (void*)edgePtr)) {
-            /*
-             * Record existence of this edge
-             */
-            bool_t isSuccess;
-            isSuccess =
-                MAP_INSERT(edgeMapPtr, (void*)edgePtr, (void*)elementPtr);
-            assert(isSuccess);
-        } else {
-            /*
-             * Shared edge; update each element's neighborList
-             */
-            bool_t isSuccess;
-            element_t* sharerPtr = (element_t*)MAP_FIND(edgeMapPtr, edgePtr);
-            assert(sharerPtr); /* cannot be shared by >2 elements */
-            element_addNeighbor(elementPtr, sharerPtr);
-            element_addNeighbor(sharerPtr, elementPtr);
-            isSuccess = MAP_REMOVE(edgeMapPtr, edgePtr);
-            assert(isSuccess);
-            isSuccess = MAP_INSERT(edgeMapPtr,
-                                   edgePtr,
-                                   NULL); /* marker to check >2 sharers */
-            assert(isSuccess);
-        }
-    }
-
-    /*
-     * Check if really encroached
-     */
-
-    edge_t* encroachedPtr = element_getEncroachedPtr(elementPtr);
-    if (encroachedPtr) {
-        if (!SET_CONTAINS(meshPtr->boundarySetPtr, encroachedPtr)) {
-            element_clearEncroached(elementPtr);
-        }
-    }
-}
-
-
-/* =============================================================================
- * TMmesh_insert
- * =============================================================================
- */
-void
-TMmesh_insert (TM_ARGDECL
-               mesh_t* meshPtr, element_t* elementPtr, MAP_T* edgeMapPtr)
-{
-    /*
-     * Assuming fully connected graph, we just need to record one element.
-     * The root element is not needed for the actual refining, but rather
-     * for checking the validity of the final mesh.
-     */
-    if (!TM_SHARED_READ_P(meshPtr->rootElementPtr)) {
-        TM_SHARED_WRITE_P(meshPtr->rootElementPtr, elementPtr);
-    }
-
-    /*
-     * Record existence of each of this element's edges
-     */
-    long i;
-    long numEdge = element_getNumEdge(elementPtr);
-    for (i = 0; i < numEdge; i++) {
-        edge_t* edgePtr = element_getEdge(elementPtr, i);
-        if (!MAP_CONTAINS(edgeMapPtr, (void*)edgePtr)) {
-            /* Record existance of this edge */
-            bool_t isSuccess;
-            isSuccess =
-                PMAP_INSERT(edgeMapPtr, (void*)edgePtr, (void*)elementPtr);
-            assert(isSuccess);
-        } else {
-            /*
-             * Shared edge; update each element's neighborList
-             */
-            bool_t isSuccess;
-            element_t* sharerPtr = (element_t*)MAP_FIND(edgeMapPtr, edgePtr);
-            assert(sharerPtr); /* cannot be shared by >2 elements */
-            TMELEMENT_ADDNEIGHBOR(elementPtr, sharerPtr);
-            TMELEMENT_ADDNEIGHBOR(sharerPtr, elementPtr);
-            isSuccess = PMAP_REMOVE(edgeMapPtr, edgePtr);
-            assert(isSuccess);
-            isSuccess = PMAP_INSERT(edgeMapPtr,
-                                    edgePtr,
-                                    NULL); /* marker to check >2 sharers */
-            assert(isSuccess);
-        }
-    }
-
-    /*
-     * Check if really encroached
-     */
-
-    edge_t* encroachedPtr = element_getEncroachedPtr(elementPtr);
-    if (encroachedPtr) {
-        if (!TMSET_CONTAINS(meshPtr->boundarySetPtr, encroachedPtr)) {
-            element_clearEncroached(elementPtr);
-        }
-    }
-}
-
-
-/* =============================================================================
- * TMmesh_remove
- * =============================================================================
- */
-void
-TMmesh_remove (TM_ARGDECL  mesh_t* meshPtr, element_t* elementPtr)
-{
-    assert(!TMELEMENT_ISGARBAGE(elementPtr));
-
-    /*
-     * If removing root, a new root is selected on the next mesh_insert, which
-     * always follows a call a mesh_remove.
-     */
-    if ((element_t*)TM_SHARED_READ_P(meshPtr->rootElementPtr) == elementPtr) {
-        TM_SHARED_WRITE_P(meshPtr->rootElementPtr, NULL);
-    }
-
-    /*
-     * Remove from neighbors
-     */
-    list_iter_t it;
-    list_t* neighborListPtr = element_getNeighborListPtr(elementPtr);
-    TMLIST_ITER_RESET(&it, neighborListPtr);
-    while (TMLIST_ITER_HASNEXT(&it, neighborListPtr)) {
-        element_t* neighborPtr =
-            (element_t*)TMLIST_ITER_NEXT(&it, neighborListPtr);
-        list_t* neighborNeighborListPtr = element_getNeighborListPtr(neighborPtr);
-        bool_t status = TMLIST_REMOVE(neighborNeighborListPtr, elementPtr);
-        assert(status);
-    }
-
-    TMELEMENT_SETISGARBAGE(elementPtr, TRUE);
-
-    if (!TMELEMENT_ISREFERENCED(elementPtr)) {
-        TMELEMENT_FREE(elementPtr);
-    }
-}
-
-
-/* =============================================================================
- * TMmesh_insertBoundary
- * =============================================================================
- */
-bool_t
-TMmesh_insertBoundary (TM_ARGDECL  mesh_t* meshPtr, edge_t* boundaryPtr)
-{
-    return TMSET_INSERT(meshPtr->boundarySetPtr, boundaryPtr);
-}
-
-
-/* =============================================================================
- * TMmesh_removeBoundary
- * =============================================================================
- */
-bool_t
-TMmesh_removeBoundary (TM_ARGDECL  mesh_t* meshPtr, edge_t* boundaryPtr)
-{
-    return TMSET_REMOVE(meshPtr->boundarySetPtr, boundaryPtr);
-}
-
-
-/* =============================================================================
- * createElement
- * =============================================================================
- */
-static void
-createElement (mesh_t* meshPtr,
-               coordinate_t* coordinates,
-               long numCoordinate,
-               MAP_T* edgeMapPtr)
-{
-    element_t* elementPtr = element_alloc(coordinates, numCoordinate);
-    assert(elementPtr);
-
-    if (numCoordinate == 2) {
-        edge_t* boundaryPtr = element_getEdge(elementPtr, 0);
-        bool_t status = SET_INSERT(meshPtr->boundarySetPtr, boundaryPtr);
-        assert(status);
-    }
-
-    mesh_insert(meshPtr, elementPtr, edgeMapPtr);
-
-    if (element_isBad(elementPtr)) {
-        bool_t status = queue_push(meshPtr->initBadQueuePtr, (void*)elementPtr);
-        assert(status);
-    }
- }
-
-
-/* =============================================================================
- * mesh_read
- *
- * Returns number of elements read from file
- *
- * Refer to http://www.cs.cmu.edu/~quake/triangle.html for file formats.
- * =============================================================================
- */
-long
-mesh_read (mesh_t* meshPtr, char* fileNamePrefix)
-{
-    FILE* inputFile;
-    coordinate_t* coordinates;
-    char fileName[256];
-    long fileNameSize = sizeof(fileName) / sizeof(fileName[0]);
-    char inputBuff[256];
-    long inputBuffSize = sizeof(inputBuff) / sizeof(inputBuff[0]);
-    long numEntry;
-    long numDimension;
-    long numCoordinate;
-    long i;
-    long numElement = 0;
-
-    MAP_T* edgeMapPtr = MAP_ALLOC(NULL, &element_mapCompareEdge);
-    assert(edgeMapPtr);
-
-    /*
-     * Read .node file
-     */
-    snprintf(fileName, fileNameSize, "%s.node", fileNamePrefix);
-    inputFile = fopen(fileName, "r");
-    assert(inputFile);
-    fgets(inputBuff, inputBuffSize, inputFile);
-    sscanf(inputBuff, "%li %li", &numEntry, &numDimension);
-    assert(numDimension == 2); /* must be 2-D */
-    numCoordinate = numEntry + 1; /* numbering can start from 1 */
-    coordinates = (coordinate_t*)malloc(numCoordinate * sizeof(coordinate_t));
-    assert(coordinates);
-    for (i = 0; i < numEntry; i++) {
-        long id;
-        double x;
-        double y;
-        if (!fgets(inputBuff, inputBuffSize, inputFile)) {
-            break;
-        }
-        if (inputBuff[0] == '#') {
-            continue; /* TODO: handle comments correctly */
-        }
-        sscanf(inputBuff, "%li %lf %lf", &id, &x, &y);
-        coordinates[id].x = x;
-        coordinates[id].y = y;
-    }
-    assert(i == numEntry);
-    fclose(inputFile);
-
-    /*
-     * Read .poly file, which contains boundary segments
-     */
-    snprintf(fileName, fileNameSize, "%s.poly", fileNamePrefix);
-    inputFile = fopen(fileName, "r");
-    assert(inputFile);
-    fgets(inputBuff, inputBuffSize, inputFile);
-    sscanf(inputBuff, "%li %li", &numEntry, &numDimension);
-    assert(numEntry == 0); /* .node file used for vertices */
-    assert(numDimension == 2); /* must be edge */
-    fgets(inputBuff, inputBuffSize, inputFile);
-    sscanf(inputBuff, "%li", &numEntry);
-    for (i = 0; i < numEntry; i++) {
-        long id;
-        long a;
-        long b;
-        coordinate_t insertCoordinates[2];
-        if (!fgets(inputBuff, inputBuffSize, inputFile)) {
-            break;
-        }
-        if (inputBuff[0] == '#') {
-            continue; /* TODO: handle comments correctly */
-        }
-        sscanf(inputBuff, "%li %li %li", &id, &a, &b);
-        assert(a >= 0 && a < numCoordinate);
-        assert(b >= 0 && b < numCoordinate);
-        insertCoordinates[0] = coordinates[a];
-        insertCoordinates[1] = coordinates[b];
-        createElement(meshPtr, insertCoordinates, 2, edgeMapPtr);
-    }
-    assert(i == numEntry);
-    numElement += numEntry;
-    fclose(inputFile);
-
-    /*
-     * Read .ele file, which contains triangles
-     */
-    snprintf(fileName, fileNameSize, "%s.ele", fileNamePrefix);
-    inputFile = fopen(fileName, "r");
-    assert(inputFile);
-    fgets(inputBuff, inputBuffSize, inputFile);
-    sscanf(inputBuff, "%li %li", &numEntry, &numDimension);
-    assert(numDimension == 3); /* must be triangle */
-    for (i = 0; i < numEntry; i++) {
-        long id;
-        long a;
-        long b;
-        long c;
-        coordinate_t insertCoordinates[3];
-        if (!fgets(inputBuff, inputBuffSize, inputFile)) {
-            break;
-        }
-        if (inputBuff[0] == '#') {
-            continue; /* TODO: handle comments correctly */
-        }
-        sscanf(inputBuff, "%li %li %li %li", &id, &a, &b, &c);
-        assert(a >= 0 && a < numCoordinate);
-        assert(b >= 0 && b < numCoordinate);
-        assert(c >= 0 && c < numCoordinate);
-        insertCoordinates[0] = coordinates[a];
-        insertCoordinates[1] = coordinates[b];
-        insertCoordinates[2] = coordinates[c];
-        createElement(meshPtr, insertCoordinates, 3, edgeMapPtr);
-    }
-    assert(i == numEntry);
-    numElement += numEntry;
-    fclose(inputFile);
-
-    free(coordinates);
-    MAP_FREE(edgeMapPtr);
-
-    return numElement;
-}
-
-
-/* =============================================================================
- * mesh_getBad
- * -- Returns NULL if none
- * =============================================================================
- */
-element_t*
-mesh_getBad (mesh_t* meshPtr)
-{
-    return (element_t*)queue_pop(meshPtr->initBadQueuePtr);
-}
-
-
-/* =============================================================================
- * mesh_shuffleBad
- * =============================================================================
- */
-void
-mesh_shuffleBad (mesh_t* meshPtr, random_t* randomPtr)
-{
-    queue_shuffle(meshPtr->initBadQueuePtr, randomPtr);
-}
-
-
-/* =============================================================================
- * mesh_check
- * =============================================================================
- */
-bool_t
-mesh_check (mesh_t* meshPtr, long expectedNumElement)
-{
-    queue_t* searchQueuePtr;
-    MAP_T* visitedMapPtr;
-    long numBadTriangle = 0;
-    long numFalseNeighbor = 0;
-    long numElement = 0;
-
-    puts("Checking final mesh:");
-    fflush(stdout);
-
-    searchQueuePtr = queue_alloc(-1);
-    assert(searchQueuePtr);
-    visitedMapPtr = MAP_ALLOC(NULL, &element_mapCompare);
-    assert(visitedMapPtr);
-
-    /*
-     * Do breadth-first search starting from rootElementPtr
-     */
-    assert(XTM_LOCKABLE_VALUE(meshPtr->rootElementPtr));
-    queue_push(searchQueuePtr, (void*)XTM_LOCKABLE_VALUE(meshPtr->rootElementPtr));
-    while (!queue_isEmpty(searchQueuePtr)) {
-
-        element_t* currentElementPtr;
-        list_iter_t it;
-        list_t* neighborListPtr;
-        bool_t isSuccess;
-
-        currentElementPtr = (element_t*)queue_pop(searchQueuePtr);
-        if (MAP_CONTAINS(visitedMapPtr, (void*)currentElementPtr)) {
-            continue;
-        }
-        isSuccess = MAP_INSERT(visitedMapPtr, (void*)currentElementPtr, NULL);
-        assert(isSuccess);
-        if (!element_checkAngles(currentElementPtr)) {
-            numBadTriangle++;
-        }
-        neighborListPtr = element_getNeighborListPtr(currentElementPtr);
-
-        list_iter_reset(&it, neighborListPtr);
-        while (list_iter_hasNext(&it, neighborListPtr)) {
-            element_t* neighborElementPtr =
-                (element_t*)list_iter_next(&it, neighborListPtr);
-            /*
-             * Continue breadth-first search
-             */
-            if (!MAP_CONTAINS(visitedMapPtr, (void*)neighborElementPtr)) {
-                bool_t isSuccess;
-                isSuccess = queue_push(searchQueuePtr,
-                                       (void*)neighborElementPtr);
-                assert(isSuccess);
-            }
-        } /* for each neighbor */
-
-        numElement++;
-
-    } /* breadth-first search */
-
-    printf("Number of elements      = %li\n", numElement);
-    printf("Number of bad triangles = %li\n", numBadTriangle);
-
-    queue_free(searchQueuePtr);
-    MAP_FREE(visitedMapPtr);
-
-    return ((numBadTriangle > 0 ||
-             numFalseNeighbor > 0 ||
-             numElement != expectedNumElement) ? FALSE : TRUE);
-}
-
-
-#ifdef TEST_MESH
-/* =============================================================================
- * TEST_MESH
- * =============================================================================
- */
-
-
-#include <stdio.h>
-
-
-int
-main (int argc, char* argv[])
-{
-    mesh_t* meshPtr;
-
-    assert(argc == 2);
-
-    puts("Starting tests...");
-
-    meshPtr = mesh_alloc();
-    assert(meshPtr);
-
-    mesh_read(meshPtr, argv[1]);
-
-    mesh_free(meshPtr);
-
-    puts("All tests passed.");
-
-    return 0;
-}
-
-
-#endif /* TEST_MESH */
-
-
-/* =============================================================================
- *
- * End of mesh.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/yada/mesh.cpp stamp-g/yada/mesh.cpp
--- stamp-0.9.10/yada/mesh.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-g/yada/mesh.cpp	2017-03-21 18:43:11.000000000 +0000
@@ -0,0 +1,655 @@
+/* =============================================================================
+ *
+ * mesh.c
+ *
+ * =============================================================================
+ *
+ * Copyright (C) Stanford University, 2006.  All Rights Reserved.
+ * Author: Chi Cao Minh
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+
+#include "Galois/gdeque.h"
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "element.h"
+#include "list.h"
+#include "map.h"
+#include "mesh.h"
+#include "queue.h"
+#include "random.h"
+#include "tm.h"
+#include "types.h"
+#include "utility.h"
+
+struct mesh {
+    element_t* rootElementPtr;
+    queue_t* initBadQueuePtr;
+    //long size;
+    //Galois::gdeque<edge_t*> boundarySet;
+};
+
+
+/* =============================================================================
+ * mesh_alloc
+ * =============================================================================
+ */
+mesh_t*
+mesh_alloc ()
+{
+    mesh_t* meshPtr = new mesh_t;
+
+    if (meshPtr) {
+        meshPtr->rootElementPtr = NULL;
+        meshPtr->initBadQueuePtr = queue_alloc(-1);
+        assert(meshPtr->initBadQueuePtr);
+        //meshPtr->size = 0;
+    }
+
+    return meshPtr;
+}
+
+
+/* =============================================================================
+ * mesh_free
+ * =============================================================================
+ */
+void
+mesh_free (mesh_t* meshPtr)
+{
+    queue_free(meshPtr->initBadQueuePtr);
+    delete meshPtr;
+}
+
+/* =============================================================================
+ * mesh_insert
+ * =============================================================================
+ */
+void
+mesh_insert (mesh_t* meshPtr, element_t* elementPtr, MAP_T* edgeMapPtr)
+{
+    /*
+     * Assuming fully connected graph, we just need to record one element.
+     * The root element is not needed for the actual refining, but rather
+     * for checking the validity of the final mesh.
+     */
+    if (!meshPtr->rootElementPtr) {
+        meshPtr->rootElementPtr = elementPtr;
+    }
+
+    /*
+     * Record existence of each of this element's edges
+     */
+    long i;
+    long numEdge = element_getNumEdge(elementPtr);
+    bool onBoundary = false;
+    edge_t* encroachedPtr = element_getEncroachedPtr(elementPtr);
+    for (i = 0; i < numEdge; i++) {
+        pair_t* edgePtr = element_getEdge(elementPtr, i);
+        if (!MAP_CONTAINS(edgeMapPtr, (void*)edgePtr)) {
+            /*
+             * Record existence of this edge
+             */
+            bool_t isSuccess;
+            isSuccess =
+                MAP_INSERT(edgeMapPtr, (void*)edgePtr, (void*)elementPtr);
+            assert(isSuccess);
+        } else {
+            /*
+             * Shared edge; update each element's neighborList
+             */
+            bool_t isSuccess;
+            element_t* sharerPtr = (element_t*)MAP_FIND(edgeMapPtr, edgePtr);
+            assert(sharerPtr); /* cannot be shared by >2 elements */
+            element_addNeighbor(elementPtr, sharerPtr);
+            element_addNeighbor(sharerPtr, elementPtr);
+            if (encroachedPtr && element_getNumEdge(sharerPtr) == 1 && element_getEdge(sharerPtr, 0) == encroachedPtr) {
+                assert(!onBoundary);
+                onBoundary = true;
+            }
+#if 0
+            isSuccess = MAP_REMOVE(edgeMapPtr, edgePtr);
+            assert(isSuccess);
+            isSuccess = MAP_INSERT(edgeMapPtr,
+                                   edgePtr,
+                                   NULL); /* marker to check >2 sharers */
+            assert(isSuccess);
+#endif
+        }
+    }
+
+    /*
+     * Check if really encroached
+     */
+
+    if (encroachedPtr && !onBoundary) {
+        element_clearEncroached(elementPtr);
+    }
+}
+
+
+/* =============================================================================
+ * TMmesh_insert
+ * =============================================================================
+ */
+void
+TMmesh_insert (TM_ARGDECL
+               mesh_t* meshPtr, element_t* elementPtr, tm_edge_map_t* edgeMapPtr)
+{
+    /*
+     * Assuming fully connected graph, we just need to record one element.
+     * The root element is not needed for the actual refining, but rather
+     * for checking the validity of the final mesh.
+     */
+#ifdef HTM
+    if (!meshPtr->rootElementPtr)
+      meshPtr->rootElementPtr = elementPtr;
+#else
+    while (!meshPtr->rootElementPtr) {
+      if (__sync_bool_compare_and_swap(&meshPtr->rootElementPtr, 0, elementPtr))
+        break;
+    }
+#endif
+
+    /*
+     * Record existence of each of this element's edges
+     */
+    long i;
+    long numEdge = element_getNumEdge(elementPtr);
+    bool onBoundary = false;
+    edge_t* encroachedPtr = element_getEncroachedPtr(elementPtr);
+
+    for (i = 0; i < numEdge; i++) {
+        edge_t* edgePtr = element_getEdge(elementPtr, i);
+        if (!edgeMapPtr->containsKey(edgePtr)) {
+            /* Record existance of this edge */
+            bool_t isSuccess;
+            isSuccess =
+                //PMAP_INSERT(edgeMapPtr, (void*)edgePtr, (void*)elementPtr);
+                edgeMapPtr->insert(edgePtr, elementPtr, Galois::MethodFlag::NONE);
+            assert(isSuccess);
+        } else {
+            /*
+             * Shared edge; update each element's neighborList
+             */
+            bool_t isSuccess;
+            element_t* sharerPtr = (element_t*)edgeMapPtr->find(edgePtr, Galois::MethodFlag::NONE);
+            assert(sharerPtr); /* cannot be shared by >2 elements */
+            TMELEMENT_ADDNEIGHBOR(elementPtr, sharerPtr);
+            TMELEMENT_ADDNEIGHBOR(sharerPtr, elementPtr);
+            if (encroachedPtr && element_getNumEdge(sharerPtr) == 1 && element_getEdge(sharerPtr, 0) == encroachedPtr) {
+                assert(!onBoundary);
+                onBoundary = true;
+            }
+#if 0
+            isSuccess = PMAP_REMOVE(edgeMapPtr, edgePtr);
+            isSuccess = PMAP_INSERT(edgeMapPtr, edgePtr, NULL); /* marker to check >2 sharers */
+            assert(isSuccess);
+#endif
+        }
+    }
+
+    /*
+     * Check if really encroached
+     */
+    if (encroachedPtr && !onBoundary) {
+        element_clearEncroached(elementPtr);
+    }
+}
+
+static bool_t list_remove_helper(list_t* p, void* k, long (*compare)(const void*, const void*)) {
+    auto ii = p->begin();
+    auto ei = p->end();
+    while (ii != ei) {
+        if (compare(*ii, k) == 0)
+            break;
+        ++ii;
+    }
+    if (ii == ei)
+        return FALSE;
+
+    std::swap(*ii, p->back());
+    p->pop_back();
+    return TRUE;
+}
+
+void
+mesh_removeNeighbor (mesh_t* meshPtr, element_t* elementPtr, element_t* neighborPtr)
+{
+    list_t* neighborListPtr = element_getNeighborListPtr(elementPtr);
+    bool_t status = list_remove_helper(neighborListPtr, neighborPtr, element_listCompare);
+    assert(status);
+}
+
+/* =============================================================================
+ * TMmesh_remove
+ * =============================================================================
+ */
+void
+TMmesh_remove (TM_ARGDECL  mesh_t* meshPtr, element_t* elementPtr)
+{
+    assert(!TMELEMENT_ISGARBAGE(elementPtr));
+
+    /*
+     * If removing root, a new root is selected on the next mesh_insert, which
+     * always follows a call a mesh_remove.
+     */
+#ifdef HTM
+    if (meshPtr->rootElementPtr == elementPtr)
+      meshPtr->rootElementPtr = 0;
+#else
+    while (meshPtr->rootElementPtr == elementPtr) {
+      if (__sync_bool_compare_and_swap(&meshPtr->rootElementPtr, elementPtr, 0))
+        break;
+    }
+#endif
+
+    /*
+     * Remove from neighbors
+     */
+    list_iter_t it;
+    list_t* neighborListPtr = element_getNeighborListPtr(elementPtr);
+    LIST_ITER_RESET(&it, neighborListPtr);
+    while (LIST_ITER_HASNEXT(&it, neighborListPtr)) {
+        element_t* neighborPtr =
+            (element_t*)LIST_ITER_NEXT(&it, neighborListPtr);
+        list_t* neighborNeighborListPtr = element_getNeighborListPtr(neighborPtr);
+        bool_t status = list_remove_helper(neighborNeighborListPtr, elementPtr, element_listCompare);
+        assert(status);
+    }
+
+    TMELEMENT_SETISGARBAGE(elementPtr, TRUE);
+
+    if (!TMELEMENT_ISREFERENCED(elementPtr)) {
+        TMELEMENT_FREE(elementPtr);
+    }
+}
+
+#if 0
+
+/* =============================================================================
+ * TMmesh_insertBoundary
+ * =============================================================================
+ */
+bool_t
+TMmesh_insertBoundary (TM_ARGDECL  mesh_t* meshPtr, edge_t* boundaryPtr)
+{
+    return tmset_insert(meshPtr->boundarySet, boundaryPtr);
+}
+
+
+/* =============================================================================
+ * TMmesh_removeBoundary
+ * =============================================================================
+ */
+bool_t
+TMmesh_removeBoundary (TM_ARGDECL  mesh_t* meshPtr, edge_t* boundaryPtr)
+{
+    return tmset_remove(meshPtr->boundarySet, boundaryPtr);
+}
+
+#endif
+
+/* =============================================================================
+ * createElement
+ * =============================================================================
+ */
+static void
+createElement (mesh_t* meshPtr,
+               coordinate_t* coordinates,
+               long numCoordinate,
+               MAP_T* edgeMapPtr)
+{
+    element_t* elementPtr = element_alloc(coordinates, numCoordinate);
+    assert(elementPtr);
+
+    if (numCoordinate == 2) {
+#if 0
+        edge_t* boundaryPtr = element_getEdge(elementPtr, 0);
+        bool_t status = SET_INSERT(meshPtr->boundarySetPtr, boundaryPtr);
+        assert(status);
+#endif
+    }
+
+    mesh_insert(meshPtr, elementPtr, edgeMapPtr);
+
+    if (element_isBad(elementPtr)) {
+        bool_t status = queue_push(meshPtr->initBadQueuePtr, (void*)elementPtr);
+        assert(status);
+    }
+ }
+
+
+/* =============================================================================
+ * mesh_read
+ *
+ * Returns number of elements read from file
+ *
+ * Refer to http://www.cs.cmu.edu/~quake/triangle.html for file formats.
+ * =============================================================================
+ */
+long
+mesh_read (mesh_t* meshPtr, char* fileNamePrefix)
+{
+    FILE* inputFile;
+    coordinate_t* coordinates;
+    char fileName[256];
+    long fileNameSize = sizeof(fileName) / sizeof(fileName[0]);
+    char inputBuff[256];
+    long inputBuffSize = sizeof(inputBuff) / sizeof(inputBuff[0]);
+    long numEntry;
+    long numDimension;
+    long numCoordinate;
+    long i;
+    long numElement = 0;
+
+    MAP_T* edgeMapPtr = MAP_ALLOC(&element_mapHashEdge, &element_mapCompareEdge);
+    assert(edgeMapPtr);
+
+    /*
+     * Read .node file
+     */
+    snprintf(fileName, fileNameSize, "%s.node", fileNamePrefix);
+    inputFile = fopen(fileName, "r");
+    assert(inputFile);
+    fgets(inputBuff, inputBuffSize, inputFile);
+    sscanf(inputBuff, "%li %li", &numEntry, &numDimension);
+    assert(numDimension == 2); /* must be 2-D */
+    numCoordinate = numEntry + 1; /* numbering can start from 1 */
+    coordinates = (coordinate_t*)malloc(numCoordinate * sizeof(coordinate_t));
+    assert(coordinates);
+    for (i = 0; i < numEntry; i++) {
+        long id;
+        double x;
+        double y;
+        if (!fgets(inputBuff, inputBuffSize, inputFile)) {
+            break;
+        }
+        if (inputBuff[0] == '#') {
+            continue; /* TODO: handle comments correctly */
+        }
+        sscanf(inputBuff, "%li %lf %lf", &id, &x, &y);
+        coordinates[id].x = x;
+        coordinates[id].y = y;
+    }
+    assert(i == numEntry);
+    fclose(inputFile);
+
+    /*
+     * Read .poly file, which contains boundary segments
+     */
+    snprintf(fileName, fileNameSize, "%s.poly", fileNamePrefix);
+    inputFile = fopen(fileName, "r");
+    assert(inputFile);
+    fgets(inputBuff, inputBuffSize, inputFile);
+    sscanf(inputBuff, "%li %li", &numEntry, &numDimension);
+    assert(numEntry == 0); /* .node file used for vertices */
+    assert(numDimension == 2); /* must be edge */
+    fgets(inputBuff, inputBuffSize, inputFile);
+    sscanf(inputBuff, "%li", &numEntry);
+    for (i = 0; i < numEntry; i++) {
+        long id;
+        long a;
+        long b;
+        coordinate_t insertCoordinates[2];
+        if (!fgets(inputBuff, inputBuffSize, inputFile)) {
+            break;
+        }
+        if (inputBuff[0] == '#') {
+            continue; /* TODO: handle comments correctly */
+        }
+        sscanf(inputBuff, "%li %li %li", &id, &a, &b);
+        assert(a >= 0 && a < numCoordinate);
+        assert(b >= 0 && b < numCoordinate);
+        insertCoordinates[0] = coordinates[a];
+        insertCoordinates[1] = coordinates[b];
+        createElement(meshPtr, insertCoordinates, 2, edgeMapPtr);
+    }
+    assert(i == numEntry);
+    numElement += numEntry;
+    fclose(inputFile);
+
+    /*
+     * Read .ele file, which contains triangles
+     */
+    snprintf(fileName, fileNameSize, "%s.ele", fileNamePrefix);
+    inputFile = fopen(fileName, "r");
+    assert(inputFile);
+    fgets(inputBuff, inputBuffSize, inputFile);
+    sscanf(inputBuff, "%li %li", &numEntry, &numDimension);
+    assert(numDimension == 3); /* must be triangle */
+    for (i = 0; i < numEntry; i++) {
+        long id;
+        long a;
+        long b;
+        long c;
+        coordinate_t insertCoordinates[3];
+        if (!fgets(inputBuff, inputBuffSize, inputFile)) {
+            break;
+        }
+        if (inputBuff[0] == '#') {
+            continue; /* TODO: handle comments correctly */
+        }
+        sscanf(inputBuff, "%li %li %li %li", &id, &a, &b, &c);
+        assert(a >= 0 && a < numCoordinate);
+        assert(b >= 0 && b < numCoordinate);
+        assert(c >= 0 && c < numCoordinate);
+        insertCoordinates[0] = coordinates[a];
+        insertCoordinates[1] = coordinates[b];
+        insertCoordinates[2] = coordinates[c];
+        createElement(meshPtr, insertCoordinates, 3, edgeMapPtr);
+    }
+    assert(i == numEntry);
+    numElement += numEntry;
+    fclose(inputFile);
+
+    free(coordinates);
+    MAP_FREE(edgeMapPtr);
+
+    return numElement;
+}
+
+
+/* =============================================================================
+ * mesh_getBad
+ * -- Returns NULL if none
+ * =============================================================================
+ */
+element_t*
+mesh_getBad (mesh_t* meshPtr)
+{
+    return (element_t*)queue_pop(meshPtr->initBadQueuePtr);
+}
+
+
+/* =============================================================================
+ * mesh_shuffleBad
+ * =============================================================================
+ */
+void
+mesh_shuffleBad (mesh_t* meshPtr, random_t* randomPtr)
+{
+    queue_shuffle(meshPtr->initBadQueuePtr, randomPtr);
+}
+
+
+/* =============================================================================
+ * mesh_check
+ * =============================================================================
+ */
+bool_t
+mesh_check (mesh_t* meshPtr, long expectedNumElement)
+{
+    queue_t* searchQueuePtr;
+    MAP_T* visitedMapPtr;
+    long numBadTriangle = 0;
+    long numFalseNeighbor = 0;
+    long numElement = 0;
+
+    puts("Checking final mesh:");
+    fflush(stdout);
+
+    searchQueuePtr = queue_alloc(-1);
+    assert(searchQueuePtr);
+    visitedMapPtr = MAP_ALLOC(&element_mapHash, &element_mapCompare);
+    assert(visitedMapPtr);
+
+    /*
+     * Do breadth-first search starting from rootElementPtr
+     */
+    assert(meshPtr->rootElementPtr);
+    queue_push(searchQueuePtr, (void*)meshPtr->rootElementPtr);
+    while (!queue_isEmpty(searchQueuePtr)) {
+
+        element_t* currentElementPtr;
+        list_iter_t it;
+        list_t* neighborListPtr;
+        bool_t isSuccess;
+
+        currentElementPtr = (element_t*)queue_pop(searchQueuePtr);
+        if (MAP_CONTAINS(visitedMapPtr, (void*)currentElementPtr)) {
+            continue;
+        }
+        isSuccess = MAP_INSERT(visitedMapPtr, (void*)currentElementPtr, NULL);
+        assert(isSuccess);
+        if (!element_checkAngles(currentElementPtr)) {
+            numBadTriangle++;
+        }
+        neighborListPtr = element_getNeighborListPtr(currentElementPtr);
+
+        list_iter_reset(&it, neighborListPtr);
+        while (list_iter_hasNext(&it, neighborListPtr)) {
+            element_t* neighborElementPtr =
+                (element_t*)list_iter_next(&it, neighborListPtr);
+            /*
+             * Continue breadth-first search
+             */
+            if (!MAP_CONTAINS(visitedMapPtr, (void*)neighborElementPtr)) {
+                bool_t isSuccess;
+                isSuccess = queue_push(searchQueuePtr,
+                                       (void*)neighborElementPtr);
+                assert(isSuccess);
+            }
+        } /* for each neighbor */
+
+        numElement++;
+
+    } /* breadth-first search */
+
+    printf("Number of elements          = %li\n", numElement);
+    printf("Number of expected elements = %li\n", expectedNumElement);
+    printf("Number of bad triangles     = %li\n", numBadTriangle);
+    printf("Number of false neighbors   = %li\n", numFalseNeighbor);
+
+    queue_free(searchQueuePtr);
+    MAP_FREE(visitedMapPtr);
+
+    return ((numBadTriangle > 0 ||
+             numFalseNeighbor > 0 ||
+             numElement != expectedNumElement) ? FALSE : TRUE);
+}
+
+
+#ifdef TEST_MESH
+/* =============================================================================
+ * TEST_MESH
+ * =============================================================================
+ */
+
+
+#include <stdio.h>
+
+
+int
+main (int argc, char* argv[])
+{
+    mesh_t* meshPtr;
+
+    assert(argc == 2);
+
+    puts("Starting tests...");
+
+    meshPtr = mesh_alloc();
+    assert(meshPtr);
+
+    mesh_read(meshPtr, argv[1]);
+
+    mesh_free(meshPtr);
+
+    puts("All tests passed.");
+
+    return 0;
+}
+
+
+#endif /* TEST_MESH */
+
+
+/* =============================================================================
+ *
+ * End of mesh.c
+ *
+ * =============================================================================
+ */
diff -x .git -x inputs -Naur stamp-0.9.10/yada/mesh.h stamp-g/yada/mesh.h
--- stamp-0.9.10/yada/mesh.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/yada/mesh.h	2017-03-20 15:19:41.000000000 +0000
@@ -79,41 +79,82 @@
 #include "tm.h"
 #include "vector.h"
 
-
 typedef struct mesh  mesh_t;
 
+#ifdef __cplusplus
+#include <map>
+
+class TMEdgeMap {
+  struct Comparator {
+    bool operator()(edge_t* a, edge_t* b) const {
+      return element_mapCompareEdge(a, b) < 0;
+    }
+  };
+  typedef std::pair<edge_t*, element_t*> MapPair;
+  typedef Galois::PerIterAllocTy::rebind<MapPair>::other MapAllocator;
+
+  typedef std::map<edge_t*,element_t*,Comparator,MapAllocator> Map;
+  Map map;
+
+public:
+  TMEdgeMap(const Galois::PerIterAllocTy& a): map(Comparator(), a) { }
+
+  bool containsKey(edge_t* key, Galois::MethodFlag = Galois::MethodFlag::ALL) const {
+    return map.find(key) != map.end();
+  }
+
+  bool insert(edge_t* key, element_t* value, Galois::MethodFlag = Galois::MethodFlag::ALL) {
+    return map.insert(Map::value_type(key, value)).second;
+  }
+
+  element_t* find(edge_t* key, Galois::MethodFlag = Galois::MethodFlag::ALL) {
+    Map::iterator ii = map.find(key);
+    if (ii != map.end())
+      return ii->second;
+    return NULL;
+  }
+};
+
+
+typedef hash_rbtree_map<void*,void*,Galois::PerIterAllocTy> edge_map_t;
+typedef TMEdgeMap tm_edge_map_t;
+//typedef edge_map_t tm_edge_map_t;
 
 /* =============================================================================
- * mesh_alloc
+ * mesh_insert
  * =============================================================================
  */
-mesh_t*
-mesh_alloc ();
+void
+mesh_insert (mesh_t* meshPtr, element_t* elementPtr, edge_map_t* edgeMapPtr);
 
 
 /* =============================================================================
- * mesh_free
+ * TMmesh_insert
  * =============================================================================
  */
 void
-mesh_free (mesh_t* meshPtr);
+TMmesh_insert (TM_ARGDECL
+               mesh_t* meshPtr, element_t* elementPtr, tm_edge_map_t* edgeMapPtr);
+
 
+extern "C" {
+#endif
 
 /* =============================================================================
- * mesh_insert
+ * mesh_alloc
  * =============================================================================
  */
-void
-mesh_insert (mesh_t* meshPtr, element_t* elementPtr, MAP_T* edgeMapPtr);
+mesh_t*
+mesh_alloc ();
 
 
 /* =============================================================================
- * TMmesh_insert
+ * mesh_free
  * =============================================================================
  */
 void
-TMmesh_insert (TM_ARGDECL
-               mesh_t* meshPtr, element_t* elementPtr, MAP_T* edgeMapPtr);
+mesh_free (mesh_t* meshPtr);
+
 
 
 /* =============================================================================
@@ -124,6 +165,9 @@
 void
 TMmesh_remove (TM_ARGDECL  mesh_t* meshPtr, element_t* elementPtr);
 
+void
+mesh_removeNeighbor (mesh_t* meshPtr, element_t* elementPtr, element_t* neighborPtr);
+
 
 /* =============================================================================
  * TMmesh_insertBoundary
@@ -183,6 +227,9 @@
 #define TMMESH_INSERTBOUNDARY(m, b)     TMmesh_insertBoundary(TM_ARG  m, b)
 #define TMMESH_REMOVEBOUNDARY(m, b)     TMmesh_removeBoundary(TM_ARG  m, b)
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* MESH_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/yada/region.c stamp-g/yada/region.c
--- stamp-0.9.10/yada/region.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/yada/region.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,421 +0,0 @@
-/* =============================================================================
- *
- * region.c
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <stdlib.h>
-#include "region.h"
-#include "coordinate.h"
-#include "element.h"
-#include "list.h"
-#include "map.h"
-#include "queue.h"
-#include "mesh.h"
-#include "tm.h"
-
-
-struct region {
-    coordinate_t centerCoordinate;
-    queue_t* expandQueuePtr;
-    list_t* beforeListPtr; /* before retriangulation; list to avoid duplicates */
-    list_t* borderListPtr; /* edges adjacent to region; list to avoid duplicates */
-    vector_t* badVectorPtr;
-};
-
-
-/* =============================================================================
- * Pregion_alloc
- * =============================================================================
- */
-region_t*
-Pregion_alloc ()
-{
-    region_t* regionPtr;
-
-    regionPtr = (region_t*)P_MALLOC(sizeof(region_t));
-    if (regionPtr) {
-        regionPtr->expandQueuePtr = PQUEUE_ALLOC(-1);
-        assert(regionPtr->expandQueuePtr);
-        regionPtr->beforeListPtr = PLIST_ALLOC(&element_listCompare);
-        assert(regionPtr->beforeListPtr);
-        regionPtr->borderListPtr = PLIST_ALLOC(&element_listCompareEdge);
-        assert(regionPtr->borderListPtr);
-        regionPtr->badVectorPtr = PVECTOR_ALLOC(1);
-        assert(regionPtr->badVectorPtr);
-    }
-
-    return regionPtr;
-}
-
-
-/* =============================================================================
- * Pregion_free
- * =============================================================================
- */
-void
-Pregion_free (region_t* regionPtr)
-{
-    PVECTOR_FREE(regionPtr->badVectorPtr);
-    PLIST_FREE(regionPtr->borderListPtr);
-    PLIST_FREE(regionPtr->beforeListPtr);
-    PQUEUE_FREE(regionPtr->expandQueuePtr);
-    P_FREE(regionPtr);
-}
-
-
-/* =============================================================================
- * TMaddToBadVector
- * =============================================================================
- */
-void
-TMaddToBadVector (TM_ARGDECL  vector_t* badVectorPtr, element_t* badElementPtr)
-{
-    bool_t status = PVECTOR_PUSHBACK(badVectorPtr, (void*)badElementPtr);
-    assert(status);
-    TMELEMENT_SETISREFERENCED(badElementPtr, TRUE);
-}
-
-
-/* =============================================================================
- * TMretriangulate
- * -- Returns net amount of elements added to mesh
- * =============================================================================
- */
-long
-TMretriangulate (TM_ARGDECL
-                 element_t* elementPtr,
-                 region_t* regionPtr,
-                 mesh_t* meshPtr,
-                 MAP_T* edgeMapPtr)
-{
-    vector_t* badVectorPtr = regionPtr->badVectorPtr; /* private */
-    list_t* beforeListPtr = regionPtr->beforeListPtr; /* private */
-    list_t* borderListPtr = regionPtr->borderListPtr; /* private */
-    list_iter_t it;
-    long numDelta = 0L;
-
-    assert(edgeMapPtr);
-
-    coordinate_t centerCoordinate = element_getNewPoint(elementPtr);
-
-    /*
-     * Remove the old triangles
-     */
-
-    list_iter_reset(&it, beforeListPtr);
-    while (list_iter_hasNext(&it, beforeListPtr)) {
-        element_t* beforeElementPtr =
-            (element_t*)list_iter_next(&it, beforeListPtr);
-        TMMESH_REMOVE(meshPtr, beforeElementPtr);
-    }
-
-    numDelta -= PLIST_GETSIZE(beforeListPtr);
-
-    /*
-     * If segment is encroached, split it in half
-     */
-
-    if (element_getNumEdge(elementPtr) == 1) {
-
-        coordinate_t coordinates[2];
-
-        edge_t* edgePtr = element_getEdge(elementPtr, 0);
-        coordinates[0] = centerCoordinate;
-
-        coordinates[1] = *(coordinate_t*)(edgePtr->firstPtr);
-        element_t* aElementPtr = TMELEMENT_ALLOC(coordinates, 2);
-        assert(aElementPtr);
-        TMMESH_INSERT(meshPtr, aElementPtr, edgeMapPtr);
-
-        coordinates[1] = *(coordinate_t*)(edgePtr->secondPtr);
-        element_t* bElementPtr = TMELEMENT_ALLOC(coordinates, 2);
-        assert(bElementPtr);
-        TMMESH_INSERT(meshPtr, bElementPtr, edgeMapPtr);
-
-        bool_t status;
-        status = TMMESH_REMOVEBOUNDARY(meshPtr, element_getEdge(elementPtr, 0));
-        assert(status);
-        status = TMMESH_INSERTBOUNDARY(meshPtr, element_getEdge(aElementPtr, 0));
-        assert(status);
-        status = TMMESH_INSERTBOUNDARY(meshPtr, element_getEdge(bElementPtr, 0));
-        assert(status);
-
-        numDelta += 2;
-    }
-
-    /*
-     * Insert the new triangles. These are contructed using the new
-     * point and the two points from the border segment.
-     */
-
-    list_iter_reset(&it, borderListPtr);
-    while (list_iter_hasNext(&it, borderListPtr)) {
-        element_t* afterElementPtr;
-        coordinate_t coordinates[3];
-        edge_t* borderEdgePtr = (edge_t*)list_iter_next(&it, borderListPtr);
-        assert(borderEdgePtr);
-        coordinates[0] = centerCoordinate;
-        coordinates[1] = *(coordinate_t*)(borderEdgePtr->firstPtr);
-        coordinates[2] = *(coordinate_t*)(borderEdgePtr->secondPtr);
-        afterElementPtr = TMELEMENT_ALLOC(coordinates, 3);
-        assert(afterElementPtr);
-        TMMESH_INSERT(meshPtr, afterElementPtr, edgeMapPtr);
-        if (element_isBad(afterElementPtr)) {
-            TMaddToBadVector(TM_ARG  badVectorPtr, afterElementPtr);
-        }
-    }
-
-    numDelta += PLIST_GETSIZE(borderListPtr);
-
-    assert(numDelta > 0);
-
-    return numDelta;
-}
-
-
-/* =============================================================================
- * TMgrowRegion
- * -- Return NULL if success, else pointer to encroached boundary
- * =============================================================================
- */
-element_t*
-TMgrowRegion (TM_ARGDECL
-              element_t* centerElementPtr,
-              region_t* regionPtr,
-              mesh_t* meshPtr,
-              MAP_T* edgeMapPtr)
-{
-    bool_t isBoundary = FALSE;
-
-    if (element_getNumEdge(centerElementPtr) == 1) {
-        isBoundary = TRUE;
-    }
-
-    list_t* beforeListPtr = regionPtr->beforeListPtr;
-    list_t* borderListPtr = regionPtr->borderListPtr;
-    queue_t* expandQueuePtr = regionPtr->expandQueuePtr;
-
-    PLIST_CLEAR(beforeListPtr);
-    PLIST_CLEAR(borderListPtr);
-    PQUEUE_CLEAR(expandQueuePtr);
-
-    coordinate_t centerCoordinate = element_getNewPoint(centerElementPtr);
-    coordinate_t* centerCoordinatePtr = &centerCoordinate;
-
-    PQUEUE_PUSH(expandQueuePtr, (void*)centerElementPtr);
-    while (!PQUEUE_ISEMPTY(expandQueuePtr)) {
-
-        element_t* currentElementPtr = (element_t*)PQUEUE_POP(expandQueuePtr);
-
-        PLIST_INSERT(beforeListPtr, (void*)currentElementPtr); /* no duplicates */
-        list_t* neighborListPtr = element_getNeighborListPtr(currentElementPtr);
-        assert(TMLIST_GETSIZE(neighborListPtr) > 0);
-
-        list_iter_t it;
-        TMLIST_ITER_RESET(&it, neighborListPtr);
-        while (TMLIST_ITER_HASNEXT(&it, neighborListPtr)) {
-            element_t* neighborElementPtr =
-                (element_t*)TMLIST_ITER_NEXT(&it, neighborListPtr);
-            TMELEMENT_ISGARBAGE(neighborElementPtr); /* so we can detect conflicts */
-            if (!list_find(beforeListPtr, (void*)neighborElementPtr)) {
-                if (element_isInCircumCircle(neighborElementPtr, centerCoordinatePtr)) {
-                    /* This is part of the region */
-                    if (!isBoundary && (element_getNumEdge(neighborElementPtr) == 1)) {
-                        /* Encroached on mesh boundary so split it and restart */
-                        return neighborElementPtr;
-                    } else {
-                        /* Continue breadth-first search */
-                        bool_t isSuccess;
-                        isSuccess = PQUEUE_PUSH(expandQueuePtr,
-                                                (void*)neighborElementPtr);
-                        assert(isSuccess);
-                    }
-                } else {
-                    /* This element borders region; save info for retriangulation */
-                    edge_t* borderEdgePtr =
-                        element_getCommonEdge(neighborElementPtr, currentElementPtr);
-                    if (!borderEdgePtr) {
-                        TM_RESTART();
-                    }
-                    PLIST_INSERT(borderListPtr,
-                                 (void*)borderEdgePtr); /* no duplicates */
-                    if (!MAP_CONTAINS(edgeMapPtr, borderEdgePtr)) {
-                        PMAP_INSERT(edgeMapPtr, borderEdgePtr, neighborElementPtr);
-                    }
-                }
-            } /* not visited before */
-        } /* for each neighbor */
-
-    } /* breadth-first search */
-
-    return NULL;
-}
-
-
-/* =============================================================================
- * TMregion_refine
- * -- Returns net number of elements added to mesh
- * =============================================================================
- */
-long
-TMregion_refine (TM_ARGDECL
-                 region_t* regionPtr, element_t* elementPtr, mesh_t* meshPtr)
-{
-
-    long numDelta = 0L;
-    MAP_T* edgeMapPtr = NULL;
-    element_t* encroachElementPtr = NULL;
-
-    TMELEMENT_ISGARBAGE(elementPtr); /* so we can detect conflicts */
-
-    while (1) {
-        edgeMapPtr = PMAP_ALLOC(NULL, &element_mapCompareEdge);
-        assert(edgeMapPtr);
-        encroachElementPtr = TMgrowRegion(TM_ARG
-                                          elementPtr,
-                                          regionPtr,
-                                          meshPtr,
-                                          edgeMapPtr);
-
-        if (encroachElementPtr) {
-            TMELEMENT_SETISREFERENCED(encroachElementPtr, TRUE);
-            numDelta += TMregion_refine(TM_ARG
-                                        regionPtr,
-                                        encroachElementPtr,
-                                        meshPtr);
-            if (TMELEMENT_ISGARBAGE(elementPtr)) {
-                break;
-            }
-        } else {
-            break;
-        }
-        PMAP_FREE(edgeMapPtr);
-    }
-
-    /*
-     * Perform retriangulation.
-     */
-
-    if (!TMELEMENT_ISGARBAGE(elementPtr)) {
-        numDelta += TMretriangulate(TM_ARG
-                                    elementPtr,
-                                    regionPtr,
-                                    meshPtr,
-                                    edgeMapPtr);
-    }
-
-    PMAP_FREE(edgeMapPtr); /* no need to free elements */
-
-    //assert(numDelta > 0);
-
-    return numDelta;
-}
-
-
-/* =============================================================================
- * Pregion_clearBad
- * =============================================================================
- */
-void
-Pregion_clearBad (region_t* regionPtr)
-{
-    PVECTOR_CLEAR(regionPtr->badVectorPtr);
-}
-
-
-/* =============================================================================
- * TMregion_transferBad
- * =============================================================================
- */
-void
-TMregion_transferBad (TM_ARGDECL  region_t* regionPtr, heap_t* workHeapPtr)
-{
-    vector_t* badVectorPtr = regionPtr->badVectorPtr;
-    long numBad = PVECTOR_GETSIZE(badVectorPtr);
-    long i;
-
-    for (i = 0; i < numBad; i++) {
-        element_t* badElementPtr = (element_t*)vector_at(badVectorPtr, i);
-        if (TMELEMENT_ISGARBAGE(badElementPtr)) {
-            TMELEMENT_FREE(badElementPtr);
-        } else {
-            bool_t status = TMHEAP_INSERT(workHeapPtr, (void*)badElementPtr);
-            assert(status);
-        }
-    }
-}
-
-
-/* =============================================================================
- *
- * End of region.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/yada/region.cpp stamp-g/yada/region.cpp
--- stamp-0.9.10/yada/region.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-g/yada/region.cpp	2017-03-21 18:45:28.000000000 +0000
@@ -0,0 +1,445 @@
+/* =============================================================================
+ *
+ * region.c
+ *
+ * =============================================================================
+ *
+ * Copyright (C) Stanford University, 2006.  All Rights Reserved.
+ * Author: Chi Cao Minh
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+
+
+#include <assert.h>
+#include <stdlib.h>
+#include "region.h"
+#include "coordinate.h"
+#include "element.h"
+#include "list.h"
+#include "map.h"
+#include "queue.h"
+#include "mesh.h"
+#include "tm.h"
+
+
+
+/* =============================================================================
+ * Pregion_alloc
+ * =============================================================================
+ */
+#if 0
+region_t*
+Pregion_alloc ()
+{
+    region_t* regionPtr;
+
+    regionPtr = (region_t*)P_MALLOC(sizeof(region_t));
+    if (regionPtr) {
+        regionPtr->expandQueuePtr = PQUEUE_ALLOC(-1);
+        assert(regionPtr->expandQueuePtr);
+        regionPtr->beforeListPtr = PLIST_ALLOC(&element_listCompare);
+        assert(regionPtr->beforeListPtr);
+        regionPtr->borderListPtr = PLIST_ALLOC(&element_listCompareEdge);
+        assert(regionPtr->borderListPtr);
+        regionPtr->badVectorPtr = PVECTOR_ALLOC(1);
+        assert(regionPtr->badVectorPtr);
+    }
+
+    return regionPtr;
+}
+
+
+/* =============================================================================
+ * Pregion_free
+ * =============================================================================
+ */
+void
+Pregion_free (region_t* regionPtr)
+{
+    PVECTOR_FREE(regionPtr->badVectorPtr);
+    PLIST_FREE(regionPtr->borderListPtr);
+    PLIST_FREE(regionPtr->beforeListPtr);
+    PQUEUE_FREE(regionPtr->expandQueuePtr);
+    P_FREE(regionPtr);
+}
+#endif
+
+/* =============================================================================
+ * TMaddToBadVector
+ * =============================================================================
+ */
+void
+TMaddToBadVector (TM_ARGDECL  vector_t* badVectorPtr, element_t* badElementPtr)
+{
+    bool_t status = PVECTOR_PUSHBACK(badVectorPtr, (void*)badElementPtr);
+    assert(status);
+    TMELEMENT_SETISREFERENCED(badElementPtr, TRUE);
+}
+
+
+/* =============================================================================
+ * TMretriangulate
+ * -- Returns net amount of elements added to mesh
+ * =============================================================================
+ */
+long
+TMretriangulate (TM_ARGDECL
+                 element_t* elementPtr,
+                 region_t* regionPtr,
+                 mesh_t* meshPtr,
+                 tm_edge_map_t* edgeMapPtr,
+                 Galois::InsertBag<element_t>& alloc,
+                 RefineLog& refineLog
+                 )
+{
+    vector_t* badVectorPtr = &regionPtr->badVector; /* private */
+    list_t* beforeListPtr = &regionPtr->beforeList; /* private */
+    list_t* borderListPtr = &regionPtr->borderList; /* private */
+    list_iter_t it;
+    long numDelta = 0L;
+
+    assert(edgeMapPtr);
+
+    coordinate_t centerCoordinate = element_getNewPoint(elementPtr);
+
+    /*
+     * Remove the old triangles
+     */
+
+    list_iter_reset(&it, beforeListPtr);
+    while (list_iter_hasNext(&it, beforeListPtr)) {
+        element_t* beforeElementPtr =
+            (element_t*)list_iter_next(&it, beforeListPtr);
+        refineLog.meshRemove(meshPtr, beforeElementPtr);
+    }
+
+    numDelta -= PLIST_GETSIZE(beforeListPtr);
+
+    /*
+     * If segment is encroached, split it in half
+     */
+
+    if (element_getNumEdge(elementPtr) == 1) {
+
+        coordinate_t coordinates[2];
+
+        edge_t* edgePtr = element_getEdge(elementPtr, 0);
+        coordinates[0] = centerCoordinate;
+
+        coordinates[1] = *(coordinate_t*)(edgePtr->firstPtr);
+        element_t* aElementPtr = TMELEMENT_ALLOC(coordinates, 2, alloc);
+        assert(aElementPtr);
+        refineLog.meshInsert(meshPtr, aElementPtr, edgeMapPtr);
+
+        coordinates[1] = *(coordinate_t*)(edgePtr->secondPtr);
+        element_t* bElementPtr = TMELEMENT_ALLOC(coordinates, 2, alloc);
+        assert(bElementPtr);
+        refineLog.meshInsert(meshPtr, bElementPtr, edgeMapPtr);
+
+#if 0
+        bool_t status;
+        status = TMMESH_REMOVEBOUNDARY(meshPtr, element_getEdge(elementPtr, 0));
+        assert(status);
+        status = TMMESH_INSERTBOUNDARY(meshPtr, element_getEdge(aElementPtr, 0));
+        assert(status);
+        status = TMMESH_INSERTBOUNDARY(meshPtr, element_getEdge(bElementPtr, 0));
+        assert(status);
+#endif
+        numDelta += 2;
+    }
+
+    /*
+     * Insert the new triangles. These are contructed using the new
+     * point and the two points from the border segment.
+     */
+
+    list_iter_reset(&it, borderListPtr);
+    while (list_iter_hasNext(&it, borderListPtr)) {
+        element_t* afterElementPtr;
+        coordinate_t coordinates[3];
+        edge_t* borderEdgePtr = (edge_t*)list_iter_next(&it, borderListPtr);
+        assert(borderEdgePtr);
+        coordinates[0] = centerCoordinate;
+        coordinates[1] = *(coordinate_t*)(borderEdgePtr->firstPtr);
+        coordinates[2] = *(coordinate_t*)(borderEdgePtr->secondPtr);
+        afterElementPtr = TMELEMENT_ALLOC(coordinates, 3, alloc);
+        assert(afterElementPtr);
+        refineLog.meshInsert(meshPtr, afterElementPtr, edgeMapPtr);
+        if (element_isBad(afterElementPtr)) {
+            TMaddToBadVector(TM_ARG  badVectorPtr, afterElementPtr);
+        }
+    }
+
+    numDelta += PLIST_GETSIZE(borderListPtr);
+
+    //assert(numDelta >= 0);
+
+    return numDelta;
+}
+
+
+bool list_find_helper(list_t *l, void* k, long (*compare)(const void*, const void*)) {
+    auto ii = l->begin();
+    auto ei = l->end();
+    while (ii != ei) {
+        if (compare(*ii, k) == 0)
+            return true;
+        ++ii;
+    }
+    return false;
+}
+
+/* =============================================================================
+ * TMgrowRegion
+ * -- Return NULL if success, else pointer to encroached boundary
+ * =============================================================================
+ */
+element_t*
+TMgrowRegion (TM_ARGDECL
+              element_t* centerElementPtr,
+              region_t* regionPtr,
+              mesh_t* meshPtr,
+              tm_edge_map_t* edgeMapPtr)
+{
+    bool_t isBoundary = FALSE;
+
+    if (element_getNumEdge(centerElementPtr) == 1) {
+        isBoundary = TRUE;
+    }
+
+    list_t* beforeListPtr = &regionPtr->beforeList;
+    list_t* borderListPtr = &regionPtr->borderList;
+    queue_t* expandQueuePtr = &regionPtr->expandQueue;
+
+    PLIST_CLEAR(beforeListPtr);
+    PLIST_CLEAR(borderListPtr);
+    PQUEUE_CLEAR(expandQueuePtr);
+
+    coordinate_t centerCoordinate = element_getNewPoint(centerElementPtr); // XXX
+    coordinate_t* centerCoordinatePtr = &centerCoordinate;
+
+    PQUEUE_PUSH(expandQueuePtr, (void*)centerElementPtr);
+    while (!PQUEUE_ISEMPTY(expandQueuePtr)) {
+
+        element_t* currentElementPtr = (element_t*)PQUEUE_POP(expandQueuePtr);
+        currentElementPtr->acquire();
+
+        PLIST_INSERT(beforeListPtr, (void*)currentElementPtr); /* no duplicates */
+        list_t* neighborListPtr = element_getNeighborListPtr(currentElementPtr);
+        assert(neighborListPtr->size() > 0);
+
+        {
+            list_iter_t it;
+            LIST_ITER_RESET(&it, neighborListPtr);
+            while (LIST_ITER_HASNEXT(&it, neighborListPtr)) {
+                element_t* neighborElementPtr = (element_t*)LIST_ITER_NEXT(&it, neighborListPtr);
+                neighborElementPtr->acquire();
+            }
+        }
+
+        list_iter_t it;
+        LIST_ITER_RESET(&it, neighborListPtr);
+        while (LIST_ITER_HASNEXT(&it, neighborListPtr)) {
+            element_t* neighborElementPtr =
+                (element_t*)LIST_ITER_NEXT(&it, neighborListPtr);
+            TMELEMENT_ISGARBAGE(neighborElementPtr); /* so we can detect conflicts */
+            if (!list_find_helper(beforeListPtr, (void*)neighborElementPtr, element_listCompare)) {
+                if (element_isInCircumCircle(neighborElementPtr, centerCoordinatePtr)) {
+                    /* This is part of the region */
+                    if (!isBoundary && (element_getNumEdge(neighborElementPtr) == 1)) {
+                        /* Encroached on mesh boundary so split it and restart */
+                        return neighborElementPtr;
+                    } else {
+                        /* Continue breadth-first search */
+                        bool_t isSuccess;
+                        isSuccess = PQUEUE_PUSH(expandQueuePtr,
+                                                (void*)neighborElementPtr);
+                        assert(isSuccess);
+                    }
+                } else {
+                    /* This element borders region; save info for retriangulation */
+                    edge_t* borderEdgePtr =
+                        element_getCommonEdge(neighborElementPtr, currentElementPtr);
+                    if (!borderEdgePtr) {
+                        TM_RESTART();
+                    }
+                    PLIST_INSERT(borderListPtr,
+                                 (void*)borderEdgePtr); /* no duplicates */
+                    if (!edgeMapPtr->containsKey(borderEdgePtr)) {
+                        //PMAP_INSERT(edgeMapPtr, borderEdgePtr, neighborElementPtr);
+                        edgeMapPtr->insert(borderEdgePtr, neighborElementPtr, Galois::MethodFlag::NONE);
+                    }
+                }
+            } /* not visited before */
+        } /* for each neighbor */
+
+    } /* breadth-first search */
+
+    return NULL;
+}
+
+
+/* =============================================================================
+ * TMregion_refine
+ * -- Returns net number of elements added to mesh
+ * =============================================================================
+ */
+long
+TMregion_refine (TM_ARGDECL
+                 region_t* regionPtr, element_t* elementPtr, mesh_t* meshPtr,
+                 Galois::InsertBag<element_t>& alloc, Galois::PerIterAllocTy& perIterAlloc,
+                 RefineLog& refineLog)
+{
+
+    long numDelta = 0L;
+    element_t* encroachElementPtr = NULL;
+
+    elementPtr->acquire();
+    TMELEMENT_ISGARBAGE(elementPtr); /* so we can detect conflicts */
+
+    while (1) {
+        //tm_edge_map_t edgeMap(0, &element_mapHashEdge, &element_mapCompareEdge, perIterAlloc);
+        tm_edge_map_t edgeMap(perIterAlloc);
+        encroachElementPtr = TMgrowRegion(TM_ARG
+                                          elementPtr,
+                                          regionPtr,
+                                          meshPtr,
+                                          &edgeMap);
+        bool isDone = false;
+        if (encroachElementPtr) {
+            refineLog.setIsReferenced(encroachElementPtr, TRUE);
+            numDelta += TMregion_refine(TM_ARG
+                                        regionPtr,
+                                        encroachElementPtr,
+                                        meshPtr, alloc, perIterAlloc, refineLog);
+            if (TMELEMENT_ISGARBAGE(elementPtr)) {
+                isDone = true; //break;
+            }
+        } else {
+            isDone = true; //break;
+        }
+        if (isDone) {
+            if (!TMELEMENT_ISGARBAGE(elementPtr)) {
+                numDelta += TMretriangulate(TM_ARG
+                                            elementPtr,
+                                            regionPtr,
+                                            meshPtr,
+                                            &edgeMap,
+                                            alloc,
+                                            refineLog);
+            }
+
+            break;
+        }
+    }
+
+    /*
+     * Perform retriangulation.
+     */
+
+    //assert(numDelta >= 0);
+    return numDelta;
+}
+
+
+/* =============================================================================
+ * Pregion_clearBad
+ * =============================================================================
+ */
+void
+Pregion_clearBad (region_t* regionPtr)
+{
+    PVECTOR_CLEAR(&regionPtr->badVector);
+}
+
+
+/* =============================================================================
+ * TMregion_transferBad
+ * =============================================================================
+ */
+void
+TMregion_transferBad (TM_ARGDECL  region_t* regionPtr, Galois::UserContext<void*>& ctx)
+{
+    vector_t* badVectorPtr = &regionPtr->badVector;
+    //long numBad = PVECTOR_GETSIZE(badVectorPtr);
+    long i;
+    list_iter_t it;
+    list_iter_reset(&it, badVectorPtr);
+    for (i = 0; list_iter_hasNext(&it, badVectorPtr)/*i < numBad*/; i++) {
+        element_t* badElementPtr = (element_t*)list_iter_next(&it, badVectorPtr);//vector_at(badVectorPtr, i);
+        if (TMELEMENT_ISGARBAGE(badElementPtr)) {
+            TMELEMENT_FREE(badElementPtr);
+        } else {
+            //bool_t status = TMHEAP_INSERT(workHeapPtr, (void*)badElementPtr);
+            ctx.push((void*)badElementPtr);
+            //assert(status);
+        }
+    }
+}
+
+
+/* =============================================================================
+ *
+ * End of region.c
+ *
+ * =============================================================================
+ */
diff -x .git -x inputs -Naur stamp-0.9.10/yada/region.h stamp-g/yada/region.h
--- stamp-0.9.10/yada/region.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/yada/region.h	2017-03-21 18:39:08.000000000 +0000
@@ -74,13 +74,16 @@
 
 
 #include "element.h"
-#include "heap.h"
+#include "queue.h"
 #include "mesh.h"
 #include "tm.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef struct region  region_t;
-
+typedef vector_t heap_t;
 
 /* =============================================================================
  * Pregion_alloc
@@ -98,6 +101,138 @@
 Pregion_free (region_t* regionPtr);
 
 
+
+/* =============================================================================
+ * Pregion_clearBad
+ * =============================================================================
+ */
+void
+Pregion_clearBad (region_t* regionPtr);
+
+
+#define PREGION_ALLOC()                 Pregion_alloc()
+#define PREGION_FREE(r)                 Pregion_free(r)
+#define PREGION_CLEARBAD(r)             Pregion_clearBad(r)
+#define TMREGION_REFINE(r, e, m, a, p, l)        TMregion_refine(TM_ARG  r, e, m, a, p, l)
+#define TMREGION_TRANSFERBAD(r, q)      TMregion_transferBad(TM_ARG  r, q)
+
+#ifdef __cplusplus
+}
+
+struct region {
+    coordinate_t centerCoordinate;
+    queue_t expandQueue;
+    list_t beforeList; /* before retriangulation; list to avoid duplicates */
+    list_t borderList; /* edges adjacent to region; list to avoid duplicates */
+    vector_t badVector;
+    
+    region(): beforeList(&element_listCompare), borderList(&element_listCompareEdge) { }
+};
+
+#ifdef HTM
+struct RefineLog: private boost::noncopyable {
+    RefineLog(const Galois::PerIterAllocTy& a) { }
+
+    void setIsReferenced(element_t* p, long v) {
+        element_setIsReferenced(p, v);
+    }
+
+    void meshRemove(mesh_t* mesh, element_t* element) {
+        TMMESH_REMOVE(mesh, element);
+    }
+
+    void meshInsert(mesh_t* mesh, element_t* element, tm_edge_map_t* edgeMap) {
+        TMMESH_INSERT(mesh, element, edgeMap);
+    }
+
+    void clear() { }
+};
+
+#else
+struct RefineLog: private boost::noncopyable, public Galois::Runtime::Releasable {
+    enum Kind {
+        SET_REFERENCED,
+        SET_GARBAGE,
+        ADD_NEIGHBOR,
+        REMOVE_NEIGHBOR
+    };
+
+    struct Op {
+        typedef int tt_has_known_trivial_constructor;
+        Kind kind;
+        element_t* e;
+        long value;
+        element_t* other;
+    };
+
+    typedef Galois::PerIterAllocTy::rebind<Op>::other DequeAllocator;
+    std::deque<Op, DequeAllocator> ops;
+
+    RefineLog(const Galois::PerIterAllocTy& a): ops(a) { }
+
+    virtual ~RefineLog() { cleanup(); }
+
+    virtual void release() { cleanup(); }
+
+    void cleanup() {
+        while (!ops.empty()) {
+            Op& op = ops.back();
+            switch (op.kind) {
+                case SET_REFERENCED: element_setIsReferenced(op.e, op.value); break;
+                case ADD_NEIGHBOR: element_addNeighbor(op.e, op.other); break;
+                case SET_GARBAGE: element_setIsGarbage(op.e, op.value); break;
+                case REMOVE_NEIGHBOR: mesh_removeNeighbor(0, op.e, op.other); break;
+                default: abort();
+            }
+            ops.pop_back();
+        }
+    }
+
+    void setIsReferenced(element_t* p, long v) {
+        Op op = { SET_REFERENCED, p, element_isReferenced(p), 0 };
+        element_setIsReferenced(p, v);
+        ops.push_back(op);
+    }
+
+    void meshRemove(mesh_t* mesh, element_t* element) {
+        list_iter_t it;
+        list_t* neighborListPtr = element_getNeighborListPtr(element);
+        LIST_ITER_RESET(&it, neighborListPtr);
+        while (LIST_ITER_HASNEXT(&it, neighborListPtr)) {
+            element_t* neighborPtr = (element_t*)LIST_ITER_NEXT(&it, neighborListPtr);
+            Op op = { ADD_NEIGHBOR, neighborPtr, 0, element };
+            ops.push_back(op);
+        }
+        assert(!element_isGarbage(element));
+
+        Op op = { SET_GARBAGE, element, element_isGarbage(element), 0 };
+
+        TMMESH_REMOVE(mesh, element);
+
+        ops.push_back(op);
+    }
+
+    void meshInsert(mesh_t* mesh, element_t* element, tm_edge_map_t* edgeMap) {
+        TMMESH_INSERT(mesh, element, edgeMap);
+
+        list_iter_t it;
+        list_t* neighborListPtr = element_getNeighborListPtr(element);
+        LIST_ITER_RESET(&it, neighborListPtr);
+        while (LIST_ITER_HASNEXT(&it, neighborListPtr)) {
+            element_t* neighborPtr = (element_t*)LIST_ITER_NEXT(&it, neighborListPtr);
+            Op op = { REMOVE_NEIGHBOR, neighborPtr, 0, element };
+            ops.push_back(op);
+        }
+        Op op = { SET_GARBAGE, element, TRUE, 0 };
+        ops.push_back(op);
+    }
+
+    void clear() {
+        ops.clear();
+    }
+};
+#endif
+
 /* =============================================================================
  * TMregion_refine
  *
@@ -111,31 +246,19 @@
  */
 long
 TMregion_refine (TM_ARGDECL
-                 region_t* regionPtr, element_t* elementPtr, mesh_t* meshPtr);
-
-
-/* =============================================================================
- * Pregion_clearBad
- * =============================================================================
- */
-void
-Pregion_clearBad (region_t* regionPtr);
-
+                 region_t* regionPtr, element_t* elementPtr, mesh_t* meshPtr,
+                 Galois::InsertBag<element_t>&, Galois::PerIterAllocTy&,
+                 RefineLog& refineLog);
 
 /* =============================================================================
  * TMregion_transferBad
  * =============================================================================
  */
 void
-TMregion_transferBad (TM_ARGDECL  region_t* regionPtr, heap_t* workHeapPtr);
+TMregion_transferBad (TM_ARGDECL  region_t* regionPtr, Galois::UserContext<void*>&);
 
 
-#define PREGION_ALLOC()                 Pregion_alloc()
-#define PREGION_FREE(r)                 Pregion_free(r)
-#define PREGION_CLEARBAD(r)             Pregion_clearBad(r)
-#define TMREGION_REFINE(r, e, m)        TMregion_refine(TM_ARG  r, e, m)
-#define TMREGION_TRANSFERBAD(r, q)      TMregion_transferBad(TM_ARG  r, q)
-
+#endif
 
 #endif /* REGION_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/yada/yada.c stamp-g/yada/yada.c
--- stamp-0.9.10/yada/yada.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-g/yada/yada.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,365 +0,0 @@
-/* =============================================================================
- *
- * yada.c
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <getopt.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include "region.h"
-#include "list.h"
-#include "mesh.h"
-#include "heap.h"
-#include "thread.h"
-#include "timer.h"
-#include "tm.h"
-
-
-#define PARAM_DEFAULT_INPUTPREFIX ("")
-#define PARAM_DEFAULT_NUMTHREAD   (1L)
-#define PARAM_DEFAULT_ANGLE       (20.0)
-
-
-char*    global_inputPrefix     = PARAM_DEFAULT_INPUTPREFIX;
-long     global_numThread       = PARAM_DEFAULT_NUMTHREAD;
-double   global_angleConstraint = PARAM_DEFAULT_ANGLE;
-mesh_t*  global_meshPtr;
-heap_t*  global_workHeapPtr;
-XTM_DECL_LOCKABLE(long,     global_totalNumAdded); // = 0;
-XTM_DECL_LOCKABLE(long,     global_numProcess);//    = 0;
-
-
-/* =============================================================================
- * displayUsage
- * =============================================================================
- */
-static void
-displayUsage (const char* appName)
-{
-    printf("Usage: %s [options]\n", appName);
-    puts("\nOptions:                              (defaults)\n");
-    printf("    a <FLT>   Min [a]ngle constraint  (%lf)\n", PARAM_DEFAULT_ANGLE);
-    printf("    i <STR>   [i]nput name prefix     (%s)\n",  PARAM_DEFAULT_INPUTPREFIX);
-    printf("    t <UINT>  Number of [t]hreads     (%li)\n", PARAM_DEFAULT_NUMTHREAD);
-    exit(1);
-}
-
-
-/* =============================================================================
- * parseArgs
- * =============================================================================
- */
-static void
-parseArgs (long argc, char* const argv[])
-{
-    long i;
-    long opt;
-
-    opterr = 0;
-
-    while ((opt = getopt(argc, argv, "a:i:t:")) != -1) {
-        switch (opt) {
-            case 'a':
-                global_angleConstraint = atof(optarg);
-                break;
-            case 'i':
-                global_inputPrefix = optarg;
-                break;
-            case 't':
-                global_numThread = atol(optarg);
-                break;
-            case '?':
-            default:
-                opterr++;
-                break;
-        }
-    }
-
-    for (i = optind; i < argc; i++) {
-        fprintf(stderr, "Non-option argument: %s\n", argv[i]);
-        opterr++;
-    }
-
-    if (opterr) {
-        displayUsage(argv[0]);
-    }
-}
-
-
-/* =============================================================================
- * initializeWork
- * =============================================================================
- */
-static long
-initializeWork (heap_t* workHeapPtr, mesh_t* meshPtr)
-{
-    random_t* randomPtr = random_alloc();
-    random_seed(randomPtr, 0);
-    mesh_shuffleBad(meshPtr, randomPtr);
-    random_free(randomPtr);
-
-    long numBad = 0;
-
-    while (1) {
-        element_t* elementPtr = mesh_getBad(meshPtr);
-        if (!elementPtr) {
-            break;
-        }
-        numBad++;
-        bool_t status = heap_insert(workHeapPtr, (void*)elementPtr);
-        assert(status);
-        element_setIsReferenced(elementPtr, TRUE);
-    }
-
-    return numBad;
-}
-
-
-/* =============================================================================
- * process
- * =============================================================================
- */
-void
-process ()
-{
-    TM_THREAD_ENTER();
-
-    heap_t* workHeapPtr = global_workHeapPtr;
-    mesh_t* meshPtr = global_meshPtr;
-    region_t* regionPtr;
-    long totalNumAdded = 0;
-    long numProcess = 0;
-
-    regionPtr = PREGION_ALLOC();
-    assert(regionPtr);
-
-    while (1) {
-
-        element_t* elementPtr;
-
-        TM_BEGIN();
-        elementPtr = TMHEAP_REMOVE(workHeapPtr);
-        TM_END();
-        if (elementPtr == NULL) {
-            break;
-        }
-
-        bool_t isGarbage;
-        TM_BEGIN();
-        isGarbage = TMELEMENT_ISGARBAGE(elementPtr);
-        TM_END();
-        if (isGarbage) {
-            /*
-             * Handle delayed deallocation
-             */
-            PELEMENT_FREE(elementPtr);
-            continue;
-        }
-
-        long numAdded;
-
-        TM_BEGIN();
-        PREGION_CLEARBAD(regionPtr);
-        numAdded = TMREGION_REFINE(regionPtr, elementPtr, meshPtr);
-        TM_END();
-
-        TM_BEGIN();
-        TMELEMENT_SETISREFERENCED(elementPtr, FALSE);
-        isGarbage = TMELEMENT_ISGARBAGE(elementPtr);
-        TM_END();
-        if (isGarbage) {
-            /*
-             * Handle delayed deallocation
-             */
-            PELEMENT_FREE(elementPtr);
-        }
-
-        totalNumAdded += numAdded;
-
-        TM_BEGIN();
-        TMREGION_TRANSFERBAD(regionPtr, workHeapPtr);
-        TM_END();
-
-        numProcess++;
-
-    }
-
-    TM_BEGIN();
-    TM_SHARED_WRITE(global_totalNumAdded,
-                    TM_SHARED_READ(global_totalNumAdded) + totalNumAdded);
-    TM_SHARED_WRITE(global_numProcess,
-                    TM_SHARED_READ(global_numProcess) + numProcess);
-    TM_END();
-
-    PREGION_FREE(regionPtr);
-
-    TM_THREAD_EXIT();
-}
-
-
-/* =============================================================================
- * main
- * =============================================================================
- */
-MAIN(argc, argv)
-{
-    GOTO_REAL();
-
-    /*
-     * Initialization
-     */
-
-    parseArgs(argc, (char** const)argv);
-    SIM_GET_NUM_CPU(global_numThread);
-    TM_STARTUP(global_numThread);
-    P_MEMORY_STARTUP(global_numThread);
-    thread_startup(global_numThread);
-    global_meshPtr = mesh_alloc();
-    assert(global_meshPtr);
-    printf("Angle constraint = %lf\n", global_angleConstraint);
-    printf("Reading input... ");
-    long initNumElement = mesh_read(global_meshPtr, global_inputPrefix);
-    puts("done.");
-    global_workHeapPtr = heap_alloc(1, &element_heapCompare);
-    assert(global_workHeapPtr);
-    long initNumBadElement = initializeWork(global_workHeapPtr, global_meshPtr);
-
-    printf("Initial number of mesh elements = %li\n", initNumElement);
-    printf("Initial number of bad elements  = %li\n", initNumBadElement);
-    printf("Starting triangulation...");
-    fflush(stdout);
-
-    /*
-     * Run benchmark
-     */
-
-    TIMER_T start;
-    TIMER_READ(start);
-    GOTO_SIM();
-    thread_begin_timing();
-#ifdef OTM
-#pragma omp parallel
-    {
-        process();
-    }
-#else
-    thread_start(process, NULL);
-#endif
-    thread_end_timing();
-    GOTO_REAL();
-    TIMER_T stop;
-    TIMER_READ(stop);
-
-    puts(" done.");
-    printf("Elapsed time                    = %0.3lf\n",
-           TIMER_DIFF_SECONDS(start, stop));
-    printf("STAMP time = %0.3lf\n",
-           TIMER_DIFF_SECONDS(start, stop));
-    fflush(stdout);
-
-    /*
-     * Check solution
-     */
-
-    long finalNumElement = initNumElement + XTM_LOCKABLE_VALUE(global_totalNumAdded);
-    printf("Final mesh size                 = %li\n", finalNumElement);
-    printf("Number of elements processed    = %li\n", XTM_LOCKABLE_VALUE(global_numProcess));
-    fflush(stdout);
-
-#if 0
-    bool_t isSuccess = mesh_check(global_meshPtr, finalNumElement);
-#else
-    bool_t isSuccess = TRUE;
-#endif
-    printf("Final mesh is %s\n", (isSuccess ? "valid." : "INVALID!"));
-    fflush(stdout);
-    assert(isSuccess);
-
-    /*
-     * TODO: deallocate mesh and work heap
-     */
-
-    TM_SHUTDOWN();
-    P_MEMORY_SHUTDOWN();
-
-    GOTO_SIM();
-
-    thread_shutdown();
-
-    MAIN_RETURN(0);
-}
-
-
-/* =============================================================================
- *
- * End of ruppert.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/yada/yada.cpp stamp-g/yada/yada.cpp
--- stamp-0.9.10/yada/yada.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-g/yada/yada.cpp	2017-03-21 18:41:04.000000000 +0000
@@ -0,0 +1,368 @@
+/* =============================================================================
+ *
+ * yada.c
+ *
+ * =============================================================================
+ *
+ * Copyright (C) Stanford University, 2006.  All Rights Reserved.
+ * Author: Chi Cao Minh
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+
+#include "Galois/Galois.h"
+#include "Galois/Accumulator.h"
+#include "Galois/Bag.h"
+
+#include <assert.h>
+#include <getopt.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "region.h"
+#include "list.h"
+#include "mesh.h"
+#include "thread.h"
+#include "timer.h"
+#include "tm.h"
+
+
+#define PARAM_DEFAULT_INPUTPREFIX ("")
+#define PARAM_DEFAULT_NUMTHREAD   (1L)
+#define PARAM_DEFAULT_ANGLE       (20.0)
+
+
+char*    global_inputPrefix     = PARAM_DEFAULT_INPUTPREFIX;
+long     global_numThread       = PARAM_DEFAULT_NUMTHREAD;
+double   global_angleConstraint = PARAM_DEFAULT_ANGLE;
+mesh_t*  global_meshPtr;
+heap_t*  global_workHeapPtr;
+long     global_totalNumAdded = 0;
+long     global_numProcess    = 0;
+
+
+/* =============================================================================
+ * displayUsage
+ * =============================================================================
+ */
+static void
+displayUsage (const char* appName)
+{
+    printf("Usage: %s [options]\n", appName);
+    puts("\nOptions:                              (defaults)\n");
+    printf("    a <FLT>   Min [a]ngle constraint  (%lf)\n", PARAM_DEFAULT_ANGLE);
+    printf("    i <STR>   [i]nput name prefix     (%s)\n",  PARAM_DEFAULT_INPUTPREFIX);
+    printf("    t <UINT>  Number of [t]hreads     (%li)\n", PARAM_DEFAULT_NUMTHREAD);
+    exit(1);
+}
+
+
+/* =============================================================================
+ * parseArgs
+ * =============================================================================
+ */
+static void
+parseArgs (long argc, char* const argv[])
+{
+    long i;
+    long opt;
+
+    opterr = 0;
+
+    while ((opt = getopt(argc, argv, "a:i:t:")) != -1) {
+        switch (opt) {
+            case 'a':
+                global_angleConstraint = atof(optarg);
+                break;
+            case 'i':
+                global_inputPrefix = optarg;
+                break;
+            case 't':
+                global_numThread = atol(optarg);
+                break;
+            case '?':
+            default:
+                opterr++;
+                break;
+        }
+    }
+
+    for (i = optind; i < argc; i++) {
+        fprintf(stderr, "Non-option argument: %s\n", argv[i]);
+        opterr++;
+    }
+
+    if (opterr) {
+        displayUsage(argv[0]);
+    }
+}
+
+
+/* =============================================================================
+ * initializeWork
+ * =============================================================================
+ */
+static long
+initializeWork (heap_t* workHeapPtr, mesh_t* meshPtr)
+{
+    random_t* randomPtr = random_alloc();
+    random_seed(randomPtr, 0);
+    mesh_shuffleBad(meshPtr, randomPtr);
+    random_free(randomPtr);
+
+    long numBad = 0;
+
+    while (1) {
+        element_t* elementPtr = mesh_getBad(meshPtr);
+        if (!elementPtr) {
+            break;
+        }
+        numBad++;
+        bool_t status = vector_pushBack(workHeapPtr, (void*)elementPtr);
+        assert(status);
+        element_setIsReferenced(elementPtr, TRUE);
+    }
+
+    return numBad;
+}
+
+
+struct Fn1 {
+    typedef int tt_needs_per_iter_alloc;
+    mesh_t* meshPtr;
+    Galois::GAccumulator<long>& numProcess;
+    Galois::GAccumulator<long>& totalNumAdded;
+    Galois::InsertBag<element_t>& elementAlloc;
+
+    void operator()(void* voidPtr, Galois::UserContext<void*>& ctx) {
+        element_t* elementPtr = (element_t*) voidPtr;
+        bool_t isGarbage;
+        region_t region;
+
+        TM_BEGIN();
+        elementPtr->acquire();
+        isGarbage = TMELEMENT_ISGARBAGE(elementPtr);
+        TM_END();
+        if (isGarbage) {
+            /*
+             * Handle delayed deallocation
+             */
+            PELEMENT_FREE(elementPtr);
+            return;
+        }
+
+        long numAdded;
+
+        TM_BEGIN();
+        PREGION_CLEARBAD(&region);
+        RefineLog refineLog(ctx.getPerIterAlloc());
+        numAdded = TMREGION_REFINE(&region, elementPtr, meshPtr, elementAlloc, ctx.getPerIterAlloc(), refineLog);
+        refineLog.clear();
+        //Galois::Runtime::checkWrite(Galois::MethodFlag::WRITE, false); // XXX: Failsafe point
+        TM_END();
+
+        TM_BEGIN();
+        TMELEMENT_SETISREFERENCED(elementPtr, FALSE);
+        isGarbage = TMELEMENT_ISGARBAGE(elementPtr);
+        TM_END();
+        if (isGarbage) {
+            /*
+             * Handle delayed deallocation
+             */
+            PELEMENT_FREE(elementPtr);
+        }
+
+        totalNumAdded += numAdded;
+
+        TM_BEGIN();
+        TMREGION_TRANSFERBAD(&region, ctx);
+        TM_END();
+
+        numProcess += 1;
+    }
+};
+
+/* =============================================================================
+ * process
+ * =============================================================================
+ */
+void
+process (Galois::InsertBag<element_t>& elementAlloc)
+{
+    TM_THREAD_ENTER();
+
+    //heap_t* workHeapPtr = global_workHeapPtr;
+    Galois::GAccumulator<long> numProcess;
+    Galois::GAccumulator<long> totalNumAdded;
+    Fn1 fn1 = { global_meshPtr, numProcess, totalNumAdded, elementAlloc };
+
+    Galois::for_each(global_workHeapPtr->begin(), global_workHeapPtr->end(), fn1,
+        Galois::wl<Galois::WorkList::AltChunkedLIFO<32>>());
+
+    global_totalNumAdded += totalNumAdded.reduce();
+    global_numProcess += numProcess.reduce();
+
+    TM_THREAD_EXIT();
+}
+
+
+/* =============================================================================
+ * main
+ * =============================================================================
+ */
+MAIN(argc, argv)
+{
+    GOTO_REAL();
+
+    /*
+     * Initialization
+     */
+
+    Galois::InsertBag<element_t> elementAlloc;
+
+    parseArgs(argc, (char** const)argv);
+    SIM_GET_NUM_CPU(global_numThread);
+    TM_STARTUP(global_numThread);
+    P_MEMORY_STARTUP(global_numThread);
+    thread_startup(global_numThread);
+    global_meshPtr = mesh_alloc();
+    assert(global_meshPtr);
+    printf("Angle constraint = %lf\n", global_angleConstraint);
+    printf("Reading input... ");
+    long initNumElement = mesh_read(global_meshPtr, global_inputPrefix);
+    puts("done.");
+    global_workHeapPtr = vector_alloc(1);//heap_alloc(1, &element_heapCompare);
+    assert(global_workHeapPtr);
+    long initNumBadElement = initializeWork(global_workHeapPtr, global_meshPtr);
+
+    printf("Initial number of mesh elements = %li\n", initNumElement);
+    printf("Initial number of bad elements  = %li\n", initNumBadElement);
+    printf("Starting triangulation...");
+    fflush(stdout);
+
+    /*
+     * Run benchmark
+     */
+
+    Galois::preAlloc(15 * global_numThread + Galois::Runtime::MM::numPageAllocTotal() * 4);
+    Galois::reportPageAlloc("MeminfoPre");
+
+    TIMER_T start;
+    GOTO_SIM();
+    thread_begin_timing();
+    TIMER_READ(start);
+    {
+        process(elementAlloc);
+    }
+    TIMER_T stop;
+    TIMER_READ(stop);
+    thread_end_timing();
+    GOTO_REAL();
+    Galois::reportPageAlloc("MeminfoPost");
+
+    puts(" done.");
+    printf("Elapsed time                    = %0.3lf\n",
+           TIMER_DIFF_SECONDS(start, stop));
+    printf("STAMP time = %0.3lf\n",
+           TIMER_DIFF_SECONDS(start, stop));
+    fflush(stdout);
+
+    /*
+     * Check solution
+     */
+
+    long finalNumElement = initNumElement + global_totalNumAdded;
+    printf("Final mesh size                 = %li\n", finalNumElement);
+    printf("Number of elements processed    = %li\n", global_numProcess);
+    fflush(stdout);
+
+#if 0
+    bool_t isSuccess = mesh_check(global_meshPtr, finalNumElement);
+    // XXX(ddn): finalNumElement is likely to be wrong when running
+    // with tinySTM because the accumulation is not transactionalized
+    isSuccess = TRUE;
+#else
+    bool_t isSuccess = TRUE;
+#endif
+    printf("Final mesh is %s\n", (isSuccess ? "valid." : "INVALID!"));
+    fflush(stdout);
+    assert(isSuccess);
+
+    /*
+     * TODO: deallocate mesh and work heap
+     */
+
+    TM_SHUTDOWN();
+    P_MEMORY_SHUTDOWN();
+
+    GOTO_SIM();
+
+    thread_shutdown();
+
+    MAIN_RETURN(0);
+}
+
+
+/* =============================================================================
+ *
+ * End of ruppert.c
+ *
+ * =============================================================================
+ */
